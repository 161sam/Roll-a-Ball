"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[884],{8359:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"development/AGENTS-INDEX","title":"\ud83e\udd16 AGENTEN-\xdcBERSICHT","description":"In diesem Dokument werden die verschiedenen KI-Agenten (OpenAI Codex, Claude via Unity MCP) beschrieben, die zur Analyse, Korrektur und Erweiterung des Roll-a-Ball Projekts eingesetzt werden. Jeder Agent fokussiert sich auf eine bestimmte Phase oder Komponente der Entwicklung mit klar definierten Zielen, Arbeitsschritten und Erfolgsindikatoren.","source":"@site/docs/development/AGENTS-INDEX.md","sourceDirName":"development","slug":"/development/AGENTS-INDEX","permalink":"/Roll-a-Ball/docs/development/AGENTS-INDEX","draft":false,"unlisted":false,"editUrl":"https://github.com/161sam/Roll-a-Ball/edit/main/wiki/docs/development/AGENTS-INDEX.md","tags":[],"version":"current","frontMatter":{}}');var t=i(4848),s=i(8453);const l={},d="\ud83e\udd16 AGENTEN-\xdcBERSICHT",a={},o=[{value:"\ud83c\udfaf Agentenauftrag: Roll-a-Ball Scene Normalisierung &amp; UI-Korrektur (Phase 3)",id:"-agentenauftrag-roll-a-ball-scene-normalisierung--ui-korrektur-phase-3",level:2},{value:"\ud83e\udde0 Agentenname",id:"-agentenname",level:3},{value:"\ud83d\uddc2\ufe0f Projektverzeichnis",id:"\ufe0f-projektverzeichnis",level:3},{value:"\ud83d\udd0d Ziel",id:"-ziel",level:3},{value:"\ud83d\udccc Auftragsschritte",id:"-auftragsschritte",level:3},{value:"1. Szene-Erkennung",id:"1-szene-erkennung",level:4},{value:"2. Szenen laden &amp; analysieren",id:"2-szenen-laden--analysieren",level:4},{value:"3. Fehlerbericht &amp; Korrekturvorschl\xe4ge",id:"3-fehlerbericht--korrekturvorschl\xe4ge",level:4},{value:"4. Optional: Automatisierte Korrektur",id:"4-optional-automatisierte-korrektur",level:4},{value:"\u2705 Erfolgsbedingungen",id:"-erfolgsbedingungen",level:3},{value:"\ud83e\uddfe Status-Tracking",id:"-status-tracking",level:3},{value:"\ud83e\udde0 Agentenlogik",id:"-agentenlogik",level:3},{value:"\ud83c\udfaf Agentenauftrag: OpenStreetMap Integration (Phase 4)",id:"-agentenauftrag-openstreetmap-integration-phase-4",level:2},{value:"\ud83e\udde0 Agentenname",id:"-agentenname-1",level:3},{value:"\ud83d\uddc2\ufe0f Projektverzeichnis",id:"\ufe0f-projektverzeichnis-1",level:3},{value:"\ud83d\udd0d Ziel",id:"-ziel-1",level:3},{value:"\ud83d\udccc Auftragsschritte",id:"-auftragsschritte-1",level:3},{value:"1. OSM-Framework einbinden",id:"1-osm-framework-einbinden",level:4},{value:"2. Kartengenerierung implementieren",id:"2-kartengenerierung-implementieren",level:4},{value:"3. Scene Setup &amp; UI-Integration",id:"3-scene-setup--ui-integration",level:4},{value:"4. Testing &amp; Fallbacks",id:"4-testing--fallbacks",level:4},{value:"5. Optional: Erweiterte Features",id:"5-optional-erweiterte-features",level:4},{value:"\u2705 Erfolgsbedingungen",id:"-erfolgsbedingungen-1",level:3},{value:"\ud83e\udde0 Agentenlogik",id:"-agentenlogik-1",level:3},{value:"\ud83c\udfaf Agentenauftrag: Multiplayer-Kompatibilit\xe4t (Phase 5)",id:"-agentenauftrag-multiplayer-kompatibilit\xe4t-phase-5",level:2},{value:"\ud83e\udde0 Agentenname",id:"-agentenname-2",level:3},{value:"\ud83d\uddc2\ufe0f Projektverzeichnis",id:"\ufe0f-projektverzeichnis-2",level:3},{value:"\ud83d\udd0d Ziel",id:"-ziel-2",level:3},{value:"\ud83d\udccc Auftragsschritte",id:"-auftragsschritte-2",level:3},{value:"1. Networking-Framework einrichten",id:"1-networking-framework-einrichten",level:4},{value:"2. Spielobjekte f\xfcr Networking vorbereiten",id:"2-spielobjekte-f\xfcr-networking-vorbereiten",level:4},{value:"3. UI &amp; Spiellogik anpassen",id:"3-ui--spiellogik-anpassen",level:4},{value:"4. Multiplayer-Test &amp; Feinschliff",id:"4-multiplayer-test--feinschliff",level:4},{value:"5. Optional: Erweiterte Mehrspieler-Features",id:"5-optional-erweiterte-mehrspieler-features",level:4},{value:"\u2705 Erfolgsbedingungen",id:"-erfolgsbedingungen-2",level:3},{value:"\ud83e\udde0 Agentenlogik",id:"-agentenlogik-2",level:3},{value:"\ud83c\udfaf Agentenauftrag: Performance-Optimierung &amp; Build-Automatisierung (Phase 6)",id:"-agentenauftrag-performance-optimierung--build-automatisierung-phase-6",level:2},{value:"\ud83e\udde0 Agentenname",id:"-agentenname-3",level:3},{value:"\ud83d\uddc2\ufe0f Projektverzeichnis",id:"\ufe0f-projektverzeichnis-3",level:3},{value:"\ud83d\udd0d Ziel",id:"-ziel-3",level:3},{value:"\ud83d\udccc Auftragsschritte",id:"-auftragsschritte-3",level:3},{value:"1. Profiling &amp; Analyse",id:"1-profiling--analyse",level:4},{value:"2. Code- und Szenenoptimierung",id:"2-code--und-szenenoptimierung",level:4},{value:"3. Automatisierte Build-Pipeline einrichten",id:"3-automatisierte-build-pipeline-einrichten",level:4},{value:"4. Multi-Plattform Tests",id:"4-multi-plattform-tests",level:4},{value:"5. Optional: Ver\xf6ffentlichungsvorbereitung",id:"5-optional-ver\xf6ffentlichungsvorbereitung",level:4},{value:"\u2705 Erfolgsbedingungen",id:"-erfolgsbedingungen-3",level:3},{value:"\ud83e\udde0 Agentenlogik",id:"-agentenlogik-3",level:3}];function h(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"-agenten-\xfcbersicht",children:"\ud83e\udd16 AGENTEN-\xdcBERSICHT"})}),"\n",(0,t.jsxs)(n.p,{children:["In diesem Dokument werden die verschiedenen ",(0,t.jsx)(n.strong,{children:"KI-Agenten"})," (OpenAI Codex, Claude via Unity MCP) beschrieben, die zur Analyse, Korrektur und Erweiterung des Roll-a-Ball Projekts eingesetzt werden. Jeder Agent fokussiert sich auf eine bestimmte Phase oder Komponente der Entwicklung mit klar definierten Zielen, Arbeitsschritten und Erfolgsindikatoren."]}),"\n",(0,t.jsx)(n.h2,{id:"-agentenauftrag-roll-a-ball-scene-normalisierung--ui-korrektur-phase-3",children:"\ud83c\udfaf Agentenauftrag: Roll-a-Ball Scene Normalisierung & UI-Korrektur (Phase 3)"}),"\n",(0,t.jsx)(n.h3,{id:"-agentenname",children:"\ud83e\udde0 Agentenname"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"SceneNormalizerAgent"})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-projektverzeichnis",children:"\ud83d\uddc2\ufe0f Projektverzeichnis"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"/home/saschi/Games/Roll-a-Ball/"})}),"\n",(0,t.jsx)(n.h3,{id:"-ziel",children:"\ud83d\udd0d Ziel"}),"\n",(0,t.jsxs)(n.p,{children:["Alle Unity-Szenen im Projekt sollen ",(0,t.jsx)(n.strong,{children:"konsistent, funktionsf\xe4hig und prefab-basiert"})," aufgebaut sein. Insbesondere m\xfcssen UI-Elemente korrekt verankert, referenziert und benutzbar sein. Dieser Agent identifiziert systematisch Abweichungen in den Szenen und dokumentiert sowie korrigiert diese."]}),"\n",(0,t.jsx)(n.h3,{id:"-auftragsschritte",children:"\ud83d\udccc Auftragsschritte"}),"\n",(0,t.jsx)(n.h4,{id:"1-szene-erkennung",children:"1. Szene-Erkennung"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Alle ",(0,t.jsx)(n.code,{children:".unity"}),"-Dateien im Verzeichnis ",(0,t.jsx)(n.code,{children:"Assets/Scenes/"})," werden aufgelistet (z.\u202fB. ",(0,t.jsx)(n.em,{children:"GeneratedLevel.unity"}),", ",(0,t.jsx)(n.em,{children:"Level1.unity"}),", ",(0,t.jsx)(n.em,{children:"Level2.unity"}),", ",(0,t.jsx)(n.em,{children:"Level3.unity"}),", ",(0,t.jsx)(n.em,{children:"Level_OSM.unity"}),", ",(0,t.jsx)(n.em,{children:"MiniGame.unity"}),")."]}),"\n",(0,t.jsx)(n.li,{children:"Es wird eine Liste aller Szenennamen mit ihren Speicherpfaden erstellt, um sicherzustellen, dass keine Szene \xfcbersehen wird."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-szenen-laden--analysieren",children:"2. Szenen laden & analysieren"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Der Agent l\xe4dt jede gefundene Szene nacheinander im Unity Editor (\xfcber Unity MCP) und inspiziert systematisch alle ",(0,t.jsx)(n.strong,{children:"GameObjects"}),", ",(0,t.jsx)(n.strong,{children:"UI-Elemente"})," und ",(0,t.jsx)(n.strong,{children:"Prefab-Referenzen"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Folgende Pr\xfcfkategorien werden f\xfcr jede Szene durchlaufen:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Prefab-Check:"})," Pr\xfcfen, ob ",(0,t.jsx)(n.strong,{children:"Ground"}),", ",(0,t.jsx)(n.strong,{children:"Wall"}),", ",(0,t.jsx)(n.strong,{children:"Collectible"})," und ",(0,t.jsx)(n.strong,{children:"GoalZone"})," als Instanzen der vorgesehenen Prefabs platziert sind. Manuell duplizierte Objekte (statt Prefab-Nutzung) werden erkannt. Ebenso wird \xfcberpr\xfcft, ob ben\xf6tigte Skripte wie ",(0,t.jsx)(n.code,{children:"CollectibleController"})," oder ",(0,t.jsx)(n.code,{children:"GoalZoneTrigger"})," an den Objekten h\xe4ngen."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"UI-Check:"})," Sicherstellen, dass ein funktionierender ",(0,t.jsx)(n.strong,{children:"Canvas"})," mit korrekt eingestelltem ",(0,t.jsx)(n.code,{children:"CanvasScaler"})," (Scale With Screen Size) und ein ",(0,t.jsx)(n.strong,{children:"EventSystem"})," vorhanden sind. Alle UI-Textfelder und Buttons m\xfcssen richtig verankert sein (Anchors) und ein ",(0,t.jsx)(n.code,{children:"UIController"})," sollte existieren und mit den UI-Elementen verkn\xfcpft sein."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hierarchie-Check:"})," \xdcberpr\xfcfen, ob alle obligatorischen Objekte in der Szene vorhanden und richtig konfiguriert sind:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Main Camera:"})," Existiert und hat das Skript ",(0,t.jsx)(n.code,{children:"CameraFollow"})," (oder entsprechendes Kamerasteuerungs-Skript) angeh\xe4ngt."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Player:"})," Existiert mit dem ",(0,t.jsx)(n.code,{children:"PlayerController"}),"-Skript und korrekten Physik-Einstellungen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GameManager / LevelManager:"})," Entsprechende Manager-Objekte sind in der Szene und verwalten den Spielzustand (z.\u202fB. Level-Fortschritt, Punktestand)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Tags & Layers:"})," Wichtige Objekte tragen die erwarteten Tags (z.\u202fB. Player, Collectible) und befinden sich auf den korrekten Layers (z.\u202fB. Ground, Obstacles), damit Kollisionen und Trigger einheitlich funktionieren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Spezial-Objekte:"})," Falls die Szene steampunk-spezifische Objekte enth\xe4lt (z.\u202fB. ",(0,t.jsx)(n.code,{children:"MovingPlatform"}),", ",(0,t.jsx)(n.code,{children:"RotatingObstacle"}),", Tore), wird gepr\xfcft, ob diese die n\xf6tigen Komponenten/Skripte besitzen und ordnungsgem\xe4\xdf funktionieren."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-fehlerbericht--korrekturvorschl\xe4ge",children:"3. Fehlerbericht & Korrekturvorschl\xe4ge"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["F\xfcr jede Szene erstellt der Agent einen Markdown-Bericht ",(0,t.jsx)(n.code,{children:"SceneReport_<Szene>.md"}),". Darin werden ",(0,t.jsx)(n.strong,{children:"abweichende Befunde"})," festgehalten, z.\u202fB. fehlende Prefab-Verwendung, falsche Komponenten oder defekte UI-Elemente."]}),"\n",(0,t.jsxs)(n.li,{children:["Unter ",(0,t.jsx)(n.em,{children:"\u26a0\ufe0f Probleme"})," listet der Bericht alle gefundenen Fehler und Inkonsistenzen (z.\u202fB. ",(0,t.jsx)(n.em,{children:'"Collectible X ist kein Prefab-Instance"'}),", ",(0,t.jsx)(n.em,{children:'"CanvasScaler fehlt auf Canvas"'}),", ",(0,t.jsx)(n.em,{children:'"Player fehlt Tag=Player"'}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Unter ",(0,t.jsx)(n.em,{children:"\u2705 Empfehlungen"})," folgen konkrete Vorschl\xe4ge zur Behebung jedes Problems (etwa Ersatz eines duplizierten Objekts durch das entsprechende Prefab, Hinzuf\xfcgen eines EventSystems, Zuweisung fehlender Skriptreferenzen)."]}),"\n",(0,t.jsxs)(n.li,{children:["Au\xdferdem enth\xe4lt der Bericht einen Abschnitt ",(0,t.jsx)(n.em,{children:"\ud83d\udd04 Konsolidierungsvorschl\xe4ge"}),", der zusammenfasst, wie die Szene insgesamt an den Standard angepasst werden kann (z.\u202fB. Ersetzen aller Boden-Objekte durch ",(0,t.jsx)(n.code,{children:"GroundPrefab"}),", Neuaufbau der UI anhand einer funktionierenden Vorlage). Abschlie\xdfend gibt eine ",(0,t.jsx)(n.em,{children:"\ud83d\udcca Statistik"})," einen \xdcberblick, wie viele Prefabs korrekt bzw. falsch instanziert wurden (z.\u202fB. ",(0,t.jsx)(n.em,{children:"10/12 Prefabs konsistent"}),")."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"4-optional-automatisierte-korrektur",children:"4. Optional: Automatisierte Korrektur"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Wenn konfiguriert, nimmt der Agent direkt Korrekturen in den Szenen vor: Manuell duplizierte Objekte werden ",(0,t.jsx)(n.strong,{children:"gel\xf6scht und durch Prefab-Instanzen ersetzt"}),". Fehlende Canvas-Elemente (Canvas, EventSystem) werden neu erstellt mit korrekten Einstellungen."]}),"\n",(0,t.jsxs)(n.li,{children:["UI-Elemente, die falsch verankert sind, werden neu positioniert oder mit geeigneten Anchor-Presets versehen. Falls die UI einer Szene unbrauchbar ist, kann der Agent optional die UI ",(0,t.jsx)(n.strong,{children:"komplett neu aufbauen"})," (entsprechend dem Standard-Layout aus einer funktionierenden Szene)."]}),"\n",(0,t.jsxs)(n.li,{children:["Einheitliche ",(0,t.jsx)(n.strong,{children:"Kamera-, Manager- und Player-Setups"})," werden in allen Szenen sichergestellt (z.\u202fB. Hinzuf\xfcgen des ",(0,t.jsx)(n.code,{children:"GameManager"}),"-Prefabs falls nicht vorhanden, Setzen der Kamera-Tag und -Follow-Skript, etc.)."]}),"\n",(0,t.jsx)(n.li,{children:"Veraltete oder duplizierte Komponenten werden entweder deaktiviert oder \u2013 falls n\xf6tig \u2013 durch neuere API-Versionen (Unity 6.1 kompatibel) ersetzt. Beispielsweise k\xf6nnten obsolete Input-Handling-Komponenten durch das neue Input-System ersetzt werden, falls dies im Projektstandard so vorgesehen ist."}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-erfolgsbedingungen",children:"\u2705 Erfolgsbedingungen"}),"\n",(0,t.jsx)(n.p,{children:"Der Agent gilt als erfolgreich, wenn anschlie\xdfend:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keine Fehler"})," oder Warnungen in der Unity-Konsole beim Laden jeder Szene auftreten."]}),"\n",(0,t.jsx)(n.li,{children:"Alle Szenen einheitlich funktionieren (Spielerbewegung, Collectibles einsammeln, Level-Abschluss etc. in jeder Szene m\xf6glich)."}),"\n",(0,t.jsx)(n.li,{children:"Die UI in allen Szenen ist vollst\xe4ndig sichtbar, responsiv (skalierend) und zeigt die richtigen Informationen an (z.\u202fB. Anzahl gesammelter Objekte, Level-Name)."}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prefab-Konsistenz > 95%"}),": Nahezu alle wiederverwendbaren Objekte in den Szenen basieren auf den vorgesehenen Prefabs statt auf Kopien."]}),"\n",(0,t.jsxs)(n.li,{children:["Alle relevanten ",(0,t.jsx)(n.strong,{children:"Skripte sind korrekt zugewiesen"})," (keine Missing Script Fehler) und wichtige Objekte haben die richtigen Tags/Layers."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Erst wenn jede Szene die obigen Kriterien erf\xfcllt, wird die Normalisierung als abgeschlossen betrachtet."}),"\n",(0,t.jsx)(n.h3,{id:"-status-tracking",children:"\ud83e\uddfe Status-Tracking"}),"\n",(0,t.jsx)(n.p,{children:"Zu jeder Szene wird der Bearbeitungsstand festgehalten:"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Szene"})}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:(0,t.jsx)(n.strong,{children:"Analysiert"})}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:(0,t.jsx)(n.strong,{children:"Fehlerfrei"})}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:(0,t.jsx)(n.strong,{children:"UI repariert"})}),(0,t.jsx)(n.th,{style:{textAlign:"center"},children:(0,t.jsx)(n.strong,{children:"Prefabs konsistent"})}),(0,t.jsx)(n.th,{children:(0,t.jsx)(n.strong,{children:"Report-Datei"})})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"GeneratedLevel"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_GeneratedLevel.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level1"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_Level1.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level2"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u274c"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\ud83d\udd04"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_Level2.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u2705"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u274c"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u274c"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\ud83d\udd04"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_Level3.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Level_OSM"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_Level_OSM.md"})})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"MiniGame"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{style:{textAlign:"center"},children:"\u23f3"}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"SceneReport_MiniGame.md"})})]})]})]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Legende:"})," \u2705 = erledigt, \u274c = Mangel/Fehler vorhanden, \ud83d\udd04 = teilweise erledigt/in Bearbeitung, \u23f3 = noch ausstehend. ",(0,t.jsx)(n.em,{children:"(Die Tabelle wird automatisch aktualisiert, sobald Berichte erstellt oder Korrekturen durchgef\xfchrt wurden.)"})]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-agentenlogik",children:"\ud83e\udde0 Agentenlogik"}),"\n",(0,t.jsxs)(n.p,{children:["Der ",(0,t.jsx)(n.strong,{children:"SceneNormalizerAgent"})," verwendet ",(0,t.jsx)(n.em,{children:"OpenAI Codex"})," (integriert \xfcber Unity MCP) zur Analyse und Modifikation der Unity-Szenen. Er hat Zugriff auf:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unity Editor APIs:"})," Kann Szenen programmgesteuert laden (",(0,t.jsx)(n.code,{children:"EditorSceneManager"}),"), Objekte finden (",(0,t.jsx)(n.code,{children:"FindObjectsOfType"}),"), Prefabs instanziieren und UI-Anker setzen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dateisystem:"})," Darf Projektdateien lesen und schreiben (z.\u202fB. mit ",(0,t.jsx)(n.code,{children:"read_file"}),", ",(0,t.jsx)(n.code,{children:"edit_file"})," Aktionen), um Reports zu erzeugen oder Prefab-Verkn\xfcpfungen zu \xe4ndern."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Konsole & Logs:"})," Liest Konsolenausgaben (",(0,t.jsx)(n.code,{children:"read_console"}),"), um Fehler oder Warnungen zu erkennen, die w\xe4hrend des Szenenladens auftreten."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Unity Scripting:"})," Kann Unity-Skripte ausf\xfchren, um z.\u202fB. per Script Light die Hierarchie zu pr\xfcfen oder Objekte zu ersetzen (",(0,t.jsx)(n.code,{children:"ReplaceWithPrefab"}),", ",(0,t.jsx)(n.code,{children:"FixUIAnchors"})," sind interne Routinen)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Dank dieser F\xe4higkeiten kann der Agent sowohl ",(0,t.jsx)(n.strong,{children:"diagnostizieren"})," als auch ",(0,t.jsx)(n.strong,{children:"intervenieren"}),", um die Szenen ohne manuelles Eingreifen zu reparieren. Alle \xc4nderungen erfolgen skriptgesteuert und nachvollziehbar in den generierten SceneReport-Dateien."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-agentenauftrag-openstreetmap-integration-phase-4",children:"\ud83c\udfaf Agentenauftrag: OpenStreetMap Integration (Phase 4)"}),"\n",(0,t.jsx)(n.h3,{id:"-agentenname-1",children:"\ud83e\udde0 Agentenname"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"OSMIntegrationAgent"})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-projektverzeichnis-1",children:"\ud83d\uddc2\ufe0f Projektverzeichnis"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"/home/saschi/Games/Roll-a-Ball/"})}),"\n",(0,t.jsx)(n.h3,{id:"-ziel-1",children:"\ud83d\udd0d Ziel"}),"\n",(0,t.jsxs)(n.p,{children:["Die Spielszene ",(0,t.jsx)(n.em,{children:"Level_OSM"})," soll echte Kartendaten integrieren, sodass Spieler durch Eingabe einer ",(0,t.jsx)(n.strong,{children:"Adresse"})," ihre eigene Stadt als Roll-a-Ball-Level erleben k\xf6nnen. Ziel ist eine vollst\xe4ndige ",(0,t.jsx)(n.strong,{children:"OpenStreetMap-Integration"}),": Stra\xdfenz\xfcge werden zu begehbaren Pfaden, Geb\xe4ude als Hindernisse generiert und Collectibles strategisch in der echten Umgebung platziert \u2013 alles im bestehenden Steampunk-Stil des Spiels. Die Integration muss nahtlos ins Spiel passen (UI, Gameplay, Performance) und robust gegen Fehler funktionieren (Fallback bei fehlender Internetverbindung oder ung\xfcltigen Adressen)."]}),"\n",(0,t.jsx)(n.h3,{id:"-auftragsschritte-1",children:"\ud83d\udccc Auftragsschritte"}),"\n",(0,t.jsx)(n.h4,{id:"1-osm-framework-einbinden",children:"1. OSM-Framework einbinden"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"APIs vorbereiten:"})," Der Agent richtet den Zugriff auf die OpenStreetMap-APIs ein. Dazu geh\xf6rt die ",(0,t.jsx)(n.strong,{children:"Nominatim API"})," f\xfcr Geocoding (Umwandlung von Adresse zu Koordinaten) und die ",(0,t.jsx)(n.strong,{children:"Overpass API"})," f\xfcr das Abrufen von Kartendaten (Stra\xdfen, Geb\xe4ude etc.). Es wird sichergestellt, dass keine API-Schl\xfcssel n\xf6tig sind bzw. falls doch, diese konfiguriert werden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Datenstrukturen definieren:"})," Es werden C#-Klassen f\xfcr die OSM-Daten erstellt (z.\u202fB. eine Klasse ",(0,t.jsx)(n.code,{children:"OSMMapData"})," mit Listen von Stra\xdfen, Geb\xe4uden, Fl\xe4chen und Bounds). Diese sollen serialisierbar sein, um die empfangenen JSON/XML-Daten bequem zu speichern und weiterzuverarbeiten."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"AddressResolver entwickeln:"})," Ein Skript ",(0,t.jsx)(n.code,{children:"AddressResolver"})," wird implementiert, das eine vom Spieler eingegebene Adresse entgegennimmt und asynchron die Geo-Koordinaten abruft. Bei Erfolg soll ein Event (z.\u202fB. ",(0,t.jsx)(n.code,{children:"OnMapDataReady"}),") ausgel\xf6st werden, das den Start der Kartengenerierung triggert. Fehlerf\xe4lle (kein Ergebnis, Zeit\xfcberschreitung) m\xfcssen abgefangen und gemeldet werden (z.\u202fB. via ",(0,t.jsx)(n.code,{children:"OnError"})," Event und UI-Dialog)."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-kartengenerierung-implementieren",children:"2. Kartengenerierung implementieren"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"MapGenerator entwickeln:"})," Der Agent erstellt ein zentrales Skript ",(0,t.jsx)(n.code,{children:"MapGenerator"}),", das die von ",(0,t.jsx)(n.code,{children:"AddressResolver"})," erhaltenen OSM-Daten in ",(0,t.jsx)(n.strong,{children:"Unity-GameObjects"})," umwandelt. Stra\xdfen (",(0,t.jsx)(n.code,{children:"highway"})," in OSM) werden z.\u202fB. als begehbare Wege generiert (z.\u202fB. durch Instanziieren eines Stra\xdfen-Prefabs oder Extrudieren eines Meshes entlang der Koordinaten). Geb\xe4ude (",(0,t.jsx)(n.code,{children:"building"})," in OSM) werden als Hindernisse platziert (z.\u202fB. platzierte Quader mit H\xf6he basierend auf Geb\xe4ude-Tags oder standardisiert). Parks und Gew\xe4sser k\xf6nnen mit speziellen Materialien oder flachen Objekten dargestellt werden, um visuelle Abwechslung zu bieten."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prefab-Nutzung:"})," Soweit m\xf6glich nutzt der MapGenerator vorhandene Prefabs aus dem Projekt: F\xfcr Stra\xdfen ein Boden- oder Stra\xdfen-Prefab (z.\u202fB. ",(0,t.jsx)(n.code,{children:"GroundPrefab"}),"), f\xfcr Geb\xe4ude ggf. ",(0,t.jsx)(n.code,{children:"WallPrefab"})," oder ein neues Geb\xe4ude-Prefab, f\xfcr Sammelobjekte nat\xfcrlich das vorhandene ",(0,t.jsx)(n.code,{children:"CollectiblePrefab"}),". Die ",(0,t.jsx)(n.strong,{children:"Steampunk-Optik"})," wird beibehalten, indem z.\u202fB. spezielle Materialien (Kupfer, Messing) auf die generierten Objekte gelegt werden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Player-Integration:"})," Nach Generierung der Karte wird der Spieler-Ball (",(0,t.jsx)(n.code,{children:"Player"}),"-Prefab) an der Startposition (typischerweise der Mittelpunkt der eingegebenen Adresse oder ein definierter Spawnpunkt) platziert. Sollte bereits ein Player in der Szene vorhanden sein, wird dieser ggf. repositioniert. Zus\xe4tzlich wird ein ",(0,t.jsx)(n.strong,{children:"GoalZone"}),"-Prefab in angemessener Entfernung oder an einem markanten Ort platziert, um ein Ziel f\xfcr den Spieler zu definieren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance optimieren:"})," Da potenziell viele Objekte generiert werden, achtet der Agent auf Performance-Optimierungen: Generierung findet in ",(0,t.jsx)(n.strong,{children:"Koroutinen"})," oder \xfcber mehrere Frames verteilt statt, um Frame-Drops zu vermeiden. Au\xdferdem wird ",(0,t.jsx)(n.strong,{children:"GPU Instancing"})," oder Batching aktiviert, wo immer m\xf6glich (z.\u202fB. f\xfcr viele Stra\xdfen-Segmente oder Geb\xe4ude-W\xe4nde, die alle dasselbe Material nutzen)."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-scene-setup--ui-integration",children:"3. Scene Setup & UI-Integration"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level_OSM Scene vervollst\xe4ndigen:"})," Der Agent pr\xfcft, ob die Szene ",(0,t.jsx)(n.em,{children:"Level_OSM"})," bereits alle n\xf6tigen Grund-Objekte enth\xe4lt. Falls nicht, werden diese hinzugef\xfcgt: z.\u202fB. ein ",(0,t.jsx)(n.strong,{children:"Canvas"})," mit einem Panel f\xfcr die Adresseingabe, ein ",(0,t.jsx)(n.strong,{children:"InputField"})," (f\xfcr Adresse), ein ",(0,t.jsx)(n.strong,{children:"Button"}),' ("Karte laden"), eine Text-Anzeige f\xfcr Ladefortschritt, etc. Ein EventSystem wird ebenfalls sichergestellt.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UI-Verkn\xfcpfung:"})," Ein Skript ",(0,t.jsx)(n.code,{children:"MapStartupController"}),' wird entwickelt oder konfiguriert, das die Br\xfccke zwischen UI und Backend schl\xe4gt. Dieses Skript registriert z.\u202fB. den Button-Klick ("Karte laden"), sammelt die Adresse aus dem InputField und ruft den ',(0,t.jsx)(n.code,{children:"AddressResolver"})," auf. Ebenso verwaltet es die UI-Anzeigen (Progress-Bar, Fehlermeldungen), w\xe4hrend die Karte generiert wird. Alle UI-Elemente werden korrekt im Canvas verankert, damit sie auf unterschiedlichen Aufl\xf6sungen sichtbar bleiben."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Event-Verkettung:"})," Die einzelnen Komponenten werden verbunden: ",(0,t.jsx)(n.em,{children:"AddressResolver"})," informiert ",(0,t.jsx)(n.em,{children:"MapGenerator"}),", wenn die Daten bereit sind; ",(0,t.jsx)(n.em,{children:"MapGenerator"})," informiert ",(0,t.jsx)(n.em,{children:"MapStartupController"}),", wenn die Welt aufgebaut ist. Ebenso wird das GameManager/LevelManager-System benachrichtigt, dass ein neues Level gestartet wurde, damit bestehende Systeme (z.\u202fB. Zeitnahme, Punkte) weiter funktionieren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build-Settings aktualisieren:"})," Die Szene ",(0,t.jsx)(n.em,{children:"Level_OSM"})," wird den ",(0,t.jsx)(n.strong,{children:"Build Settings"})," des Unity-Projekts hinzugef\xfcgt, damit sie auch in gebauten Versionen des Spiels enthalten ist. Der Agent pr\xfcft au\xdferdem, ob f\xfcr plattformspezifische Einstellungen etwas angepasst werden muss (z.\u202fB. Internetzugriff f\xfcr Android erlauben)."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"4-testing--fallbacks",children:"4. Testing & Fallbacks"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Funktionstest mit Beispieldaten:"})," Der Agent f\xfchrt die Szene im Play-Modus aus (ggf. via Simulation) und testet mit mehreren Beispieladressen:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:'"Leipzig, Augustusplatz"'}),": Erwartet wird das Laden einer Stadtumgebung mit Stra\xdfen und Geb\xe4uden im Zentrum von Leipzig."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Ung\xfcltige Adresse"}),' (z.\u202fB. "asdlfkj"): Es sollte eine Fehlermeldung erscheinen und ggf. das ',(0,t.jsx)(n.strong,{children:"Fallback-System"})," greifen."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Fallback-System:"})," Bei jeglichen Fehlern im Ablauf (kein Internet, API antwortet nicht, Parsing-Fehler) stellt der Agent sicher, dass ein Fallback greift. Standardm\xe4\xdfig wird eine vordefinierte Stadt (z.\u202fB. Leipzig Markt) verwendet. D.\u202fh. der Agent pr\xfcft, ob ",(0,t.jsx)(n.code,{children:"enableFallbackMode"})," in ",(0,t.jsx)(n.em,{children:"MapStartupController"})," aktiviert ist und die Fallback-Koordinaten hinterlegt sind. Bei einem erzwungenen Fallback-Durchlauf wird kontrolliert, dass zumindest eine kleine Dummy-Stadt generiert wird, damit der Spieler weiterspielen kann."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Leistungstest:"})," Nach erfolgreicher Generierung beobachtet der Agent die Framerate im Editor. Das Ziel ist, dass auch komplexere Stadt-Ausschnitte das Spiel nicht unspielbar machen. Falls n\xf6tig, macht der Agent Vorschl\xe4ge, wie die Performance weiter verbessert werden k\xf6nnte (z.\u202fB. weniger Details generieren, Simplify Meshes, kleinere Umkreissuche f\xfcr OSM-Daten)."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Speicherbereinigung:"})," Der Agent pr\xfcft, dass nach Verlassen der Szene oder beim Neustart generierte Objekte aufger\xe4umt werden (z.\u202fB. beim Laden einer neuen Adresse alte GameObjects l\xf6schen), um Speicherlecks zu vermeiden."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"5-optional-erweiterte-features",children:"5. Optional: Erweiterte Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Street View Integration:"})," Als Ausbaustufe kann der Agent einen Ausblick auf Street-View-Integration geben. Z.\u202fB. k\xf6nnte er vorschlagen, f\xfcr markante Punkte Panorama-Texturen zu laden oder ein kleines Vorschaubild aus Google Street View API einzublenden, um die Immersion zu erh\xf6hen. (Diese Schritte werden nur als Idee dokumentiert, nicht automatisch implementiert.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"GPS & Standort"}),": Perspektivisch k\xf6nnte ein ",(0,t.jsx)(n.strong,{children:"GPS-Feature"})," integriert werden, mit dem der Spieler anstelle einer Adresse seinen aktuellen Standort laden kann. Der Agent vermerkt, welche Schnittstellen daf\xfcr vorbereitet werden m\xfcssten (z.\u202fB. Unity LocationService f\xfcr mobile Plattformen)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Offline-Modus:"})," Optional wird festgehalten, wie ein Offline-Spielmodus aussehen k\xf6nnte (z.\u202fB. Nutzung zuvor geladener Kartendaten oder eines begrenzten lokalen Kartenabschnitts), falls Internet nicht verf\xfcgbar ist."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-erfolgsbedingungen-1",children:"\u2705 Erfolgsbedingungen"}),"\n",(0,t.jsx)(n.p,{children:"Die OpenStreetMap-Integration gilt als erfolgreich, wenn:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Adresseingabe und Laden"})," in ",(0,t.jsx)(n.em,{children:"Level_OSM"})," ohne Entwickler-Eingriff funktionieren: Der Spieler kann eine Adresse eingeben, auf ",(0,t.jsx)(n.em,{children:"Karte laden"})," klicken und binnen kurzer Zeit erscheint die entsprechende Spielwelt."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"OSM-Objekte korrekt generiert"})," werden: Stra\xdfen verlaufen begehbar, Geb\xe4ude stehen an plausiblen Positionen und bilden Hindernisse, Collectibles sind verteilt und erreichbar, ohne in der Luft zu schweben oder unzug\xe4nglich zu sein."]}),"\n",(0,t.jsxs)(n.li,{children:["Der ",(0,t.jsx)(n.strong,{children:"Steampunk-Stil"})," bleibt konsistent: Alle generierten Objekte verwenden die vorgesehenen Materialien, Prefabs und Effekte (z.\u202fB. Dampfeffekte in Stra\xdfen oder an Geb\xe4uden, falls vorgesehen), sodass kein Bruch im visuellen Design entsteht."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance"}),": Die generierte Szene l\xe4uft mit ausreichender Bildrate (idealerweise >30 FPS auf durchschnittlicher Hardware). Gr\xf6\xdfere Kartenabschnitte d\xfcrfen die Engine nicht einfrieren; die Ladezeit ist angemessen (ein paar Sekunden, aber keine Minuten)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stabilit\xe4t"}),": Fallbacks greifen bei Fehlern. D.\u202fh. keine Abst\xfcrze oder Endlos-Schleifen bei Netzwerkausfall oder ung\xfcltigen Eingaben. Wenn APIs ausfallen, wird automatisch die Standardstadt geladen und das Spiel bleibt spielbar."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Keine Regressionen"}),": Die Integration darf bestehende Spielmechaniken nicht brechen. Insbesondere m\xfcssen Kamerasteuerung, Playercontroller, UI-Anzeigen (Punktestand, Timer) weiterhin funktionieren, auch wenn die Level-Geometrie nun dynamisch erstellt wird."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-agentenlogik-1",children:"\ud83e\udde0 Agentenlogik"}),"\n",(0,t.jsxs)(n.p,{children:["Der ",(0,t.jsx)(n.strong,{children:"OSMIntegrationAgent"})," greift ebenfalls auf ",(0,t.jsx)(n.em,{children:"OpenAI Codex"})," \xfcber Unity MCP zur\xfcck, mit Spezialisierungen f\xfcr Web- und Datenoperationen:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"HTTP-Anfragen"}),": Der Agent kann Unity-intern Networking-Funktionen nutzen (z.\u202fB. ",(0,t.jsx)(n.code,{children:"UnityWebRequest"}),") um API-Aufrufe an Nominatim und Overpass durch den Editor zu simulieren. (Hinweis: Im Editor kann dies mit Coroutine/EditorCoroutine geschehen, da echte HTTP-Aufrufe au\xdferhalb des Spielmodus erfolgen m\xfcssen.)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Datenparsing"}),": Mithilfe von Codex generiert der Agent Parser f\xfcr das JSON/XML der API-Antworten (beispielsweise mit Newtonsoft Json oder SimpleJSON)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Scene Manipulation"}),": Der Agent verwendet Unity APIs, um Objekte zu erzeugen (",(0,t.jsx)(n.code,{children:"GameObject.Instantiate"})," f\xfcr Prefabs) und transformieren. Er kann komplexe Berechnungen (z.\u202fB. Geodaten in Unity-Koordinaten umrechnen) durchf\xfchren und direkt im Editor testen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Editor-Scripting"}),": Da Setup-Schritte oft Editor-Arbeit erfordern (z.\u202fB. Hinzuf\xfcgen der Scene zu Build Settings, Erstellen von Menu-Items), nutzt der Agent die Unity Editor Scripting API. Beispielsweise kann er ein EditorWindow erstellen (",(0,t.jsx)(n.code,{children:"OSMEditorExtension"}),"), um manuelle Eingriffe zu erleichtern, oder Men\xfcpunkte wie ",(0,t.jsx)(n.em,{children:"Roll-a-Ball \u2192 OSM \u2192 Setup OSM Scene"})," programmatisch hinzuf\xfcgen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fehleranalyse"}),": Falls w\xe4hrend der Implementierung Fehler auftreten (Exceptions, NullRefs), erkennt der Agent diese via Konsole und passt den Code entsprechend an (z.\u202fB. f\xfcgt ",(0,t.jsx)(n.code,{children:"if"}),"-Checks ein, erh\xf6ht Timeouts, etc.)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hinweis:"})," Die OSM-Integration erfordert potenziell Internetzugriff. Falls die Ausf\xfchrung in einer isolierten Umgebung erfolgt, generiert der Agent Beispiel-Datenstrukturen, um die Logik dennoch testen zu k\xf6nnen. Abschlie\xdfend aktualisiert der Agent die Projektdokumentation (z.\u202fB. erstellt/aktualisiert ",(0,t.jsx)(n.code,{children:"OSM_INTEGRATION_USER_GUIDE.md"})," und einen technischen Report ",(0,t.jsx)(n.em,{children:"PHASE_4_COMPLETE_SUMMARY.md"}),") und markiert Phase 4 im ",(0,t.jsx)(n.code,{children:"README.md"})," als abgeschlossen."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-agentenauftrag-multiplayer-kompatibilit\xe4t-phase-5",children:"\ud83c\udfaf Agentenauftrag: Multiplayer-Kompatibilit\xe4t (Phase 5)"}),"\n",(0,t.jsx)(n.h3,{id:"-agentenname-2",children:"\ud83e\udde0 Agentenname"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"MultiplayerAgent"})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-projektverzeichnis-2",children:"\ud83d\uddc2\ufe0f Projektverzeichnis"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"/home/saschi/Games/Roll-a-Ball/"})}),"\n",(0,t.jsx)(n.h3,{id:"-ziel-2",children:"\ud83d\udd0d Ziel"}),"\n",(0,t.jsxs)(n.p,{children:["Das Spiel soll ",(0,t.jsx)(n.strong,{children:"Multiplayer-f\xe4hig"})," werden, sodass mehrere Spieler gleichzeitig in den Roll-a-Ball Levels spielen k\xf6nnen. Geplant ist zun\xe4chst ein ",(0,t.jsx)(n.strong,{children:"kooperativer Modus"})," (z.\u202fB. gemeinsames Einsammeln von Collectibles) und perspektivisch auch kompetitive Elemente (Wettlauf um Punkte oder Zeit). Der Agent bereitet das Projekt auf Netzwerkf\xe4higkeit vor, passt bestehenden Code an f\xfcr mehrere Spieler und stellt sicher, dass Synchronisation, Spielablauf und UI f\xfcr alle Beteiligten korrekt funktionieren."]}),"\n",(0,t.jsx)(n.h3,{id:"-auftragsschritte-2",children:"\ud83d\udccc Auftragsschritte"}),"\n",(0,t.jsx)(n.h4,{id:"1-networking-framework-einrichten",children:"1. Networking-Framework einrichten"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Netzwerk-API Auswahl:"})," Der Agent evaluiert verf\xfcgbare Unity-Multiplayer-Frameworks (z.\u202fB. ",(0,t.jsx)(n.strong,{children:"Unity Netcode for GameObjects"})," (NGO) vs. ",(0,t.jsx)(n.strong,{children:"Mirror"})," oder Photon). F\xfcr eine Open-Source-L\xf6sung bietet sich ",(0,t.jsx)(n.em,{children:"Mirror"})," an, w\xe4hrend NGO eine offizielle L\xf6sung ist. Entscheidungskriterien (Latency, Ease of integration, Doku) werden notiert."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Grundsetup:"})," Nachdem ein Framework gew\xe4hlt ist, integriert der Agent dieses ins Projekt (entsprechende Packages importieren, ggf. Project Settings anpassen). Ein zentrales ",(0,t.jsx)(n.strong,{children:"NetworkManager"}),"-Objekt wird eingerichtet, das die Verbindung zwischen Host und Clients verwaltet. Hier definiert man z.\u202fB. maximale Spieleranzahl, Transport-Protokoll (kann z.\u202fB. UNet Transport oder KCP f\xfcr Mirror sein) und grundlegende Callbacks (OnServerConnect, OnClientDisconnect etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lobby/Testumgebung:"})," Optional erstellt der Agent eine einfache Lobby-Szene oder benutzt ",(0,t.jsx)(n.em,{children:"GeneratedLevel.unity"})," als Test, in der per Tastendruck entweder ein Host gestartet oder ein Client dem Spiel beitritt. Dies dient zum schnellen Testen der Verbindung, bevor Gameplay synchronisiert wird."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-spielobjekte-f\xfcr-networking-vorbereiten",children:"2. Spielobjekte f\xfcr Networking vorbereiten"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Player-Prefab networkf\xe4hig machen:"})," Der existierende Spieler-Ball (",(0,t.jsx)(n.code,{children:"Player"})," GameObject/Prefab) wird um Netzwerk-Funktionen erweitert. Je nach Framework wird z.\u202fB. eine ",(0,t.jsx)(n.code,{children:"NetworkIdentity"})," (Mirror) oder ",(0,t.jsx)(n.code,{children:"NetworkObject"})," (Unity Netcode) Komponente hinzugef\xfcgt. Der Player-Controller-Code muss so angepasst werden, dass er die Bewegung ",(0,t.jsx)(n.strong,{children:"nur f\xfcr den eigenen Spieler"})," ausf\xfchrt und die Position/Rotation \xfcber das Netzwerk synchronisiert. (Oft mittels ",(0,t.jsx)(n.em,{children:"Client Authority"})," oder transform sync Komponente)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronisation der Collectibles:"})," Alle ",(0,t.jsx)(n.strong,{children:"Collectible-Objekte"})," m\xfcssen bei allen Spielern konsistent sein. Der Agent \xe4ndert das Collectible-System dahingehend, dass das Einsammeln eines Objekts vom Server autoritativ gehandhabt wird: Wenn ein Spieler einsammelt, wird das Objekt auf dem Server zerst\xf6rt und dieser Zustand an alle Clients repliziert. Dies verhindert, dass verschiedene Spieler dasselbe Item mehrfach sehen oder einsammeln k\xf6nnen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goals & Trigger:"})," \xc4hnlich wie Collectibles m\xfcssen Endzonen/Trigger (z.\u202fB. ",(0,t.jsx)(n.code,{children:"GoalZone"}),") so angepasst werden, dass sie nur einmal feuern und allen Spielern das Levelende signalisieren. Der Agent implementiert, dass beim Erreichen der GoalZone durch einen beliebigen Spieler ein Event an alle gesendet wird (z.\u202fB. ",(0,t.jsx)(n.em,{children:"LevelComplete"}),"), woraufhin die Runde f\xfcr alle endet."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Multiplayer-taugliche Camera:"})," Die Kamera-Verfolgung muss pro Spieler-Instanz getrennt funktionieren. Im einfachsten Fall wird f\xfcr jeden Client die lokale Kamera verwendet, die dem eigenen Player folgt. Der Agent stellt sicher, dass die Kamera nicht versucht, mehreren Spielern gleichzeitig zu folgen. Gegebenenfalls spawnt der NetworkManager pro Client eine eigene Kamera oder der Player spawnt mit einer Kamera als Kindobjekt."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-ui--spiellogik-anpassen",children:"3. UI & Spiellogik anpassen"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"UI f\xfcr mehrere Spieler:"})," Der Agent passt die UI-Elemente wie Punktestand und Collectible-Z\xe4hler an, sodass sie pro Spieler oder f\xfcr das gesamte Team funktionieren. Beispielsweise k\xf6nnte bei kooperativem Modus allen Spielern ein gemeinsamer Collectible-Z\xe4hler (X/Y gefunden) angezeigt werden, der synchron aktualisiert wird. In kompetitiven Modi br\xe4uchte jeder Spieler eine eigene Anzeige seines Scores \u2013 hierf\xfcr kann der Agent das HUD duplizieren und an verschiedene Ecken des Bildschirms platzieren oder ein Tabellensystem einf\xfchren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Respawn/Restart-Mechanik:"}),' In Multiplayer m\xfcssen Abl\xe4ufe wie "Neustart" oder "Level neu generieren (R-Taste)" koordiniert ablaufen. Der Agent implementiert, dass ein Level-Reset vom Server initiiert wird und an alle Clients gesendet. So wird verhindert, dass nur der lokale Client neu l\xe4dt. \xc4hnlich wird bei einem Spielende (alle Collectibles gesammelt oder Zeit abgelaufen) eine Synchronisation eingef\xfchrt, damit alle Spieler gleichzeitig ins n\xe4chste Level wechseln oder zur\xfcck zur Lobby gehen.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kooperations-Logik:"})," Falls Koop-Modus, stellt der Agent sicher, dass ",(0,t.jsx)(n.strong,{children:"Team-Ziele"})," korrekt berechnet werden (z.\u202fB. Level geschafft, wenn ",(0,t.jsx)(n.em,{children:"gesamt"})," alle Collectibles gesammelt sind). Falls kompetitiv, muss die Spielwertung getrennt gef\xfchrt werden. Der Code im GameManager/LevelManager wird dahingehend erweitert, mehrere Spielerobjekte zu verwalten (evtl. Liste von Spielern statt single Player reference) und Spielzust\xe4nde pro Spieler (z.\u202fB. wer hat wie viele Collectibles) oder global zu unterscheiden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Synchronisations-Test:"})," Der Agent f\xfcgt tempor\xe4r Debug-UI oder Logs ein, um zu pr\xfcfen, ob wichtige Zust\xe4nde synchron sind (z.\u202fB. eine kleine Konsole, die anzeigt, wie viele Spieler verbunden, wie viele Collectibles aus Sicht jedes Clients verbleiben). Diese Hilfen erm\xf6glichen es, Desynchronisationen fr\xfch zu erkennen."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"4-multiplayer-test--feinschliff",children:"4. Multiplayer-Test & Feinschliff"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Lokaler Mehrspieler-Test:"})," Der Agent startet das Spiel in zwei Instanzen (im Editor als Host und in einem Build als Client, oder zwei Builds) auf dem gleichen Rechner, um den Multiplayer zu pr\xfcfen. Szenarien: Beide Spieler bewegen ihren Ball, sammeln Objekte, erreichen die Ziellinie. Es wird beobachtet, ob alle Ereignisse korrekt bei beiden ankommen. Insbesondere Latenz/Synchronisations-Verhalten (Teleportierender Ball? Rubberbanding?) wird begutachtet. Bei Bedarf schl\xe4gt der Agent Verbesserungen vor, z.\u202fB. ",(0,t.jsx)(n.strong,{children:"Interpolation"})," oder ",(0,t.jsx)(n.strong,{children:"Prediction"})," f\xfcr fl\xfcssigere Bewegung der Fremd-Players."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Edge-Case Tests:"})," Spieler verlassen das Spiel vorzeitig (Verbindungstrennung) \u2013 der Agent pr\xfcft, dass der Spielzustand damit umgehen kann (z.\u202fB. verbleibende Spieler k\xf6nnen weiter spielen, das Objekt des getrennten Spielers wird entfernt). Ebenso wird ein neuer Client mitten im Spiel getestet, falls unterst\xfctzt (Late Joiner synchronisiert aktuellen Spielstand korrekt)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance & Bandbreite:"})," Der Agent analysiert, ob die Netzwerklast im Rahmen bleibt. Falls z.\u202fB. zu viele Objekte zu h\xe4ufig Updates senden, empfiehlt er Optimierungen (z.\u202fB. Sync seltener, relevancy checks \u2013 nur nahe Objekte updaten). Auch wird geschaut, dass keine gro\xdfen Garbage-Spikes durch Netzwerk erzeugt werden (z.\u202fB. durch exzessive Allocations in Update)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Dokumentation & Kompatibilit\xe4t:"})," Abschlie\xdfend erstellt der Agent einen Report ",(0,t.jsx)(n.code,{children:"MultiplayerIntegrationReport.md"}),", der zusammenfasst, welche \xc4nderungen vorgenommen wurden, welche Einschr\xe4nkungen bestehen (z.\u202fB. ",(0,t.jsx)(n.em,{children:'"Maximal 4 Spieler getestet"'}),", ",(0,t.jsx)(n.em,{children:'"Physics derzeit nicht deterministisch synchron \u2013 kann zu Abweichungen f\xfchren"'}),") und welche Schritte f\xfcr voll robuste Multiplayer-Unterst\xfctzung noch empfohlen werden. Au\xdferdem werden im Projekt-README neue Features (Multiplayer Koop/Competitive) vermerkt, und die ",(0,t.jsx)(n.strong,{children:"Roadmap Phase 5"})," kann entsprechend als begonnen/teilerf\xfcllt markiert werden."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"5-optional-erweiterte-mehrspieler-features",children:"5. Optional: Erweiterte Mehrspieler-Features"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Globale Ranglisten:"})," Als Ausblick kann der Agent schon die Integration eines Leaderboard-Services vorschlagen. Z.\u202fB. Nutzung einer einfachen Web-API, an die Scores gemeldet werden. Dieses Feature wird noch nicht implementiert, aber in der Dokumentation als n\xe4chster Meilenstein notiert."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"T\xe4gliche Herausforderungen:"})," Der Agent skizziert, wie t\xe4gliche Herausforderungen im Multiplayer aussehen k\xf6nnten (z.\u202fB. t\xe4glich generierter Level-Seed, Koop-Zeitangriff f\xfcr alle Spieler mit Ranking). Solche Ideen werden gesammelt, um die Weiterentwicklung zu steuern."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plattform-\xdcbergreifend & VR:"})," Falls relevant, erw\xe4hnt der Agent, ob das Multiplayer-System auch f\xfcr zuk\xfcnftige VR-Unterst\xfctzung oder Cross-Platform (PC/Mobile) verwendbar ist oder welche Anpassungen n\xf6tig w\xe4ren (z.\u202fB. andere Steuerung, Networking in VR Kontext mit Motion-Sickness-Vermeidung bei Zuschauer-Modus etc.)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-erfolgsbedingungen-2",children:"\u2705 Erfolgsbedingungen"}),"\n",(0,t.jsx)(n.p,{children:"Die Multiplayer-Vorbereitung ist erfolgreich, wenn:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mehrere Spieler"})," gleichzeitig im selben Spiellevel interagieren k\xf6nnen, ohne Fehler. Beispielsweise k\xf6nnen zwei Spieler in Level1 gemeinsam alle Collectibles sammeln und das Level beenden, wobei beide Clients synchron den Abschluss registrieren."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Spielzustand Synchronit\xe4t:"}),' Wichtige Spielzust\xe4nde (Positionen der Spieler, verbleibende Collectibles, Punkte) sind bei allen Teilnehmern konsistent. Es treten keine duplizierten Objekte, "Geister-Collectibles" oder widerspr\xfcchlichen Anzeigen auf.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Stabilit\xe4t im Netzwerk:"})," Ein Verbindungsaufbau ist m\xf6glich (Spieler k\xf6nnen hosten/joinen), und das Spiel l\xe4uft \xfcber ein paar Minuten ohne Verbindungsabbruch oder mit sauberem Handling, falls doch jemand trennt. Es gibt keine massiven Lags oder unkontrollierte Physik-Effekte durch die Netzwerklatenz."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bestehender Singleplayer unver\xe4ndert:"})," Wichtig ist, dass der normale Einzelspielermodus weiterhin einwandfrei funktioniert, falls man solo spielt. Die Multiplayer-Erweiterungen d\xfcrfen das Singleplayer-Erlebnis nicht beeintr\xe4chtigen (z.\u202fB. sollte im Einzelspielermodus kein NetworkManager st\xf6ren oder Fehler werfen)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Skalierbarkeit:"})," Das System ist so ausgelegt, dass auch mehr als 2 Spieler unterst\xfctzt werden k\xf6nnten (mindestens 4 Spieler in Tests erfolgreich). Zudem sollte es m\xf6glich sein, weitere Multiplayer-Features (Chat, Team-Mechaniken) relativ einfach zu integrieren, ohne das Grundger\xfcst neu zu erfinden."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-agentenlogik-2",children:"\ud83e\udde0 Agentenlogik"}),"\n",(0,t.jsxs)(n.p,{children:["Der ",(0,t.jsx)(n.strong,{children:"MultiplayerAgent"})," nutzt OpenAI Codex, um komplexe ",(0,t.jsx)(n.strong,{children:"Netzwerk-Programmieraufgaben"})," zu bew\xe4ltigen:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Framework-Kenntnis"}),": Codex wird mit Dokumentation oder g\xe4ngigen Mustern des gew\xe4hlten Netzwerksystems angeleitet, um korrekt z.\u202fB. ",(0,t.jsx)(n.code,{children:"NetworkBehaviour"}),"-Klassen, RPCs oder Synchronisierungs-Attributes zu schreiben."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Code-Refactor"}),': Viele bestehende Klassen m\xfcssen angepasst werden. Der Agent durchforstet die Codebasis und findet Stellen, die aktuell von einem einzelnen Spieler ausgehen (z.\u202fB. Referenzen auf "Player" Objekt). Codex hilft dabei, diese so zu generalisieren, dass sie mit einer dynamischen Liste von Spielern umgehen k\xf6nnen.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Merge & Konfliktl\xf6sung"}),': Sollte das Projekt bereits fortgeschritten sein, kann das Einf\xfcgen von Networking-Code Konflikte mit bisherigen Systemen ausl\xf6sen. Der Agent nutzt Codex\u2019 Kontextverst\xe4ndnis, um L\xf6sungen zu finden (z.\u202fB. Bedingungen einzubauen "if (IsClient) return;" f\xfcr Logik, die nur am Server laufen soll, etc.).']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Testing Automation"}),": Der Agent kann kleine Testskripte generieren, die im Editor automatisiert zwei Players simulieren (z.\u202fB. zwei Editor PlayModes via Multi-Instance starten, falls unterst\xfctzt). Dies erm\xf6glicht es, wiederholt die Grundfunktionalit\xe4t zu pr\xfcfen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"KI-Unterst\xfctzte Fehlersuche"}),": Sollten Bugs auftreten (typische Netzwerkrace-Conditions, null references auf Clients, etc.), nutzt der Agent die KI, um die Ursachen im Code zu finden und zu beheben. M\xf6gliche L\xf6sungen zieht er aus bekannten Patterns (z.\u202fB. WaitForNetworkObjectSpawn, Scenes als Server synchron laden, etc.)."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Nachdem der Agent die Multiplayer-Integration fertiggestellt hat, aktualisiert er die Projektdokumentation. Die ",(0,t.jsx)(n.strong,{children:"README.md"})," erh\xe4lt einen Abschnitt \xfcber Multiplayer, und die ",(0,t.jsx)(n.em,{children:"Roadmap"}),' Phase 5 Punkte (zumindest "Multiplayer-Unterst\xfctzung") k\xf6nnen als erledigt markiert werden. Auch der erzeugte ',(0,t.jsx)(n.code,{children:"MultiplayerIntegrationReport.md"})," wird dem Repository hinzugef\xfcgt."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"-agentenauftrag-performance-optimierung--build-automatisierung-phase-6",children:"\ud83c\udfaf Agentenauftrag: Performance-Optimierung & Build-Automatisierung (Phase 6)"}),"\n",(0,t.jsx)(n.h3,{id:"-agentenname-3",children:"\ud83e\udde0 Agentenname"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"PerformanceBuildAgent"})}),"\n",(0,t.jsx)(n.h3,{id:"\ufe0f-projektverzeichnis-3",children:"\ud83d\uddc2\ufe0f Projektverzeichnis"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"/home/saschi/Games/Roll-a-Ball/"})}),"\n",(0,t.jsx)(n.h3,{id:"-ziel-3",children:"\ud83d\udd0d Ziel"}),"\n",(0,t.jsxs)(n.p,{children:["In dieser Phase wird das Spiel f\xfcr den ",(0,t.jsx)(n.strong,{children:"Release vorbereitet"}),". Zwei Hauptaspekte stehen im Fokus: zum einen die ",(0,t.jsx)(n.strong,{children:"Performance-Optimierung"})," (das Spiel soll fl\xfcssig auf den Zielplattformen laufen, ohne unn\xf6tige Ressourcen zu verbrauchen) und zum anderen die ",(0,t.jsx)(n.strong,{children:"Build-Automatisierung"})," (reibungslose Erstellung von Builds f\xfcr verschiedene Plattformen mit minimalem manuellem Aufwand). Der Agent identifiziert Performance-Engp\xe4sse im Spiel, verbessert diese und richtet Skripte/Workflows ein, um das Erstellen neuer Builds und Releases effizient zu gestalten."]}),"\n",(0,t.jsx)(n.h3,{id:"-auftragsschritte-3",children:"\ud83d\udccc Auftragsschritte"}),"\n",(0,t.jsx)(n.h4,{id:"1-profiling--analyse",children:"1. Profiling & Analyse"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Profiler-Durchlauf:"})," Der Agent f\xfchrt das Spiel in verschiedenen Szenarien aus (kleines Level, gro\xdfes Level, OSM-Level, Multiplayer) und sammelt Daten mit dem Unity Profiler. CPU-Auslastung pro Frame, Garbage Collection Spikes, Render-Stallings und GPU-Auslastung werden protokolliert. Insbesondere achtet der Agent auf ",(0,t.jsx)(n.strong,{children:"kritische Engp\xe4sse"}),": z.\u202fB. ob die ",(0,t.jsx)(n.strong,{children:"Generierungskoroutinen"})," gro\xdfe Last erzeugen, ob die ",(0,t.jsx)(n.strong,{children:"Physikberechnungen"})," (f\xfcr rollende B\xe4lle, Kollisionen) viel Zeit ben\xf6tigen oder ob die ",(0,t.jsx)(n.strong,{children:"Rendering"}),"-Last (Partikeleffekte, Beleuchtung) hoch ist."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Bottlenecks identifizieren:"})," Anhand der Profiler-Daten erstellt der Agent eine Liste der gr\xf6\xdften \xdcbelt\xe4ter. Beispielsweise k\xf6nnte herauskommen:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Hohe CPU-Last durch h\xe4ufige ",(0,t.jsx)(n.strong,{children:"Garbage Collection"})," (viele tempor\xe4re Allokierungen pro Frame)."]}),"\n",(0,t.jsx)(n.li,{children:"Frame-Drops beim Laden neuer Level (vielleicht ung\xfcnstiges Timing in der LevelGenerator-Koroutine)."}),"\n",(0,t.jsx)(n.li,{children:"Partikelsysteme mit zu vielen Partikeln gleichzeitig."}),"\n",(0,t.jsxs)(n.li,{children:["Unn\xf6tig hohe ",(0,t.jsx)(n.strong,{children:"Draw-Call"}),"-Zahlen (zu viele einzelne Objekte ohne Batching)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Diagnose-Report:"})," Diese Befunde werden in einem kurzen ",(0,t.jsx)(n.code,{children:"PerformanceReport.md"})," zusammengefasst, priorisiert nach Impact auf FPS."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"2-code--und-szenenoptimierung",children:"2. Code- und Szenenoptimierung"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Skript-Optimierungen:"})," Auf Basis der Analyse optimiert der Agent kritische Code-Stellen. Beispielsweise werden tempor\xe4re List-Allocations in der Update-Schleife vermieden, indem Lists vorab erstellt und wiederverwendet werden. Koroutinen werden gepr\xfcft, ob sie vielleicht zu gro\xdfe Arbeitspakete pro Frame erledigen \u2013 ggf. f\xfcgt der Agent zus\xe4tzliche ",(0,t.jsx)(n.code,{children:"yield"}),"-Schritte ein, um die Last zu verteilen. Physik-Abfragen (wie ",(0,t.jsx)(n.code,{children:"Physics.OverlapSphere"})," f\xfcr Collectibles) k\xf6nnten gecacht oder seltener ausgef\xfchrt werden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Object Pooling:"})," Der Agent implementiert ein ",(0,t.jsx)(n.strong,{children:"Object Pooling"}),"-System f\xfcr h\xe4ufig erstellte/destroyte Objekte (z.\u202fB. Collectibles, Partikelobjekte). Das Ziel ist, teure Instantiierung/Destruction im laufenden Spiel zu reduzieren. Es wird ein Pool angelegt, der z.\u202fB. X Collectible-Objekte vorh\xe4lt und wiederverwendet, anstatt st\xe4ndig neue zu erzeugen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Grafik-Tuning:"})," Gemeinsam mit den Entwicklern oder anhand der Zielplattformen passt der Agent die ",(0,t.jsx)(n.strong,{children:"Quality Settings"})," und Render-Optionen an. Beispielsweise k\xf6nnte die Schattenqualit\xe4t reduziert oder ein k\xfcrzerer Schattenabstand gesetzt werden, wenn das Spiel auf schw\xe4cheren Ger\xe4ten laufen soll. Auch wird gepr\xfcft, ob ",(0,t.jsx)(n.strong,{children:"Occlusion Culling"})," aktiviert und konfiguriert ist (f\xfcr die Labyrinth-Levels sinnvoll, damit nicht alle Objekte immer gerendert werden)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Level-of-Detail (LOD):"})," F\xfcr 3D-Modelle (falls vorhanden, z.\u202fB. Steampunk-Deko) richtet der Agent LOD-Stufen ein oder nutzt Unitys ",(0,t.jsx)(n.strong,{children:"LOD Group"}),"-Komponente, um weit entfernte Objekte g\xfcnstiger zu rendern. Sollte das Projekt wenige komplexe Modelle haben, ist dies ggf. vernachl\xe4ssigbar."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Mobile Optimierungen:"})," Falls Android/WebGL Targets geplant sind, sorgt der Agent f\xfcr plattformspezifische Einstellungen: z.\u202fB. Texturkompression f\xfcr Mobile, begrenzte framerate oder Abschalten von aufwendigen Post-Processing f\xfcr WebGL."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"3-automatisierte-build-pipeline-einrichten",children:"3. Automatisierte Build-Pipeline einrichten"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Build-Skripte erstellen:"})," Der Agent automatisiert den Build-Prozess mittels Unity ",(0,t.jsx)(n.strong,{children:"Batchmode"})," oder Editor-Skripten. Beispielsweise wird ein Skript ",(0,t.jsx)(n.code,{children:"BuildAll.cs"})," oder eine Reihe von Skripten erstellt, die per Men\xfc oder CLI alle Zielplattformen bauen. Diese Skripte verwenden die Unity Editor API (",(0,t.jsx)(n.code,{children:"BuildPipeline.BuildPlayer"}),") und ber\xfccksichtigen unterschiedliche Profile:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Standalone (Windows/macOS/Linux)"}),": Evtl. separate Ordner pro OS, oder zumindest Einstellungen wie x86_64 Architektur."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"Android"}),": Setzt automatisch den Build auf IL2CPP, ARM64, und signiert ggf. mit einem Keystore (Stub, falls nicht vorhanden)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.em,{children:"WebGL"}),": Aktiviert Kompression, setzt Memory Size passend, etc."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"One-Click Build:"})," Im Unity-Men\xfc erscheint unter ",(0,t.jsx)(n.em,{children:"Roll-a-Ball \u2192 Build"})," nun Optionen wie ",(0,t.jsx)(n.em,{children:"Build Standalone"}),", ",(0,t.jsx)(n.em,{children:"Build Android"}),", ",(0,t.jsx)(n.em,{children:"Build WebGL"}),". Der Agent stellt sicher, dass vor dem Build alle Szenen in Build Settings eingetragen sind (inkl. neu hinzugekommene ",(0,t.jsx)(n.em,{children:"Level_OSM"}),", etc.) und dass die Builds in einen definierten Ordnerpfad ausgegeben werden."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"CI/CD Vorbereitung:"})," Falls das Projekt auf GitHub oder einem \xe4hnlichen Repository ist, bereitet der Agent eine einfache Continuous Integration vor. Z.\u202fB. generiert er ein GitHub Actions Workflow YAML, das bei einem Push einen Unity Build Container startet und das Projekt baut (dies erfordert Unity-Lizenz in CI, was evtl. nur skizziert wird). Der Agent dokumentiert die Schritte, die n\xf6tig w\xe4ren, um das CI zum Laufen zu bringen (viele Open-Source-Projekte nutzen z.\u202fB. Game.CI images f\xfcr Unity in GitHub Actions)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"4-multi-plattform-tests",children:"4. Multi-Plattform Tests"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build-Verifizierung:"})," Der Agent f\xfchrt nach jedem erstellten Build einen kurzen Test durch. F\xfcr Standalone k\xf6nnte er automatisiert das Spiel starten (im Hintergrund) und pr\xfcfen, ob es abst\xfcrzt oder bestimmte Logs ausgibt. F\xfcr Android kann er keinen echten Lauf durchf\xfchren, aber er pr\xfcft die APK-Gr\xf6\xdfe und ob der Build \xfcberhaupt erfolgreich ist. WebGL k\xf6nnte er lokal im Browser \xf6ffnen (falls automatisierbar) oder zumindest sicherstellen, dass die Build-Dateien erzeugt wurden."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Performance nach Build:"})," Gerade auf mobilen/WebGL Plattformen testet der Agent die Performance mit den finalen Einstellungen. Er achtet auf Unterschiede zum Editor-Profiling (z.\u202fB. im WebGL-Build k\xf6nnte die Performance anders ausfallen). Falls schwere Probleme auftauchen (z.\u202fB. WebGL memory issues), nimmt er entsprechende Anpassungen vor (z.\u202fB. mehr Heap oder Asset Stripping)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Fehlerbereinigung:"})," Sollten Plattform-spezifische Fehler auftreten (z.\u202fB. ein Script benutzt eine API, die in WebGL nicht unterst\xfctzt wird), identifiziert der Agent diese via Build-Logs und passt den Code an, um die Kompatibilit\xe4t herzustellen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Abschlusstests:"})," Am Ende f\xfchrt der Agent eine vollst\xe4ndige Testrunde der wichtigsten Spielabl\xe4ufe auf jeder Plattform durch (soweit m\xf6glich). Das hei\xdft: einmal Level spielen in Standalone PC, auf Android Ger\xe4t (manuell, sofern der Agent Bericht von Testern bekommt), und WebGL im Browser. Dabei wird sichergestellt, dass die Spielerfahrung konsistent und fehlerfrei ist."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"5-optional-ver\xf6ffentlichungsvorbereitung",children:"5. Optional: Ver\xf6ffentlichungsvorbereitung"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Release Build optimieren:"})," Der Agent schl\xe4gt vor, f\xfcr einen tats\xe4chlichen Release noch Schritte wie ",(0,t.jsx)(n.strong,{children:"IL2CPP Code-Stripping"})," zu verfeinern, ",(0,t.jsx)(n.strong,{children:"Profiler"}),"-Anbindungen zu entfernen, Debug-Logs zu reduzieren, um die Build-Gr\xf6\xdfe klein und die Performance hoch zu halten."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Installationspakete:"})," Optional k\xf6nnen Skripte erweitert werden, um Installationsprogramme oder Archive zu erstellen (z.\u202fB. ZIP der Standalone-Builds, APK Signing, etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Store-Setup:"})," Der Agent dokumentiert, welche Schritte f\xfcr eine Ver\xf6ffentlichung n\xf6tig w\xe4ren (z.\u202fB. Vorbereitung einer Itch.io Seite, oder Einreichen in Google Play Store), auch wenn diese Aufgaben au\xdferhalb des direkten Code-Bereichs liegen. Dies dient als Checkliste f\xfcr die Entwickler."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Zuk\xfcnftige Automatisierung:"})," Als Ausblick kann der Agent anmerken, wie man die Tests weiter automatisieren k\xf6nnte (z.\u202fB. Integrationstests oder Verwendung von Unity Test Framework, sodass in CI nicht nur gebaut, sondern auch automatisch bestimmte Gameplay-Tests durchlaufen werden)."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-erfolgsbedingungen-3",children:"\u2705 Erfolgsbedingungen"}),"\n",(0,t.jsx)(n.p,{children:"Die Phase Performance & Build ist erfolgreich, wenn:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bildrate und Speicher"}),": Das Spiel erreicht die angestrebte ",(0,t.jsx)(n.strong,{children:"Framerate"})," (z.\u202fB. 60 FPS auf Desktop, 30+ FPS auf Mobile) in allen regul\xe4ren Szenen. Speicherverbrauch bleibt im Rahmen und es gibt keine auff\xe4lligen Memory-Leaks oder \xfcberlaufenden Garbage Collections im Spielverlauf."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reibungsloser Ablauf"}),": Level\xfcberg\xe4nge, insbesondere das prozedurale Generieren (GeneratedLevel, OSM-Level), verursachen keine merklichen Stotterer mehr. Die Spielerfahrung ist glatt und ohne lange Pausen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Kleine Build-Gr\xf6\xdfe"}),": Unn\xf6tige Dateien sind nicht im Build. Die Gesamtgr\xf6\xdfe des Builds ist optimiert (z.\u202fB. keine inkludierten Library/-Ordner, keine \xfcbergro\xdfen ungenutzten Assets). Nach M\xf6glichkeit bleibt das Projekt (vor allem WebGL) leichtgewichtig."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build-Prozess vereinfacht"}),": Ein Entwickler kann mit minimalem Aufwand einen neuen Build f\xfcr eine Plattform erzeugen, idealerweise durch einen einzelnen Befehl oder Klick. Alle wichtigen Szenen und Assets werden zuverl\xe4ssig in die Builds einbezogen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Plattform-Kompatibilit\xe4t"}),": Die Builds laufen auf den angegebenen Plattformen ohne Abst\xfcrze. Windows, Linux, macOS sollten gleicherma\xdfen bedient werden. F\xfcr Android gilt, dass die App auf einem Testger\xe4t installiert und gestartet werden kann, f\xfcr WebGL, dass es in g\xe4ngigen Browsern l\xe4dt und spielbar ist."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Automatisierungsgrad"}),": Bonus-Ziel ist erreicht, wenn ein CI-System den Build automatisiert durchf\xfchren k\xf6nnte (d.\u202fh. Skripte ohne Editor-GUI funktionieren). Auch ohne voll eingerichtetes CI soll zumindest die lokale Automatisierung zuverl\xe4ssig funktionieren."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-agentenlogik-3",children:"\ud83e\udde0 Agentenlogik"}),"\n",(0,t.jsxs)(n.p,{children:["Der ",(0,t.jsx)(n.strong,{children:"PerformanceBuildAgent"})," kombiniert F\xe4higkeiten in den Bereichen Profiling, Code-Optimierung und Automatisierung:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Profiler API & Analytics"}),": Der Agent kann via Code auf Unitys Profiler-Daten zugreifen (z.\u202fB. mit Development Build und ProfilerConnection) oder alternativ die Ausgabe des Profilers interpretieren. Gegebenenfalls werden Editor-integrierte Profiler-Markierungen (ProfilerMarkers) in den Code eingef\xfcgt, um Engp\xe4sse besser zu erkennen. Die KI hilft dabei, Muster zu erkennen (z.\u202fB. wiederkehrende GC.Alloc in bestimmten Funktionen)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Code-Verbesserung"}),": Codex kann auf Performance Best Practices zur\xfcckgreifen. Es schl\xe4gt z.\u202fB. vor, teure LINQ-Ausdr\xfccke durch herk\xf6mmliche Schleifen zu ersetzen, bestimmte Update()-Aufrufe zu reduzieren (z.\u202fB. durch Zusammenlegen von Tasks, oder Nutzung von Events statt Polling)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Parallelisierung"}),": Wo angebracht, kann der Agent den Einsatz von Unity Jobs oder Burst vorschlagen (z.\u202fB. f\xfcr massenhafte Berechnungen in der Generierung). Falls aber das Projekt nicht darauf ausgelegt ist, wird dies nur als Hinweis notiert, nicht zwingend implementiert."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Editor-Scripting f\xfcr Build"}),": Der Agent nutzt Codex, um die Unity Editor BuildPipeline korrekt anzusteuern. Dabei achtet er auf h\xe4ufige Fallen (z.\u202fB. dass Scenes in BuildSettings gesetzt sein m\xfcssen, dass Pfade existieren). Er testet die geschriebenen Build-Skripte im Editor und f\xe4ngt etwaige Exceptions ab (z.\u202fB. fehlende Berechtigung, volles Laufwerk, usw.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Integrationsskripte"}),": F\xfcr CI kann der Agent Templates nutzen (z.\u202fB. eine YAML-Vorlage von Unity CI) und passt Repository-spezifische Parameter an. Er dokumentiert jeden Schritt gut, damit Entwickler Vertrauen in den automatischen Prozess fassen."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validierungs-Checks"}),": Der Agent implementiert kleine Checks, die vor einem Build laufen, wie z.\u202fB. sicherzustellen, dass keine Development-Settings aktiv sind (Debug-Modus, Profiler attached) im Release-Build, oder dass die Versionnummer inkrementiert wurde. Diese helfen, menschliche Fehler vor Release zu minimieren."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Am Ende dieser Phase sollten alle Kernsysteme stabil und optimiert sein. Der Agent aktualisiert ",(0,t.jsx)(n.strong,{children:"README.md"})," (Performance-Metriken, Systemanforderungen) mit den neuesten Messwerten und f\xfcgt ggf. eine ",(0,t.jsx)(n.em,{children:"FINAL_SUCCESS_COMPLETE.md"})," Dokumentation hinzu, die den Abschluss des Projekts best\xe4tigt (inklusive aller implementierten Features bis Phase 6)."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["\ud83d\udccc ",(0,t.jsx)(n.strong,{children:"Letzte Aktualisierung:"})," ",(0,t.jsx)(n.code,{children:"{{TODAY}}"})]})]})}function c(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>l,x:()=>d});var r=i(6540);const t={},s=r.createContext(t);function l(e){const n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);