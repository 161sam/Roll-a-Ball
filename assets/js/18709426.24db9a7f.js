"use strict";(self.webpackChunkwiki=self.webpackChunkwiki||[]).push([[466],{8453:(e,n,r)=>{r.d(n,{R:()=>l,x:()=>a});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}},9136:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>o,frontMatter:()=>l,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"development/Analyse_OSM-Kartengenerierung","title":"Analyse und Verbesserungsvorschl\xe4ge f\xfcr die OSM-Kartengenerierung im Roll-a-Ball-Spiel","description":"Aktueller Stand der Implementierung","source":"@site/docs/development/Analyse_OSM-Kartengenerierung.md","sourceDirName":"development","slug":"/development/Analyse_OSM-Kartengenerierung","permalink":"/Roll-a-Ball/docs/development/Analyse_OSM-Kartengenerierung","draft":false,"unlisted":false,"editUrl":"https://github.com/161sam/Roll-a-Ball/edit/main/wiki/docs/development/Analyse_OSM-Kartengenerierung.md","tags":[],"version":"current","frontMatter":{}}');var s=r(4848),t=r(8453);const l={},a="Analyse und Verbesserungsvorschl\xe4ge f\xfcr die OSM-Kartengenerierung im Roll-a-Ball-Spiel",d={},h=[{value:"Aktueller Stand der Implementierung",id:"aktueller-stand-der-implementierung",level:2},{value:"Probleme und Limitierungen der aktuellen L\xf6sung",id:"probleme-und-limitierungen-der-aktuellen-l\xf6sung",level:2},{value:"Entwicklungsvorschl\xe4ge zur Verbesserung",id:"entwicklungsvorschl\xe4ge-zur-verbesserung",level:2},{value:"1. <strong>Echtes Parsing der Overpass-API-Daten</strong>",id:"1-echtes-parsing-der-overpass-api-daten",level:3},{value:"2. <strong>Detailgetreue <strong>Stra\xdfen</strong>-Generierung</strong>",id:"2-detailgetreue-stra\xdfen-generierung",level:3},{value:"3. <strong>Realistischere <strong>Geb\xe4ude</strong>-Darstellung</strong>",id:"3-realistischere-geb\xe4ude-darstellung",level:3},{value:"4. <strong>Fl\xe4chen (Parks, Gew\xe4sser, W\xe4lder) sinnvoll darstellen</strong>",id:"4-fl\xe4chen-parks-gew\xe4sser-w\xe4lder-sinnvoll-darstellen",level:3},{value:"5. <strong>Performance optimieren (Batching, Instancing)</strong>",id:"5-performance-optimieren-batching-instancing",level:3},{value:"6. <strong>Verbesserte Integration in Spielfluss und Levelsystem</strong>",id:"6-verbesserte-integration-in-spielfluss-und-levelsystem",level:3},{value:"7. <strong>Vervollst\xe4ndigung der Benutzerfunktionen (Adresseingabe, GPS)</strong>",id:"7-vervollst\xe4ndigung-der-benutzerfunktionen-adresseingabe-gps",level:3},{value:"8. <strong>Weiteres Feintuning und zuk\xfcnftige Erweiterungen</strong>",id:"8-weiteres-feintuning-und-zuk\xfcnftige-erweiterungen",level:3}];function c(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"analyse-und-verbesserungsvorschl\xe4ge-f\xfcr-die-osm-kartengenerierung-im-roll-a-ball-spiel",children:"Analyse und Verbesserungsvorschl\xe4ge f\xfcr die OSM-Kartengenerierung im Roll-a-Ball-Spiel"})}),"\n",(0,s.jsx)(n.h2,{id:"aktueller-stand-der-implementierung",children:"Aktueller Stand der Implementierung"}),"\n",(0,s.jsxs)(n.p,{children:["Die Klassen ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"AddressResolver"})})," und ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"MapGenerator"})})," bilden das Herzst\xfcck der geplanten OSM-Integration. Aktuell l\xe4uft der Prozess wie folgt ab:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"AddressResolver"}),": K\xfcmmert sich um Geokodierung und Abruf der OSM-Daten. Bei Eingabe einer Adresse wird \xfcber Nominatim eine Koordinate ermittelt. Anschlie\xdfend wird die Overpass-API mit einer Bounding Box (Standard-Radius ~500m) abgefragt. ",(0,s.jsx)(n.strong,{children:"Wichtig:"})," Die Antworten der Overpass-API werden derzeit ",(0,s.jsx)(n.em,{children:"nicht"})," wirklich geparst \u2013 stattdessen f\xfcllt die Methode ",(0,s.jsx)(n.code,{children:"ParseOSMResponse"})," das Ergebnis mit Platzhalter-Daten auf. Das hei\xdft, unabh\xe4ngig vom tats\xe4chlichen Kartenausschnitt erzeugt das Programm momentan beispielhafte Stra\xdfen und Geb\xe4ude in einem einfachen Gittermuster. Diese Platzhalter dienen offenbar nur als \xdcbergangsl\xf6sung (\u201eIn production, use a proper JSON library\u2026\u201c)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"MapGenerator"}),": Nimmt die erhaltenen OSM-Daten (derzeit also die Platzhalter-Strukturen) und erzeugt daraus Unity-GameObjects. Hierbei werden Stra\xdfen, Geb\xe4ude, Fl\xe4chen (Parks/Wasser) sowie Sammelobjekte (",(0,s.jsx)(n.em,{children:"Collectibles"}),") und ein Zielbereich generiert. Allerdings ist die Geometrie stark vereinfacht:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Stra\xdfen:"})," Pro OSM-Weg wird ",(0,s.jsx)(n.strong,{children:"ein einziges"})," quaderf\xf6rmiges Mesh erzeugt, das lediglich vom ",(0,s.jsx)(n.strong,{children:"ersten bis zum letzten Knotenpunkt"})," der Stra\xdfe reicht. Kurven oder mehrere Segmente werden ignoriert \u2013 die Stra\xdfe wird als gerade Linie zwischen Start- und Endpunkt dargestellt."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Geb\xe4ude:"})," Unabh\xe4ngig von der tats\xe4chlichen Grundrissform wird jedes Geb\xe4ude als ",(0,s.jsx)(n.strong,{children:"ein W\xfcrfel (PrimitiveType.Cube)"})," mit fester Grundfl\xe4che (5\xd75 Unity-Einheiten) platziert. Die Position ist der Durchschnitt aller Geb\xe4ude-Eckpunkte, die H\xf6he wird aus den OSM-Daten gesch\xe4tzt (z.B. \xfcber ",(0,s.jsx)(n.code,{children:"building:levels"})," oder Standardwerte). Die tats\xe4chliche Polygonform der Geb\xe4ude wird ",(0,s.jsx)(n.strong,{children:"nicht"})," abgebildet \u2013 Ecken/Umrisse bleiben unber\xfccksichtigt."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Fl\xe4chen:"})," Parks, Gew\xe4sser etc. (OSM ",(0,s.jsx)(n.strong,{children:"Areas"}),") werden analog als einfacher ",(0,s.jsx)(n.strong,{children:"Plane"})," in der Mitte der Punktewolke erzeugt. Der Umriss der Fl\xe4che wird also nicht nachgezeichnet; es entsteht lediglich ein kleines flaches Quadrat (Skalierung fest auf ",(0,s.jsx)(n.code,{children:"Vector3.one * 2f"}),") am Schwerpunkt der Fl\xe4che."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.em,{children:"Zusatz:"})," Sammelobjekte werden pro Geb\xe4ude (Standard: 2 St\xfcck) in der N\xe4he zuf\xe4llig verteilt und vereinzelt an zuf\xe4lligen Stellen entlang von Stra\xdfen platziert. Ein ",(0,s.jsx)(n.strong,{children:"Zielbereich"})," (\u201eGoalZone\u201c) wird standardm\xe4\xdfig in die Mitte des gr\xf6\xdften Geb\xe4udes oder \u2013 falls keine Geb\xe4ude vorhanden sind \u2013 ins Kartenmittel gesetzt. Der Spieler-Spawn erfolgt auf der ersten Stra\xdfe oder im Kartenmittelpunkt."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Diese Architektur trennt die Verantwortlichkeiten sauber: ",(0,s.jsx)(n.strong,{children:"AddressResolver"})," l\xe4dt die Daten und wandelt Adressen in Koordinaten um, ",(0,s.jsx)(n.strong,{children:"MapGenerator"})," \xfcbernimmt die Welt-Erstellung und Styling (Steampunk-Materialien, Nebel, Dampf-Effekte etc.). Die Kommunikation l\xe4uft \xfcber Events (",(0,s.jsx)(n.code,{children:"OnMapDataLoaded"}),", ",(0,s.jsx)(n.code,{children:"OnMapGenerationCompleted"})," usw.), die in einem ",(0,s.jsx)(n.strong,{children:"MapStartupController"})," mit der UI verkn\xfcpft sind. \xdcber dieses System erh\xe4lt der Spieler eine Eingabemaske f\xfcr Adressen, einen ",(0,s.jsx)(n.em,{children:"\u201eaktueller Standort\u201c"}),"-Button (derzeit als Demo fest auf Leipzig gesetzt) und Ladeanzeigen f\xfcr die Generierung."]}),"\n",(0,s.jsxs)(n.p,{children:["Neben dem OSM-Level gibt es ",(0,s.jsx)(n.strong,{children:"drei statische Tutorial-Level"})," (Level1\u20133) mit festem Layout, um den Spieler an Steuerung und Gameplay heranzuf\xfchren. In der aktuellen Level-Logik wird nach Level 3 ",(0,s.jsx)(n.em,{children:"kein"})," weiteres Level geladen \u2013 ",(0,s.jsx)(n.code,{children:"LevelManager.DetermineNextScene"})," gibt nach \u201eLevel3\u201c einen leeren String zur\xfcck, was de facto das Spielende bedeutet. Laut Vorgabe soll hier jedoch nahtlos in ",(0,s.jsx)(n.strong,{children:"prozedural generierte Levels"})," \xfcbergegangen werden: Sobald Level 3 abgeschlossen ist, soll automatisch immer das n\xe4chste Level generiert werden (theoretisch endlos). Au\xdferdem gibt es den speziellen ",(0,s.jsx)(n.strong,{children:"OSM-Spielmodus"}),", in dem der Nutzer jederzeit ein Level basierend auf einer beliebigen Adresse oder GPS-Position starten kann. Die generierte Karte soll dabei der realen Geografie entsprechen (Stra\xdfenverlauf, Geb\xe4udeplatzierung etc.)."]}),"\n",(0,s.jsx)(n.p,{children:"Zusammengefasst: Die Grundstruktur f\xfcr die OSM-Integration ist vorhanden, aber viele Funktionen sind momentan stark vereinfacht oder unvollst\xe4ndig. Im n\xe4chsten Abschnitt werden die wichtigsten Baustellen und Probleme aufgezeigt."}),"\n",(0,s.jsx)(n.h2,{id:"probleme-und-limitierungen-der-aktuellen-l\xf6sung",children:"Probleme und Limitierungen der aktuellen L\xf6sung"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Keine echte Auswertung der OSM-Daten:"})," Der wohl gr\xf6\xdfte Mangel ist, dass die Overpass-API-Antwort gar nicht geparst wird. Statt die tats\xe4chlichen Stra\xdfen, Geb\xe4ude etc. aus den JSON-Daten zu lesen, erzeugt ",(0,s.jsx)(n.code,{children:"ParseOSMResponse"})," immer das gleiche schematische Netz aus ein paar Stra\xdfen und K\xe4stchen. Dadurch spiegelt die generierte Karte ",(0,s.jsx)(n.strong,{children:"nicht die echte OSM-Umgebung"})," der gew\xe4hlten Adresse wider. Selbst wenn Overpass valide Daten liefern w\xfcrde, werden sie ignoriert. Zudem wird so auch nicht erkennbar, ob in der Region eventuell gar keine Daten vorhanden sind \u2013 das Spiel w\xfcrde trotzdem ein fiktives Grid anzeigen (anstatt den Nutzer zu informieren, dass z.B. mitten im Ozean keine Objekte sind)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Vereinfachte Geometrie und fehlende Details:"})," Die derzeit erzeugten Meshes sind nur grobe Platzhalter. Insbesondere:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stra\xdfen"}),": Alle Stra\xdfen werden als gerades Rechteck zwischen zwei Punkten dargestellt. Kurven, Kreuzungen oder Stra\xdfennetze mit Verzweigungen fehlen komplett. Eine L-f\xf6rmige Stra\xdfe w\xfcrde z.B. diagonal abgeschnitten. Au\xdferdem haben alle Stra\xdfen dieselbe Breite (2m) und das gleiche Material \u2013 Unterscheidungen nach ",(0,s.jsx)(n.em,{children:"highway"}),"-Typ (z.B. Hauptstra\xdfe vs. Fu\xdfweg) fehlen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Geb\xe4ude"}),": Es wird nicht der Grundriss genutzt, sondern pauschal ein 5\xd75-Quader am Mittelpunkt platziert. Dadurch stehen die Geb\xe4ude nicht an ihren tats\xe4chlichen Positionen oder in korrekter Ausdehnung zueinander. \xdcberlappungen mit Stra\xdfen sind wahrscheinlich, da die 5x5-Fl\xe4che beliebig gew\xe4hlt ist. Auch die Orientierung der Geb\xe4ude (Drehung) wird ignoriert \u2013 alle W\xfcrfel sind Achsen-parallel ausgerichtet."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fl\xe4chen"}),": Parks, W\xe4lder, Gew\xe4sser etc. werden nur als winzige Plane-Fl\xe4che in der Mitte approximiert. Die tats\xe4chliche Ausdehnung oder Form der Fl\xe4che geht verloren, wodurch z.B. ein langer Flussabschnitt lediglich als kleines blaues Quadrat erscheint."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Visuelle Qualit\xe4t"}),": Primitive Basic-Objekte (Unity-Cubes/Planes) ohne Variation wirken sehr steril. Obwohl Steampunk-Materialien vorgesehen sind, nutzen alle Geb\xe4ude derzeit dasselbe Material, ebenso die Stra\xdfen \u2013 individuelle Texturen (z.B. Stra\xdfenasphalt vs. Pflaster) je nach Typ fehlen."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Performance-Potenzial unausgesch\xf6pft:"})," F\xfcr jede Stra\xdfe und jedes Geb\xe4ude wird ein eigenes GameObject mit eigenem Renderer erzeugt. In st\xe4dtischen Gebieten k\xf6nnen 500m Radius aber Dutzende Stra\xdfen und Geb\xe4ude umfassen. Ohne weitere Optimierung drohen hier sehr viele Draw Calls. Zwar ist im Code eine ",(0,s.jsx)(n.strong,{children:"Batching-Option"})," angedeutet (",(0,s.jsx)(n.code,{children:"useBatching = true"}),"), doch ",(0,s.jsx)(n.code,{children:"ApplyMeshBatching()"})," ist noch leer bzw. enth\xe4lt nur einen Debug-Log. Das hei\xdft, ",(0,s.jsx)(n.strong,{children:"keine echten Zusammenf\xfchrungen"})," der Meshes finden statt. Au\xdferdem werden die vorbereiteten Listen ",(0,s.jsx)(n.code,{children:"roadMeshes"})," und ",(0,s.jsx)(n.code,{children:"buildingMeshes"})," nie bef\xfcllt \u2013 das Batchingsystem ist unvollst\xe4ndig.\nWeitere Performance-Themen: Die Generierung l\xe4uft innerhalb von Coroutinen bereits schrittweise (yield nach X Objekten) \u2013 das ist gut gegen Frameeinbr\xfcche. Dennoch k\xf6nnte bei sehr vielen Objekten oder einem gro\xdfen Radius auch das Parsen der JSON oder das Instantiieren vieler Primitives zum Engpass werden. Hier ist aber mangels echter Datenverarbeitung noch kein Problem sichtbar."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ungenutzte Prefabs und fehlende Variation:"})," In ",(0,s.jsx)(n.code,{children:"MapGenerator"})," sind Prefabs vorgesehen (",(0,s.jsx)(n.code,{children:"roadPrefab"}),", ",(0,s.jsx)(n.code,{children:"buildingPrefab"}),", etc.), um ggf. vordefinierte Modelle zu verwenden. Diese bleiben aber ungenutzt \u2013 stattdessen werden immer Unity-Primitives erstellt. Dadurch geht die M\xf6glichkeit verloren, optisch ansprechendere oder komplexere Modelle einzusetzen (z.B. vorgefertigte Deko-Geb\xe4ude im Steampunk-Stil). Auch die ",(0,s.jsx)(n.strong,{children:"Steampunk-Elemente"})," sind minimal: Ein zuf\xe4lliger Dampfwolken-Emitter auf manchen Fabrikd\xe4chern und eine \xc4nderung des Ambient-Light/Fog. Hier lie\xdfe sich thematisch mehr aussch\xf6pfen (Zahnr\xe4der, Rohre an Geb\xe4uden, bewegliche Mechaniken etc.), was aber Gameplay-seitig nicht kritisch ist \u2013 eher eine optionale Verbesserung f\xfcr Atmosph\xe4re."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ma\xdfstabsberechnung und Genauigkeit:"})," Die Umrechnung von Geo-Koordinaten in Unity-Koordinaten ist momentan ",(0,s.jsx)(n.strong,{children:"vereinfacht linear"}),". Der Code nimmt an, dass 1\xb0 geographische L\xe4nge \u2248 111.320m (am \xc4quator) und konvertiert die gew\xfcnschten Meter in Grad indem er durch 111320 teilt. Diese N\xe4herung ignoriert, dass die L\xe4ngengrad-Abst\xe4nde je nach Breitengrad kleiner werden (cos-Faktor). F\xfcr moderate Breiten (z.B. Deutschland ~50\xb0N) ist der Fehler zwar sp\xfcrbar (~30% zu gro\xdfe Ost-West-Ausdehnung), aber f\xfcr 500m noch nicht dramatisch. Dennoch: Das generierte Kartenquadrat ist ",(0,s.jsx)(n.strong,{children:"kein exakter Kreisradius"}),", sondern ein Rechteck in Grad, das in Nord-S\xfcd-Richtung ~500m, Ost-West etwas mehr abdeckt. Die ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"scaleMultiplier"})})," wird dann gesetzt, um die gesamte Bounding Box auf ~1000 Unity-Einheiten zu bringen. Dieses Vorgehen wirkt etwas willk\xfcrlich \u2013 im Prinzip sollte 1 Unity-Einheit idealerweise ",(0,s.jsx)(n.strong,{children:"1 Meter"})," entsprechen, damit z.B. ein 10m breites Geb\xe4ude im Spiel ~10 Einheiten misst. Momentan ist der Ma\xdfstab davon abh\xe4ngig, wie gro\xdf die Grad-Differenz des Bereichs ist; das kann zu leichten Verzerrungen f\xfchren und erschwert es, echte Gr\xf6\xdfen abzusch\xe4tzen. Es wurde kein Ausgleich zwischen unterschiedlicher Breite/H\xf6he der Bounding Box implementiert (es wird einfach die Breite genommen) \u2013 d.h. falls die H\xf6he deutlich abweicht, w\xfcrde das Kartenquadrat evtl. nicht perfekt quadratisch skaliert."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Integration in den Spielablauf:"})," Der \xdcbergang von den statischen Leveln zu den generierten Leveln ist noch nicht umgesetzt. Nach Abschluss von Level 3 passiert aktuell nichts (Game Over). Zudem scheint der OSM-Modus derzeit getrennt vom ",(0,s.jsx)(n.strong,{children:"LevelManager"})," zu laufen:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["In der OSM-Szene \xfcbernimmt ",(0,s.jsx)(n.code,{children:"MapStartupController"})," die Kontrolle und ruft nach Generierung ",(0,s.jsx)(n.code,{children:"gameManager.StartGame()"})," auf, jedoch wird der ",(0,s.jsx)(n.strong,{children:"LevelManager"})," dort offenbar nicht verwendet. Das hat Implikationen f\xfcr die Spielziele:"]}),"\n",(0,s.jsxs)(n.li,{children:["In den statischen Levels verwaltet ",(0,s.jsx)(n.code,{children:"LevelManager"})," die Anzahl der Collectibles und schlie\xdft das Level automatisch ab, wenn alle eingesammelt sind. Im generierten Level werden zwar Collectibles platziert, aber ",(0,s.jsx)(n.strong,{children:"nicht in den LevelManager eingebunden"}),". Zwar aktualisiert ",(0,s.jsx)(n.code,{children:"MapGenerator"})," nach dem Platzieren via ",(0,s.jsx)(n.code,{children:"LevelManager.UpdateCollectibleCount()"})," die Z\xe4hler, jedoch werden die neuen Collectible-Objekte nicht mittels ",(0,s.jsx)(n.code,{children:"AddCollectible()"})," dem LevelManager bekannt gemacht. Folge: Deren Event ",(0,s.jsx)(n.code,{children:"OnCollectiblePickedUp"})," wird nicht vom LevelManager abonniert, sodass das Einsammeln keinen Abschluss ausl\xf6st. Dadurch besteht die Gefahr, dass ein generiertes Level ",(0,s.jsx)(n.strong,{children:"nie als \u201egewonnen\u201c erkannt"})," wird, selbst wenn alle Objekte gesammelt wurden \u2013 es sei denn, der ",(0,s.jsx)(n.strong,{children:"GoalZone"}),"-Trigger \xfcbernimmt das (unklar, da Code dazu nicht sichtbar ist). Insgesamt ist die ",(0,s.jsx)(n.strong,{children:"Level-Fortsetzung in generierten Levels unvollst\xe4ndig"}),". F\xfcr das gew\xfcnschte Feature \u201enach Level 3 endlos weiter\u201c muss diese L\xfccke geschlossen werden."]}),"\n",(0,s.jsxs)(n.li,{children:["Auch das ",(0,s.jsx)(n.strong,{children:"automatische Starten"})," eines generierten Levels nach Level 3 fehlt. Im Code gibt es einen Hinweis, dass hier ein \u201eprocedural level scene\u201c vorgesehen war. Derzeit w\xfcrde Level3->GameOver gehen, was den Vorgaben widerspricht."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Benutzerf\xfchrung und Fehlerszenarien:"})," Die aktuelle UI f\xfcr den OSM-Level deckt grundlegende F\xe4lle ab (Adresse leer -> Fehlermeldung \u201eBitte g\xfcltige Adresse eingeben\u201c, AddressResolver-Fehler -> ggf. Fallback-Karte). Dennoch ein paar Punkte:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"GPS-Nutzung:"})," Der \u201eaktueller Standort\u201c-Button ist im Code nur ein Platzhalter, der fix auf Leipzig gestellt ist. Eine echte GPS-Abfrage (Unity LocationService) mit Berechtigungspr\xfcfung fehlt noch komplett."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fallback-Handling:"})," Ist ",(0,s.jsx)(n.code,{children:"enableFallbackMode"})," aktiv, l\xe4dt das Spiel bei Fehlern (Adresse nicht gefunden, keine Daten) eine feste Ersatz-Location (im Code vorbelegt mit Koordinaten 52.5217, 13.4132 \u2013 Berlin, Brandenburger Tor). Das ist grunds\xe4tzlich gut, aber die Entscheidung passiert blind nach ",(0,s.jsx)(n.em,{children:"jedem"})," Fehler. Beispielsweise wenn Overpass keine Daten liefert, wird sofort Berlin geladen \u2013 der Nutzer hat keine Chance, eine andere Eingabe zu versuchen, was verwirrend sein k\xf6nnte (\u201eWarum bin ich pl\xf6tzlich in Berlin?\u201c). Hier w\xe4re evtl. eine bessere Kommunikation oder ein alternativer Fallback (z.B. Radius erh\xf6hen, andere nahe Adresse versuchen) w\xfcnschenswert."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Overpass/API Limits:"})," Nicht direkt ein UI-Thema, aber erw\xe4hnenswert: Weder Nominatim noch Overpass haben eine explizite Limitierung im Code (au\xdfer Timeout 10s bzw. 20s). Bei h\xe4ufiger Nutzung k\xf6nnten jedoch API-Limits erreicht werden. Der User-Agent ist gesetzt, was positiv ist. Dennoch: Caching von Ergebnissen (wenn dieselbe Adresse mehrfach gespielt wird) existiert nicht und auch keine Begrenzung, wie oft pro Zeiteinheit Daten geladen werden. In einem Endlosmodus k\xf6nnte das relevant werden."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Abdeckung komplexer OSM-Features:"})," Der Overpass-Query selbst sucht derzeit nur nach einfachen Wegen: ",(0,s.jsx)(n.code,{children:'way["highway"]'}),", ",(0,s.jsx)(n.code,{children:'way["building"]'}),", ",(0,s.jsx)(n.code,{children:'way["leisure"]'}),", ",(0,s.jsx)(n.code,{children:'way["natural"]'}),", ",(0,s.jsx)(n.code,{children:'way["landuse"]'}),", sowie Knoten ",(0,s.jsx)(n.code,{children:'node["amenity"]'})," und ",(0,s.jsx)(n.code,{children:'node["shop"]'}),". ",(0,s.jsx)(n.strong,{children:"Relationen"})," (Multipolygone) werden ignoriert. Das bedeutet, gr\xf6\xdfere zusammengesetzte Geb\xe4ude oder Fl\xe4chen, die in OSM als Relation vorliegen, w\xfcrden fehlen. Beispiel: Ein Park, der als Multipolygon-Relation gemappt ist, w\xfcrde vom obigen Query nicht erfasst und somit gar nicht erscheinen. Ebenso k\xf6nnte ein Geb\xe4ude mit Innenhof (Multipolygon) fehlen. Dies ist ein fortgeschrittenes Thema, aber der Vollst\xe4ndigkeit halber zu nennen \u2013 aktuell bleibt dieser Aspekt unber\xfccksichtigt und k\xf6nnte zu l\xfcckenhaften Karten f\xfchren."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"entwicklungsvorschl\xe4ge-zur-verbesserung",children:"Entwicklungsvorschl\xe4ge zur Verbesserung"}),"\n",(0,s.jsxs)(n.p,{children:["Um die Map-Generierung wirklich ",(0,s.jsx)(n.strong,{children:"automatisch anhand echter OSM-Daten"})," zu machen, sollten die folgenden Ma\xdfnahmen ergriffen werden:"]}),"\n",(0,s.jsxs)(n.h3,{id:"1-echtes-parsing-der-overpass-api-daten",children:["1. ",(0,s.jsx)(n.strong,{children:"Echtes Parsing der Overpass-API-Daten"})]}),"\n",(0,s.jsx)(n.p,{children:"Statt Dummy-Daten zu verwenden, muss die JSON-Antwort von Overpass vollst\xe4ndig ausgewertet werden. Konkret hei\xdft das:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Ein JSON-Parser verwenden (z.B. ",(0,s.jsx)(n.strong,{children:"Newtonsoft.Json"})," oder Unitys ",(0,s.jsx)(n.code,{children:"JsonUtility"}),", wobei NewtonSoft flexibler mit verschachtelten Strukturen umgehen kann). Damit kann ",(0,s.jsx)(n.code,{children:"ParseOSMResponse"})," die ",(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"elements"}),"-Liste"]})," der Overpass-Antwort durchlaufen."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mapping der OSM-Objekte:"})," F\xfcr jedes Element:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Falls ",(0,s.jsx)(n.code,{children:'type == "node"'}),": einen ",(0,s.jsx)(n.strong,{children:"OSMNode"})," erstellen (ID, lat, lon, Tags). Zweck: Diese Nodes dienen als Punkte, die von Wegen referenziert werden."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Falls ",(0,s.jsx)(n.code,{children:'type == "way"'}),": Pr\xfcfen auf Tags wie ",(0,s.jsx)(n.em,{children:'"highway"'}),", ",(0,s.jsx)(n.em,{children:'"building"'}),", ",(0,s.jsx)(n.em,{children:'"leisure/natural/landuse"'}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Hat der Way ein ",(0,s.jsx)(n.code,{children:'"highway"'}),"-Tag -> neuen ",(0,s.jsx)(n.strong,{children:"OSMWay"})," erstellen und als ",(0,s.jsx)(n.em,{children:"Stra\xdfe"})," in ",(0,s.jsx)(n.code,{children:"mapData.roads"})," aufnehmen."]}),"\n",(0,s.jsxs)(n.li,{children:["Hat er ein ",(0,s.jsx)(n.code,{children:'"building"'}),"-Tag -> neuen ",(0,s.jsx)(n.strong,{children:"OSMBuilding"})," erstellen (Unterklasse von OSMWay) und in ",(0,s.jsx)(n.code,{children:"mapData.buildings"})," aufnehmen. Dabei ",(0,s.jsx)(n.code,{children:"building.CalculateHeight()"})," ausf\xfchren, um H\xf6he aus Tags wie ",(0,s.jsx)(n.code,{children:"height"})," oder ",(0,s.jsx)(n.code,{children:"building:levels"})," zu ermitteln. So werden reale H\xf6hen (falls vorhanden) \xfcbernommen oder anhand Stockwerken gesch\xe4tzt (Standardeinstellung 3m pro Etage). Der Building-Typ (residential, commercial etc.) sollte ebenfalls aus dem Tag \xfcbernommen werden (wird in CalculateHeight schon gesetzt)."]}),"\n",(0,s.jsxs)(n.li,{children:["Hat er z.B. ein ",(0,s.jsx)(n.code,{children:'"leisure"'}),"-, ",(0,s.jsx)(n.code,{children:'"natural"'}),"- oder ",(0,s.jsx)(n.code,{children:'"landuse"'}),"-Tag (und ",(0,s.jsx)(n.strong,{children:"kein"})," building/highway): -> neuen ",(0,s.jsx)(n.strong,{children:"OSMArea"})," erstellen und in ",(0,s.jsx)(n.code,{children:"mapData.areas"})," aufnehmen. Danach ",(0,s.jsx)(n.code,{children:"OSMArea.DetermineAreaType()"})," aufrufen, um den ",(0,s.jsx)(n.strong,{children:"Typ"})," festzulegen (Park, Wasser, Wald usw.) und ggf. eine Materialfarbe zu bestimmen. Diese Information nutzen wir sp\xe4ter, um passendes Material zu w\xe4hlen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Nodes zuordnen:"})," Jeder Way-Eintrag hat eine Liste von Node-IDs. Hier muss man die zuvor erstellten OSMNode-Objekte per ID nachschlagen (ggf. in einem Dictionary id->OSMNode speichern) und dem Way hinzuf\xfcgen. Wichtig: Wenn der erste und letzte Knoten identisch sind, markiert ",(0,s.jsx)(n.code,{children:"OSMWay.IsClosed()"})," das Objekt als geschlossener Ring. Das ist relevant f\xfcr Geb\xe4ude/Fl\xe4chen."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Falls ",(0,s.jsx)(n.code,{children:'type == "relation"'}),": ",(0,s.jsx)(n.strong,{children:"(Optional, f\xfcr vollst\xe4ndige OSM-Unterst\xfctzung)"})," Pr\xfcfen, ob es sich um Multipolygon-Relationen f\xfcr Geb\xe4ude oder Fl\xe4chen handelt (Tag ",(0,s.jsx)(n.code,{children:'"type":"multipolygon"'})," mit building/landuse Tags in den Relationen). Diese k\xf6nnte man verarbeiten, indem man Outer-/Inner-Ways ermittelt. Dies ist allerdings komplex; ein einfacherer Workaround w\xe4re, im Overpass-Query solche Relationen ebenfalls als ",(0,s.jsx)(n.em,{children:"way"})," abzurufen (Overpass kann Relationen in Fl\xe4chen umwandeln, z.B. mit ",(0,s.jsx)(n.code,{children:'(relation["building"](...); >;); out geom;'}),"). Wenn darauf verzichtet wird, w\xfcrden manche gro\xdfen Features fehlen \u2013 als pragmatische L\xf6sung zun\xe4chst okay, aber perspektivisch eine m\xf6gliche Erweiterung."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Amenities/POIs"}),": Die Query erfasst auch Nodes mit ",(0,s.jsx)(n.code,{children:'"amenity"'})," oder ",(0,s.jsx)(n.code,{children:'"shop"'}),". Diese k\xf6nnten in ",(0,s.jsx)(n.code,{children:"OSMMapData.pointsOfInterest"})," (",(0,s.jsx)(n.code,{children:"List<OSMNode>"}),") gespeichert werden. Momentan nutzt die Generierung diese Punkte nicht weiter, aber man k\xf6nnte \xfcberlegen, sie als besondere Punkte darzustellen \u2013 z.B. ",(0,s.jsx)(n.strong,{children:"zus\xe4tzliche Collectibles oder Marker"})," auf der Karte (etwa eine andere Farbe/Symbol f\xfcr ein bekanntes Wahrzeichen oder einen Shop). Zumindest sind die Daten da und k\xf6nnten f\xfcr Gameplay oder Deko genutzt werden (kein Muss f\xfcr Funktion, aber Potenzial f\xfcr sp\xe4ter)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Durch diese Parsing-Verbesserung wird ",(0,s.jsx)(n.code,{children:"mapData.roads"}),", ",(0,s.jsx)(n.code,{children:".buildings"}),", ",(0,s.jsx)(n.code,{children:".areas"})," etc. echte OSM-Objekte der Umgebung enthalten. ",(0,s.jsx)(n.strong,{children:"Die Platzhalter-Funktionen"})," ",(0,s.jsx)(n.code,{children:"CreateSampleRoads/Buildings()"})," sollten danach komplett entfernt oder nur noch als Fallback dienen, falls das Parsen fehlschl\xe4gt. Stattdessen validiert man: Wenn in der Overpass-Antwort ",(0,s.jsx)(n.strong,{children:"gar keine"})," Stra\xdfe/Building gefunden wurde, kann man ",(0,s.jsx)(n.code,{children:"mapData"})," als ung\xfcltig betrachten und einen Fehler melden (\u201eKeine Kartendaten f\xfcr diese Region.\u201c), anstatt k\xfcnstlich etwas zu erfinden. Das informiert den Nutzer korrekt, z.B. wenn mitten in der Wildnis keine Wege sind. Der vorhandene OnError-Pfad w\xfcrde dann greifen und ggf. den Fallback-Ort laden."]}),"\n",(0,s.jsxs)(n.h3,{id:"2-detailgetreue-stra\xdfen-generierung",children:["2. ",(0,s.jsxs)(n.strong,{children:["Detailgetreue ",(0,s.jsx)(n.strong,{children:"Stra\xdfen"}),"-Generierung"]})]}),"\n",(0,s.jsxs)(n.p,{children:["Mit realen Stra\xdfendaten im ",(0,s.jsx)(n.code,{children:"OSMMapData"})," muss die ",(0,s.jsx)(n.strong,{children:"Mesh-Erzeugung f\xfcr Stra\xdfen \xfcberarbeitet"})," werden, damit das Stra\xdfennetz korrekt erscheint:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Segmentweise statt gesamter Weg:"})," Anstatt nur Start- zu Endpunkt zu verbinden, sollte ",(0,s.jsx)(n.code,{children:"GenerateRoadFromWay"})," ",(0,s.jsx)(n.strong,{children:"alle Segmente"})," eines Weges generieren. Ein einfacherer Ansatz:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Iteriere \xfcber jede aufeinanderfolgende Punkte-Paarung ",(0,s.jsx)(n.code,{children:"(node[i], node[i+1])"})," des Weges."]}),"\n",(0,s.jsxs)(n.li,{children:["F\xfcr jedes Segment ein ",(0,s.jsx)(n.strong,{children:"stra\xdfenf\xf6rmiges Mesh"})," erzeugen. Das k\xf6nnte weiterhin ein gestrecktes Quader-Primitive sein, aber es muss ",(0,s.jsx)(n.strong,{children:"f\xfcr jedes Teilst\xfcck"})," ausgerichtet werden, nicht f\xfcr den ganzen Weg auf einmal. D.h. man w\xfcrde die ",(0,s.jsx)(n.code,{children:"CreateRoadMesh"}),"-Logik pro Segment anwenden (Position = Mittelpunkt des Segmentes, LookAt = auf Endpunkt des Segments, L\xe4nge = Distanz zwischen den beiden Knoten, Breite = je nach Stra\xdfentyp)."]}),"\n",(0,s.jsxs)(n.li,{children:["Diese Segment-Objekte sollte man als Kinder des Road-Containers platzieren. Gegebenenfalls kann man sie sp\xe4ter zu einem Gesamtmesh kombinieren (siehe ",(0,s.jsx)(n.strong,{children:"Batching"})," unten)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Kurven und Kreuzungen:"})," Mit obigem Verfahren werden gekr\xfcmmte Stra\xdfen sichtbar als polygonale Kette von geraden Abschnitten. Das ist v\xf6llig ausreichend; flie\xdfende Kr\xfcmmung w\xe4re unmerklich, solange gen\xfcgend Zwischenknoten da sind (OSM-Wege sind meist so detailliert, dass Kurven durch viele kleine Segmente angen\xe4hert sind). An Kreuzungen werden sich Segmente von verschiedenen Stra\xdfen \xfcberlappen oder aneinandersto\xdfen. Das ist ok, man k\xf6nnte aber \xfcberlegen, ",(0,s.jsx)(n.strong,{children:"Kreuzungspunkte"})," zu gl\xe4tten: z.B. das letzte Segment einer Stra\xdfe endet genau am Knoten, das erste Segment der kreuzenden Stra\xdfe beginnt dort \u2013 meist ergeben sich kleine L\xfccken oder \xdcberschneidungen. Anspruchsvolle L\xf6sung: spezielle Kreuzungs-Meshes (z.B. quadratische Fl\xe4chen) an Knoten generieren. F\xfcr den Anfang kann man das ignorieren; optisch wird es dennoch brauchbar sein."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Stra\xdfenbreite & Material nach Typ:"})," In OSM verr\xe4t das ",(0,s.jsx)(n.em,{children:"highway"}),"-Tag die Art der Stra\xdfe (motorway, primary, secondary, residential, footway, etc.). Man sollte diese Info nutzen, um ",(0,s.jsx)(n.strong,{children:"Breitenvariationen"})," zu erzeugen:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Z.B. ",(0,s.jsx)(n.em,{children:"motorway/primary"})," = deutlich breiter (evtl. 4\u20136 Unity-Einheiten), ",(0,s.jsx)(n.em,{children:"residential"})," = schmal (~2), ",(0,s.jsx)(n.em,{children:"footway"})," = ganz schmal (1 oder weniger). Die Variable ",(0,s.jsx)(n.code,{children:"roadWidth"})," k\xf6nnte als Basis f\xfcr normale Stra\xdfen dienen, und man multipliziert je nach Kategorie."]}),"\n",(0,s.jsxs)(n.li,{children:["Unterschiedliche ",(0,s.jsx)(n.strong,{children:"Materialien/Texturen"})," w\xe4ren ideal (z.B. Asphaltstra\xdfe vs. Schotterweg vs. Fu\xdfweg). Im einfachsten Fall kann man auch mit Farbe arbeiten: breite Stra\xdfen dunklerer Grauton, Fu\xdfwege heller. Hierf\xfcr k\xf6nnte man mehrere Materials im MapGenerator vorsehen (aktuell gibt es nur eins f\xfcr roads)."]}),"\n",(0,s.jsxs)(n.li,{children:["Falls gew\xfcnscht, k\xf6nnte man ",(0,s.jsx)(n.strong,{children:"Stra\xdfenmarkierungen"})," (Linien) oder Bordsteine als optische Details hinzuf\xfcgen. Das w\xe4re aber Zusatzaufwand \u2013 zun\xe4chst reicht es, visuell zwischen gro\xdfen und kleinen Stra\xdfen zu unterscheiden, um dem Spieler Orientierung zu geben."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"H\xf6henprofil:"})," In diesem Projekt scheint alles flach auf einer Ebene zu liegen (keine Gel\xe4ndeh\xf6hen). OSM-Daten zu H\xf6henmetern werden nicht abgefragt (macht auch wenig Sinn ohne ein Gel\xe4nde- oder Stra\xdfen-H\xf6henmodell). Man kann also davon ausgehen, dass alle Stra\xdfen plan auf y=0 bleiben \u2013 das ist okay."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Durch diese \xc4nderungen wird das ",(0,s.jsx)(n.strong,{children:"Stra\xdfennetz im Spiel viel n\xe4her am echten Stadtplan"})," liegen. Der Ball kann dann z.B. einem echten Stra\xdfenverlauf folgen. Wichtig ist, die Kollision beizubehalten: Die generierten Stra\xdfensegmente m\xfcssen wie bisher einen Collider bekommen, damit der Ball daran st\xf6\xdft oder dar\xfcber rollen kann. Hier sollte man auch darauf achten, dass Stra\xdfen ",(0,s.jsx)(n.strong,{children:"fl\xe4chenb\xfcndig mit dem Boden"})," sind:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Momentan haben die Stra\xdfencubes eine H\xf6he von 0.1 und werden zentriert auf y=0 platziert, d.h. sie ragen 0.05 nach unten und 0.05 nach oben. Das erzeugt minimale Kanten. Besser: Entweder H\xf6he auf 0 (rein flaches Quad) oder die Stra\xdfe ",(0,s.jsx)(n.strong,{children:"0.05 nach oben verschieben"}),", sodass sie auf dem Boden aufliegt (y = 0.05). Dann gibt es keinen Versatz nach unten. Alternativ k\xf6nnte man Stra\xdfen auch ",(0,s.jsx)(n.strong,{children:"ohne Collider"})," lassen und nur als visuelle Markierung betrachten, aber dann w\xfcrden sie f\xfcr das Gameplay keine Hindernisse darstellen \u2013 es sei denn, man will sie lediglich als unterschiedliche Boden-Textur und nicht als Hindernis. Hier ist eine Design-Entscheidung gefragt: Soll der Ball an H\xe4usern h\xe4ngenbleiben (ja), und an Stra\xdfen? Vermutlich nicht \u2013 Stra\xdfen sind ja keine W\xe4nde. Daher k\xf6nnte man erw\xe4gen, ",(0,s.jsx)(n.strong,{children:"Stra\xdfen-Collider zu entfernen"}),", damit der Ball ungehindert dar\xfcberrollen kann (im Gegensatz zu Geb\xe4uden, die blockieren sollen). Momentan sind Stra\xdfen minimal erh\xf6ht, was wie ein Rand wirken k\xf6nnte. Wahrscheinlich w\xe4re es sauberer, Stra\xdfen nur als Textur/Optik auf dem Boden zu haben. Man k\xf6nnte stattdessen den ",(0,s.jsx)(n.strong,{children:"GroundPlane"})," in Stra\xdfengebieten anders einf\xe4rben oder Kacheln. Dies w\xe4re aber eine gr\xf6\xdfere Umstellung; zumindest sollte die 0.1-H\xf6he so angepasst werden, dass keine Stolperkanten entstehen."]}),"\n"]}),"\n",(0,s.jsxs)(n.h3,{id:"3-realistischere-geb\xe4ude-darstellung",children:["3. ",(0,s.jsxs)(n.strong,{children:["Realistischere ",(0,s.jsx)(n.strong,{children:"Geb\xe4ude"}),"-Darstellung"]})]}),"\n",(0,s.jsx)(n.p,{children:"Die Geb\xe4ude sollten aus den OSM-Umrissen generiert werden, um eine echte Stadtstruktur zu ergeben:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Grundriss als Polygon"}),": Jeder ",(0,s.jsx)(n.code,{children:"OSMBuilding"})," bringt eine Liste von Nodes mit, die den Umriss definieren (erster = letzter f\xfcr geschlossene Form). Statt diese zu mitteln und einen W\xfcrfel zu platzieren, sollte man die Polygonpunkte verwenden, um ein ",(0,s.jsx)(n.strong,{children:"Mesh"})," zu bauen:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Zuerst alle Punkte von Lat/Lon in Weltkoordinaten umrechnen (wird ja schon in ",(0,s.jsx)(n.code,{children:"buildingPoints"})," Liste gemacht)."]}),"\n",(0,s.jsxs)(n.li,{children:["Dann ein ",(0,s.jsx)(n.strong,{children:"Fl\xe4chen-Mesh"})," aus diesen Punkten erzeugen. Hierzu muss das Polygon trianguliert werden (in Dreiecke zerlegt). Unity bietet keine eingebaute Polygon-Triangulation f\xfcr beliebige Polygone, aber man k\xf6nnte einen simplen Algorithmus (Ear Clipping) implementieren oder auf einen externen Mesh-Generator zur\xfcckgreifen. F\xfcr rechteckige oder konvexe Formen ginge es relativ einfach. F\xfcr den Anfang k\xf6nnte man sich auch auf einfachere Formen beschr\xe4nken: Viele Geb\xe4ude sind rechteckig; man k\xf6nnte erkennen, wenn ein Geb\xe4ude genau 4 Punkte hat (Rechteck), dann kann man einfach ein extrudiertes Quader-Mesh mit entsprechenden Kantenl\xe4ngen erzeugen. Bei mehr Ecken oder L-Formen sollte man jedoch verallgemeinern."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Extrudieren in die H\xf6he"}),": Hat man die Dachfl\xe4che trianguliert, kann man die gleichen Polygone eine H\xf6he weiter unten als Boden ansetzen und die Seitenw\xe4nde generieren (jeder Kantenabschnitt -> ein Rechteck als Wand). Alternativ kann man einen Unity ProBuilder o.\xc4. nutzen, aber vermutlich reicht eigener Code."]}),"\n",(0,s.jsxs)(n.li,{children:["Ergebnis w\xe4re ein ",(0,s.jsx)(n.strong,{children:"prismenf\xf6rmiges Geb\xe4ude"})," genau entlang des OSM-Grundrisses mit richtiger H\xf6he."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Vereinfachte Alternative"}),": Falls die vollst\xe4ndige Mesh-Generierung zu aufwendig ist, zumindest die Platzierung verbessern:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Statt fester 5\xd75 Gr\xf6\xdfe k\xf6nnte man die ",(0,s.jsx)(n.strong,{children:"Bounding Box"})," des Geb\xe4udepolygons berechnen und einen skalieren Cube in dieser Ausdehnung setzen. Dann st\xfcnde das Geb\xe4ude an korrekter Position und h\xe4tte ungef\xe4hr die richtige L\xe4nge/Breite. Allerdings passen W\xfcrfel nur f\xfcr rechteckige H\xe4user wirklich \u2013 L-Formen w\xfcrden dann immer noch nicht stimmen und k\xf6nnten benachbarte Stra\xdfen \xfcberdecken. Diese L\xf6sung ist also nur bedingt besser."]}),"\n",(0,s.jsxs)(n.li,{children:["Dennoch sollte die ",(0,s.jsx)(n.strong,{children:"Position"})," wenigstens das tats\xe4chliche Schwerpunktszentrum des Polygons sein (das wird ja schon gemacht) und man k\xf6nnte die ",(0,s.jsx)(n.strong,{children:"X/Z-Skalierung"})," des W\xfcrfels so w\xe4hlen, dass sie dem maximalen Nord-S\xfcd bzw. Ost-West-Abstand der Punkte entspricht. So f\xfcllt der Kubus den Umriss zumindest aus."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Drehung"}),": Sollte man einen Cube weiterverwenden, w\xe4re es wichtig, ihn passend zu drehen. Aktuell werden alle Geb\xe4ude-Cubes gar nicht gedreht (Bleiben in Weltachsen ausgerichtet). Das f\xfchrt dazu, dass z.B. ein l\xe4ngliches Geb\xe4ude diagonal zur Karte dennoch als Achsen-paralleler W\xfcrfel steht und evtl. Fl\xe4chen au\xdferhalb seines echten Grundrisses bedeckt. ",(0,s.jsx)(n.strong,{children:"L\xf6sung:"})," die Hauptorientierung des Polygons ermitteln (z.B. mittels PCA \u2013 Hauptkomponentenanalyse der Punkte \u2013 oder einfach die Achse zwischen erstem und gegen\xfcberliegendem Punkt, falls Rechteck) und den Geb\xe4ude-W\xfcrfel entsprechend rotieren. Bei exakter Polygonmesh-Erzeugung w\xfcrde sich das automatisch durch die Punkte ergeben."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Visuelle Aufwertung:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Unterschiedliche Geb\xe4ude-Typen k\xf6nnten mit unterschiedlichen Materialien oder Farben versehen werden. Im Code wird ",(0,s.jsx)(n.code,{children:"building.buildingType"})," gesetzt (z.B. industrial, residential). Man k\xf6nnte z.B. Wohnh\xe4user rotbraun, Industrie grau, B\xfcrogeb\xe4ude blau anstreichen \u2013 oder Fenstermuster an Fassaden je nach Typ. Daf\xfcr k\xf6nnte man mehrere ",(0,s.jsx)(n.strong,{children:"Building-Materials"})," definieren (oder ein Shader, der basierend auf Tag anders aussieht)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Steampunk-Deko:"})," Derzeit werden nur Industriebauten gelegentlich mit einem Partikelemitter \u201eRauch\u201c gekr\xf6nt. Hier lie\xdfe sich mehr machen: Vielleicht Tanks, Schornsteine oder Zahnrad-Props auf die D\xe4cher setzen, speziell bei gewissen Geb\xe4udetypen. Man k\xf6nnte daf\xfcr kleine Prefabs vorbereiten (z.B. ein Zahnrad-Objekt), das via ",(0,s.jsx)(n.code,{children:"AddSteampunkElementsToBuilding"})," zuf\xe4llig angeheftet wird. Dies erh\xf6ht den Steampunk-Flair und visuelle Abwechslung."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collider:"})," Die Geb\xe4ude bekommen einen MeshCollider. Wenn wir auf tats\xe4chliche Meshes umstellen, muss das beibehalten werden, damit Geb\xe4ude solide Hindernisse bleiben. Das ist f\xfcr das Gameplay wichtig (der Ball soll um sie herum navigieren m\xfcssen)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["In Summe erh\xf6hen diese \xc4nderungen die ",(0,s.jsx)(n.strong,{children:"Authentizit\xe4t der Spielwelt"})," erheblich \u2013 die Platzierung der Geb\xe4ude entspricht dann echten St\xe4dten, was sowohl optisch interessanter ist als auch neue Gameplay-M\xf6glichkeiten bietet (z.B. Gassen zwischen H\xe4usern, versteckte Ecken f\xfcr Collectibles etc.)."]}),"\n",(0,s.jsxs)(n.h3,{id:"4-fl\xe4chen-parks-gew\xe4sser-w\xe4lder-sinnvoll-darstellen",children:["4. ",(0,s.jsx)(n.strong,{children:"Fl\xe4chen (Parks, Gew\xe4sser, W\xe4lder) sinnvoll darstellen"})]}),"\n",(0,s.jsx)(n.p,{children:"\xc4hnlich den Geb\xe4uden sollten auch Fl\xe4chen mehr als nur ein zentrales Plane bekommen:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Polygon-F\xfcllung:"})," Ein Park oder See kann wie ein flaches Geb\xe4ude behandelt werden \u2013 im Prinzip ebenfalls ein (evtl. unregelm\xe4\xdfiges) Polygon, das nur wenige Meter H\xf6he hat (praktisch 0, da Boden). Man kann analog die ",(0,s.jsx)(n.strong,{children:"Umrisspunkte triangulieren"})," und eine flache Mesh-Fl\xe4che erzeugen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gr\xf6\xdfe skalieren:"})," Falls man nicht trianguliert, k\xf6nnte man zumindest die Plane-Gr\xf6\xdfe an den Fl\xe4chenumfang anpassen. Evtl. indem man die Punktwolke nimmt und wie bei Geb\xe4uden eine Bounding Box daraus bildet, dann ein entsprechend skaliertes Plane auflegt. Allerdings werden komplexe Formen so schlecht abgebildet (z.B. langer schmaler Park wird eine \xfcbergro\xdfe Rechteckfl\xe4che und \xfcberlappt Geb\xe4ude). Daher w\xe4re Triangulation hier sogar noch wichtiger als bei Geb\xe4uden, weil Fl\xe4chen in OSM oft sehr unregelm\xe4\xdfig sind (Flussl\xe4ufe etc.)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Material & Farbe:"})," MapGenerator nutzt ",(0,s.jsx)(n.code,{children:"GetMaterialForAreaType"})," bereits, um Parkfl\xe4chen gr\xfcn, Wasser blau usw. zu f\xe4rben. Diese Logik sollte beibehalten werden. Gegebenenfalls k\xf6nnte man statt Unity-Standard-Plane auch eigene Texturen verwenden (z.B. Grastextur, Wasser mit Reflektion). Hierf\xfcr k\xf6nnten die \xf6ffentlichen Variablen ",(0,s.jsx)(n.code,{children:"parkMaterial"}),", ",(0,s.jsx)(n.code,{children:"waterMaterial"})," noch mit passenden Materialien belegt werden (zurzeit vermutlich einfache Farben)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Terrain vs. Mesh:"})," Eine weitergehende \xdcberlegung: Wenn gro\xdfe Areale generiert werden (z.B. ein riesiger Wald), k\xf6nnte man \xfcberlegen, statt einzelner Meshes auf Unity-Terrain oder Tile-Maps zu setzen. Das lohnt aber erst bei wirklich gro\xdfen, \xfcber den Bildschirm reichenden Fl\xe4chen. F\xfcr 500m Umkreis sind Polygone noch handhabbar."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Die Darstellung von Fl\xe4chen macht die Umgebung lebendiger und gibt dem Spieler visuelle Anhaltspunkte (z.B. \u201eGr\xfcnfl\xe4che = Park, dort k\xf6nnten Collectibles liegen\u201c oder \u201eBlau = Wasser, da kann der Ball vielleicht nicht dr\xfcber\u201c \u2013 ggf. k\xf6nnte man auch ",(0,s.jsx)(n.em,{children:"Wasser als Hindernis"})," betrachten, falls der Ball reinf\xe4llt -> Tod/Respawn, aber das w\xe4re extra Gameplay-Logik). Mindestens dienen die Fl\xe4chen der Authentizit\xe4t."]}),"\n",(0,s.jsxs)(n.h3,{id:"5-performance-optimieren-batching-instancing",children:["5. ",(0,s.jsx)(n.strong,{children:"Performance optimieren (Batching, Instancing)"})]}),"\n",(0,s.jsx)(n.p,{children:"Sobald echte Daten verwendet werden, steigt die Anzahl der GameObjects vermutlich stark (jede Stra\xdfe in 5 Segmente, zig Geb\xe4ude etc.). Um die Performance (Draw Calls, Hierarchy Overhead) zu verbessern:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mesh-Batching implementieren:"})," Die vorhandenen Strukturen ",(0,s.jsx)(n.code,{children:"roadMeshes"})," und ",(0,s.jsx)(n.code,{children:"buildingMeshes"})," sollten genutzt werden. Ein m\xf6glicher Ansatz:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\xc4ndere ",(0,s.jsx)(n.code,{children:"CreateRoadMesh"})," und ",(0,s.jsx)(n.code,{children:"CreateBuildingMesh"}),", so dass sie ",(0,s.jsx)(n.strong,{children:"nicht direkt"})," ein GameObject zur\xfcckgeben, sondern ",(0,s.jsx)(n.strong,{children:"Meshdaten"})," produzieren. Man k\xf6nnte z.B. die erzeugten Primitive-Cubes zwar erstellen, aber dann deren Mesh (MeshFilter.sharedMesh) in einen CombineInstance packen und das GameObject sofort zerst\xf6ren. Oder man generiert die Mesh-Quads pro Stra\xdfensegment pro Script und f\xfcgt sie direkt zu CombineInstances hinzu (vermeidet \xfcberhaupt das Erstellen vieler GameObjects)."]}),"\n",(0,s.jsxs)(n.li,{children:["Nach Generierung aller Stra\xdfen-Segmente, ruft man ",(0,s.jsx)(n.code,{children:"CombineMeshes"})," auf, um ",(0,s.jsx)(n.strong,{children:"ein Gesamt-Mesh f\xfcr alle Stra\xdfen"})," zu bauen. Dieses kann dann einem einzigen GameObject (z.B. ",(0,s.jsx)(n.code,{children:"AllRoads"}),") zugewiesen werden mit einem MeshFilter/MeshRenderer. \xc4hnlich f\xfcr Geb\xe4ude: Hier w\xe4re allerdings Vorsicht geboten \u2013 unterschiedliche Geb\xe4udeh\xf6hen und -materialien: Wenn alle Geb\xe4ude das gleiche Material nutzen (aktuell ja ",(0,s.jsx)(n.code,{children:"buildingMaterial"})," einheitlich), kann man sie zusammenfassen. Falls man Material nach Geb\xe4udetyp unterscheiden m\xf6chte, m\xfcsste man je Material ein Kombinat machen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Collider"}),": Wenn man alles kombiniert, verliert man die einzelnen MeshCollider. Eine gro\xdfe Kombi-MeshCollider f\xfcr alle Stra\xdfen k\xf6nnte problematisch sein (Unity hat Limits f\xfcr MeshCollider-Gr\xf6\xdfe/Performance). Alternativ kann man die Collider separat lassen (z.B. nicht kombinieren, oder vereinfachte Colliders verwenden \u2013 z.B. pro Stra\xdfensegment ein BoxCollider statt MeshCollider, da Stra\xdfen ja flach rechteckig sind). F\xfcr Geb\xe4ude \xe4hnlich: W\xfcrfel k\xf6nnte man als BoxCollider belassen, anstatt komplexe MeshCollider, wenn die Form einfach ist. Bei echten polygonalen Geb\xe4uden braucht man evtl. doch MeshCollider, au\xdfer man berechnet konvexe Polygone und k\xf6nnte ebenfalls Boxen approximieren. Das ist ein Performance-Tuning: im Zweifelsfall erst mal bei MeshColliders bleiben und nur optisch batchen."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Static Batching"}),": Da die Level nach Generierung statisch sind (nichts bewegt sich au\xdfer Ball und Collectibles), k\xf6nnte man auch Unitys statisches Batching nutzen. Dazu m\xfcssten die Objekte als ",(0,s.jsx)(n.code,{children:"Static"})," markiert werden. Unity w\xfcrde dann intern zum Rendern sie batchen. Das lie\xdfe sich mit ",(0,s.jsx)(n.code,{children:"GameObject.isStatic = true"})," beim Erzeugen setzen. Der Vorteil: weniger eigener Combine-Code, Nachteil: passiert erst zur Laufzeit auf der GPU, evtl. etwas Overhead, aber Unity macht das ganz gut f\xfcr viele kleine Objekte. Trotzdem w\xe4re ein manuelles CombineMeshes zur Laufzeit eine solide L\xf6sung um die Objektzahl drastisch zu reduzieren."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Pooling"}),": Da nach Levelabschluss neue Level generiert werden (endlosmodus), k\xf6nnte man \xfcberlegen, Objekte wiederzuverwenden. Aktuell zerst\xf6rt ",(0,s.jsx)(n.code,{children:"ClearExistingMap()"})," alle alten GameObjects. Das ist der einfachste Weg, aber verursacht bei jedem Wechsel neue Allokationen. Pooling (Objekte deaktivieren und recyceln) w\xe4re komplexer zu implementieren und lohnt nur, falls generierte Level sehr \xe4hnlich sind (was nicht garantiert ist \u2013 andere Stadt hat ganz andere Topologie). Also vermutlich okay, immer neu aufzubauen und zu l\xf6schen."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"LOD / Distanzen"}),": Bei 500m Radius und Unity-Scale=1m sind die gesamten Objekte innerhalb ~1000\xd71000 Einheiten \u2013 das ist nicht so gro\xdf, dass man \xfcber Level of Detail nachdenken m\xfcsste. Sollte man k\xfcnftig gr\xf6\xdfere Kartenabschnitte generieren (z.B. 2km), dann k\xf6nnte es Sinn machen, entfernte Objekte (am Kartenrand) als vereinfachte Darstellung zu generieren oder per Fog ausblenden. Im aktuellen Rahmen ist das aber nicht dringend."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Physics Optimierung"}),": Je mehr Collider (f\xfcr Geb\xe4ude) es gibt, desto mehr muss die Physik-Engine pr\xfcfen. Hier k\xf6nnte man ggf. ",(0,s.jsx)(n.strong,{children:"Collisions-Layer"})," nutzen \u2013 z.B. alle Geb\xe4ude auf Layer \u201eObstacles\u201c und den Ball so einstellen, dass er nur mit \u201eObstacles\u201c kollidiert und nicht mit \u201eRoad\u201c etc., um Checks zu sparen. Der GroundPlane und Stra\xdfen k\xf6nnten auf einem Layer liegen, der f\xfcr den Ball keine Kollision pr\xfcft (falls Ball sowieso immer auf Boden bleibt). Das sind Micro-Optimierungen, die erst bei Performanceproblemen angegangen werden m\xfcssen."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Zun\xe4chst ist die Priorit\xe4t, ",(0,s.jsx)(n.em,{children:"Batching"})," einzuf\xfchren, damit die Draw Calls sinken. Das Spiel sollte auf g\xe4ngigen Rechnern fl\xfcssig laufen, selbst wenn 100 Geb\xe4ude da sind, aber VR/AR oder mobile Targets k\xf6nnten empfindlich sein \u2013 da ist Batchen fast Pflicht."]}),"\n",(0,s.jsxs)(n.h3,{id:"6-verbesserte-integration-in-spielfluss-und-levelsystem",children:["6. ",(0,s.jsx)(n.strong,{children:"Verbesserte Integration in Spielfluss und Levelsystem"})]}),"\n",(0,s.jsx)(n.p,{children:"Um den \xdcbergang nach Level 3 und den Endlosmodus umzusetzen, sind einige \xc4nderungen am Level-Management n\xf6tig:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Level\xfcbergang nach Level 3:"})," Im ",(0,s.jsx)(n.code,{children:"LevelManager.DetermineNextScene"})," sollte nach Level3 nicht mehr ",(0,s.jsx)(n.code,{children:'return ""'}),' erfolgen, sondern z.B. der Name der OSM-Generierungs-Szene zur\xfcckgegeben werden (angenommen, es gibt eine Szene "Level_OSM" im Projekt). Alternativ kann man auch schon im Unity-Editor bei Level3 den ',(0,s.jsx)(n.code,{children:"nextSceneName"})," setzen (im LevelConfiguration von Level3) \u2013 der Code pr\xfcft das und l\xe4dt dann direkt diese Szene. So oder so muss definiert werden, ",(0,s.jsx)(n.strong,{children:"welche Szene"}),' nach Level3 kommt. Vermutlich ist bereits eine Szene vorgesehen, in der MapStartupController, AddressResolver, MapGenerator etc. vorhanden sind (die Suche zeigte einen "Level_OSM" \u2013 ggf. diese).']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Automatisches Generieren vs. Nutzereingabe:"})," Hier gibt es zwei denkbare Modi:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Freier OSM-Modus (manuelle Eingabe)"}),": Der Spieler kann nach Belieben einen Ort eingeben und spielen. Das ist via MapStartupController ja schon m\xf6glich."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Kampagnenmodus endlos (automatisch)"}),": Nach Level 3 geht es weiter mit prozeduralen Levels, ",(0,s.jsx)(n.em,{children:"ohne dass der Spieler jedes Mal eine Adresse eingeben muss"}),". F\xfcr diesen Modus sollte das Spiel ",(0,s.jsx)(n.strong,{children:"selbstst\xe4ndig Orte ausw\xe4hlen"})," oder zumindest einen Standardort verwenden. Einige Ideen:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Man k\xf6nnte eine Liste von interessanten Orten vorbereiten (im Code gibt es ja bereits ",(0,s.jsx)(n.code,{children:"suggestedAddresses"})," mit Leipzig Markt, Brandenburger Tor etc.). Man k\xf6nnte also Level 4 = Leipzig, Level 5 = Berlin, Level 6 = M\xfcnchen usw. automatisch setzen. Ist die Liste durch, entweder zyklisch wiederholen oder zuf\xe4llig w\xe4hlen."]}),"\n",(0,s.jsxs)(n.li,{children:["Alternativ tats\xe4chlich ",(0,s.jsx)(n.em,{children:"Zufallskoordinaten"})," nehmen, evtl. eingeschr\xe4nkt auf Stadtgebiete. Reiner Zufall k\xf6nnte den Spieler ins Nirgendwo setzen, was langweilig w\xe4re. Besser: aus einer Liste von Gro\xdfst\xe4dten weltweit oder in einem bestimmten Gebiet w\xe4hlen."]}),"\n",(0,s.jsxs)(n.li,{children:["Eine weitere M\xf6glichkeit: ",(0,s.jsx)(n.strong,{children:"Spielerstandort"})," als Start f\xfcr den Endlosmodus \u2013 z.B. Level 4 spielt in der eigenen Stadt des Spielers (sofern GPS verf\xfcgbar). Das w\xe4re ein cooles Feature (Realit\xe4tstreue), allerdings nicht immer praktikabel (man will evtl. nicht vor der eigenen Haust\xfcr Roll-a-Ball spielen, sondern lieber bekannte St\xe4dte)."]}),"\n",(0,s.jsxs)(n.li,{children:["F\xfcr den Anfang ist vermutlich die ",(0,s.jsx)(n.strong,{children:"Liste der vorgeschlagenen Orte"})," der einfachste Ansatz. Man k\xf6nnte in MapStartupController eine Funktion vorsehen, die beim Start der OSM-Szene pr\xfcft, ob sie im ",(0,s.jsx)(n.em,{children:"Auto-Progression"}),"-Modus l\xe4uft, und dann ohne UI-Eingabe sofort die AddressResolver mit einem voreingestellten Ort aufruft."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"UI-Unterdr\xfcckung im Auto-Modus:"})," Wenn Level4 automatisch generiert werden soll, soll der Spieler nicht jedes Mal das Adress-Eingabe-Panel sehen m\xfcssen. Man k\xf6nnte MapStartupController so erweitern, dass er erkennen kann, ob er aus der LevelProgression heraus gestartet wurde. Beispielsweise k\xf6nnte GameManager oder LevelManager einen Parameter setzen (vielleicht \xfcber PlayerPrefs oder eine static Variable) \u201eNextLevelLocation\u201c oder einen einfachen bool \u201eautoGenerateNext\u201c. Dann k\xf6nnte MapStartupController in Start() pr\xfcfen: falls autoGenerateNext=true, direkt ",(0,s.jsx)(n.code,{children:"LoadMapFromCoordinates/Address"})," mit dem gew\xfcnschten Ort aufrufen, anstatt ",(0,s.jsx)(n.code,{children:"ShowAddressInput()"}),". Die UI w\xfcrde dann gar nicht erst angezeigt, sondern direkt der Ladevorgang beginnen."]}),"\n",(0,s.jsxs)(n.li,{children:["Das ",(0,s.jsx)(n.strong,{children:"Fallback"}),"-System k\xf6nnte hier zweitverwertet werden: z.B. definieren wir den Fallback-Ort (Berlin) als Standard f\xfcr auto-generierte Levels. Dann k\xf6nnte man nach Level3 sagen: lade Fallback sofort (sofern der Spieler nicht manuell was ausw\xe4hlt)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Level-Abschluss in generierten Levels:"})," Damit die Endlos-Schleife funktioniert, muss jedes generierte Level auch beendet werden k\xf6nnen, und dann das n\xe4chste starten:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Collectibles/Goal Mechanik:"})," Es gibt zwei typische Ans\xe4tze, um ein Levelende zu definieren: ",(0,s.jsx)(n.em,{children:"alle Collectibles eingesammelt"})," oder ",(0,s.jsx)(n.em,{children:"Erreichen eines Zielbereichs"}),". Im aktuellen Roll-a-Ball ist offenbar vorgesehen, dass das Einsammeln aller Objekte den LevelManager das Level beenden l\xe4sst. Zus\xe4tzlich existiert ein \u201eGoalZone\u201c als Finish (vielleicht muss man nach Sammeln aller Items in diesen Bereich fahren, was dann LevelComplete ausl\xf6st)."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Um das in generierten Levels konsistent zu machen, sollte der ",(0,s.jsx)(n.strong,{children:"LevelManager auch in der OSM-Szene aktiv"})," sein und von Beginn an die generierten Collectibles kennen. L\xf6sung: Nachdem ",(0,s.jsx)(n.code,{children:"MapGenerator"})," die Collectibles platziert hat, muss man den LevelManager dar\xfcber informieren. Einfache Anpassung: In ",(0,s.jsx)(n.code,{children:"MapGenerator.PlaceCollectibles()"})," anstatt nur ",(0,s.jsx)(n.code,{children:"UpdateCollectibleCount()"})," aufzurufen, iteriere \xfcber die erstellten Collectible-GameObjects und rufe ",(0,s.jsx)(n.code,{children:"LevelManager.Instance.AddCollectible(collectibleController)"})," f\xfcr jedes auf. Dadurch:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["wird ",(0,s.jsx)(n.code,{children:"levelConfig.totalCollectibles"})," korrekt gesetzt,"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"OnCollectiblePickedUp"})," der Collectible-Controller wird im LevelManager abonniert,"]}),"\n",(0,s.jsx)(n.li,{children:"und die UI zeigt die Anzahl an."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Wichtig: Der LevelManager muss in der OSM-Szene vorhanden sein (kann z.B. als Singleton via DontDestroyOnLoad \xfcberleben oder man f\xfcgt einen ins OSM-Scene-Setup). Im Code sucht MapGenerator mit ",(0,s.jsx)(n.code,{children:"FindFirstObjectByType<LevelManager>()"})," nach einem LevelManager. Falls der nicht gefunden wird (aktuell wahrscheinlich so, weil im OSM-Setup nur GameManager genutzt wird), sollte man einen hinzuf\xfcgen."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"GoalZone"}),': Ebenfalls sollte man sicherstellen, dass die generierte GoalZone als solche erkannt wird. In LevelManager wird das Ziel via Tag "Finish" oder Name "GoalZone" gesucht. MapGenerator setzt den Namen bereits auf "GoalZone", aber vergisst, das Tag zu setzen. Es w\xe4re ratsam, dem GoalZone-Prefab den Tag "Finish" zu geben, damit LevelManager.FindGoalZone es findet. So kann man z.B. die Logik haben: alle Collectibles aufsammeln, dann erscheint evtl. (oder war schon sichtbar) die GoalZone \u2013 der Spieler rollt rein, und das triggert LevelComplete. Ggf. muss man einen Trigger am GoalZone-Prefab haben, der beim OnTriggerEnter den LevelManager.ForceCompleteLevel() ausl\xf6st, falls Collectibles schon alle weg sind.']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"N\xe4chsten Level laden/generieren:"})," Sobald ",(0,s.jsx)(n.code,{children:"LevelManager"})," das Ende erkennt (oder via GoalZone-Trigger), wird ",(0,s.jsx)(n.code,{children:"OnLevelCompleted"})," gefeuert und in ",(0,s.jsx)(n.code,{children:"LevelCompleteSequence"})," die n\xe4chste Szene geladen. Hier muss \u2013 wie oben besprochen \u2013 die n\xe4chste Szene definiert sein, entweder dieselbe OSM-Szene erneut (wenn man immer neu l\xe4dt) oder man generiert im gleichen Scene weiter."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Variante 1 (Scene neu laden):"}),' Man k\xf6nnte immer wieder "Level_OSM" neu laden. Das w\xfcrde MapStartupController von vorn starten lassen (mit evtl. neuer Adresse). Das ist einfach, aber eventuell unsauber, da GameManager als DontDestroy-On-Load deklariert ist und evtl. doppelt vorhanden sein k\xf6nnte. M\xfcsste man pr\xfcfen, wie GameManager Singleton gehandhabt wird (im Code wird er bei LoadLevel nicht zerst\xf6rt und bleibt).']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Variante 2 (in derselben Scene regenerieren):"})," Man l\xe4sst ",(0,s.jsx)(n.code,{children:"LevelCompleteSequence"})," keine neue Scene laden, sondern direkt ",(0,s.jsx)(n.code,{children:"MapGenerator.RegenerateMap()"}),' mit neuen Daten aufrufen. Das erfordert, den LevelManager ein wenig umzuschreiben, da er standardm\xe4\xdfig Scenes l\xe4dt. Evtl. k\xf6nnte man bei DetermineNextScene = "" speziell abfangen: Wenn currentScene == "Level_OSM" und man will endlos bleiben, dann eine Routine aufrufen, die MapGenerator neu startet. Dies w\xe4re eine Sonderbehandlung und vermischt LevelManager mit MapGenerator \u2013 nicht optimal.']}),"\n",(0,s.jsxs)(n.li,{children:['Praktischer ist vermutlich doch, jedes Mal "Level_OSM" neu zu laden. Dabei kann man in ',(0,s.jsx)(n.code,{children:"OnLevelCompleted"})," statt GameOver ein ",(0,s.jsx)(n.strong,{children:"Reload"}),' ansto\xdfen. Z.B. DetermineNextScene k\xf6nnte "Level_OSM" zur\xfcckgeben, sodass in ',(0,s.jsx)(n.code,{children:"LoadNextLevel()"})," die Scene neu geladen wird. Allerdings m\xfcsste man dann dem MapStartupController mitteilen, welche neue Location zu laden ist (z.B. n\xe4chste in Liste). Hier k\xf6nnte man wie gesagt PlayerPrefs oder statische Variablen nutzen, um zwischen den Scene-Loads den n\xe4chsten Ort zu speichern."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Progression/Difficulty:"})," Im Endlosmodus k\xf6nnte man den Schwierigkeitsgrad steigern. Z.B. sukzessive:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Mehr Collectibles platzieren (derzeit feste 2 pro Geb\xe4ude). Man k\xf6nnte ",(0,s.jsx)(n.code,{children:"collectiblesPerBuilding"})," nach jedem Level erh\xf6hen oder abh\xe4ngig von Levelnummer variieren."]}),"\n",(0,s.jsx)(n.li,{children:"Gr\xf6\xdferer Suchradius: Ein gr\xf6\xdferes Gebiet bedeutet mehr Objekte und potenziell l\xe4ngere Spielzeit pro Level. Z.B. Level4 = 500m, Level5 = 600m, etc. Allerdings w\xe4chst damit exponentiell die Datenmenge \u2013 Overpass k\xf6nnte jenseits 1km in St\xe4dten sehr viele Elemente liefern. Das muss man testen; evtl. sollte man 500m belassen."}),"\n",(0,s.jsxs)(n.li,{children:["Zeitlimit: In LevelConfiguration gibt es Felder f\xfcr Zeitlimit. Denkbar w\xe4re, im Endlosmodus ein Zeitlimit einzuf\xfchren, das immer knapper wird, um Herausforderung zu erh\xf6hen. Aktuell ist das aber optional (",(0,s.jsx)(n.code,{children:"hasTimeLimit"})," meist false)."]}),"\n",(0,s.jsx)(n.li,{children:"Dies alles sind optionale Balancing-\xdcberlegungen, die man je nach gew\xfcnschter Spielerfahrung anpassen kann."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Zusammengefasst: ",(0,s.jsx)(n.strong,{children:"Nach Level 3"})," sollte automatisiert die OSM-Level-Szene geladen werden, und dort entweder ein Standardort oder eine Abfolge von Orten ohne weitere Nutzereingabe generiert werden. ",(0,s.jsx)(n.strong,{children:"Jedes generierte Level"})," muss dann wiederum abgeschlossen werden k\xf6nnen (durch Sammeln+Ziel oder nur Sammeln), worauf das n\xe4chste generiert wird. Diese Endlos-Schleife erfordert sorgf\xe4ltiges Zusammenspiel von LevelManager, MapGenerator und ggf. dem UI/StartupController, damit es nahtlos und verst\xe4ndlich f\xfcr den Spieler abl\xe4uft."]}),"\n",(0,s.jsxs)(n.h3,{id:"7-vervollst\xe4ndigung-der-benutzerfunktionen-adresseingabe-gps",children:["7. ",(0,s.jsx)(n.strong,{children:"Vervollst\xe4ndigung der Benutzerfunktionen (Adresseingabe, GPS)"})]}),"\n",(0,s.jsx)(n.p,{children:"Abseits der technischen Generierung sollten noch ein paar Kleinigkeiten im User Interface ausgebessert werden:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"GPS-Ortsbestimmung:"})," Der Button \u201eaktueller Standort\u201c sollte wie vorgesehen mit dem Ger\xe4tel Standort arbeiten. In Unity bedeutet das:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Vor dem ersten Aufruf ",(0,s.jsx)(n.code,{children:"Input.location.Start()"})," ausf\xfchren und ein bisschen Zeit geben, bis ",(0,s.jsx)(n.code,{children:"Input.location.status"})," auf ",(0,s.jsx)(n.strong,{children:"Running"})," ist (dies k\xf6nnte asynchron im Hintergrund passieren, evtl. mit einem kleinen \u201eWarten auf GPS...\u201c-Hinweis)."]}),"\n",(0,s.jsxs)(n.li,{children:["Dann ",(0,s.jsx)(n.code,{children:"Input.location.lastData.latitude/longitude"})," auslesen und an ",(0,s.jsx)(n.code,{children:"AddressResolver.LoadMapFromCoordinates(lat, lon)"})," \xfcbergeben."]}),"\n",(0,s.jsx)(n.li,{children:"Fehlerf\xe4lle beachten: GPS deaktiviert oder keine Fix -> entsprechende Fehlermeldung (\u201eStandort konnte nicht ermittelt werden.\u201c) und evtl. auf Fallback gehen."}),"\n",(0,s.jsx)(n.li,{children:"Im Editor/PC gibt es kein GPS \u2013 dort kann man wie jetzt einen Demo-Ort (Leipzig) verwenden oder den Button ausblenden. Der Code macht das bereits per Kommentar kenntlich. Man k\xf6nnte z.B. eine Compiler-Direktive oder Laufzeit-Abfrage nutzen: auf echter mobiler Plattform GPS nutzen, im Editor festen Wert."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Adresssuche verfeinern:"})," Derzeit wird die erste Nominatim-Treffermenge (limit=1) genommen. Das ist okay, aber bei unklaren Eingaben k\xf6nnte man dem Nutzer mehrere Vorschl\xe4ge zeigen. Da im UI bereits eine Suggestion-Liste f\xfcr Beispieladressen existiert, k\xf6nnte man diese evtl. dynamisch nutzen: z.B. w\xe4hrend der Eingabe bereits Nominatim-Autocomplete abfragen (es gibt eine API daf\xfcr), um dem Nutzer m\xf6gliche Adressen vorzuschlagen. Das w\xe4re Komfort, aber nicht zwingend."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Fehlermeldungen deutlicher:"})," Falls Overpass kein Ergebnis liefert, kommt die Meldung \u201eKeine Kartendaten f\xfcr diese Region verf\xfcgbar.\u201c. Diese sollte dem Nutzer evtl. erkl\xe4ren, dass er einen anderen Ort versuchen soll (statt sofort nach Fallback zu wechseln, wenn man das Verhalten \xe4ndern m\xf6chte). Im jetzigen Code wird bei jedem Fehler automatisch Fallback geladen, sofern aktiviert. \xdcberlegen, ob das immer gewollt ist: Wenn jemand z.B. \u201eAtlantik\u201c eingibt, landet er ungefragt in Berlin \u2013 besser w\xe4re evtl.: \u201eHier gibt es nichts \u2013 es wird eine Beispielkarte geladen.\u201c (So \xe4hnlich wird es gemacht: die Fehlermeldung concatenated das bereits mit \u201eLade Fallback-Karte...\u201c). Das passt schon, eventuell k\xf6nnte man aber dem Spieler danach erlauben, doch noch eine andere Adresse einzugeben, anstatt ihn fix nach Berlin zu setzen. Ist jedoch Feinheit."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Sprachliche Anpassungen:"}),' Die UI-Texte mischen derzeit Deutsch und Englisch (z.B. "Level Complete!" als Notification in LevelManager, aber Fehlermeldungen und Hinweise sind auf Deutsch). Hier k\xf6nnte man f\xfcr Konsistenz sorgen. Wahrscheinlich sollen Spielertexte alle Deutsch sein. Entsprechend "Level abgeschlossen!" statt "Level Complete!" etc. Gleiches gilt f\xfcr evtl. "Checkpoint erreicht!" usw., falls das relevant ist.']}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Durch diese UI-Verbesserungen wird der ",(0,s.jsx)(n.strong,{children:"Bedienkomfort"})," erh\xf6ht und die Features (Adresseingabe, aktueller Standort) funktionieren wie erwartet. Insbesondere die GPS-Funktion kann ein Alleinstellungsmerkmal sein \u2013 der Spieler kann sein eigenes Viertel oder einen realen Ort seiner Wahl im Spiel erleben."]}),"\n",(0,s.jsxs)(n.h3,{id:"8-weiteres-feintuning-und-zuk\xfcnftige-erweiterungen",children:["8. ",(0,s.jsx)(n.strong,{children:"Weiteres Feintuning und zuk\xfcnftige Erweiterungen"})]}),"\n",(0,s.jsx)(n.p,{children:"Abschlie\xdfend noch ein paar Gedanken, die \xfcber das Muss hinausgehen, aber perspektivisch interessant sein k\xf6nnen:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Mehr OSM-Elemente einbeziehen:"})," Bisher liegen Fokus auf Stra\xdfen, Geb\xe4uden, Fl\xe4chen. Man k\xf6nnte aus den OSM-Daten noch mehr herausziehen:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"POIs als Objekte:"}),' Bereits erw\xe4hnt, Amenities/Shops k\xf6nnten als spezielle Objekte im Spiel auftauchen \u2013 z.B. k\xf6nnte man an POI-Koordinaten Power-ups oder Hindernisse spawnen, um das Gameplay zu erweitern (eine Fantasie: an der Position einer \u201ePolice Station\u201c ein Steampunk-Wachroboter als Gegner, oder bei "Shop" ein Bonus-Item etc.).']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Beschriftungen:"})," Man k\xf6nnte die wichtigsten Stra\xdfennamen oder Ortsschilder einblenden (via TextMeshPro 3D Text in der Szene). In einem Roll-a-Ball sind Label eher irrelevant f\xfcrs Gameplay, aber k\xf6nnten das Gef\xfchl einer echten Stadt verst\xe4rken."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Verkehrselemente:"})," Ampeln, Laternen, B\xe4nke \u2013 all das ist theoretisch in OSM (amenity=bench etc.). Es w\xe4re aber wahrscheinlich Overkill f\xfcr dieses Spiel."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Gameplay-Mechanik auf Karte anpassen:"})," Wenn die Karte komplexer wird (viele Geb\xe4ude, evtl. Sackgassen), sollte man pr\xfcfen, ob der Ball immer \xfcberall hinkann. Nicht dass Collectibles an unerreichbaren Stellen landen. Der Generator platziert sie zuf\xe4llig um Geb\xe4ude und an Stra\xdfenrand. Das kann auch mal auf einem Dach oder mitten auf der Stra\xdfe sein. Vielleicht sollte man sicherstellen, dass ",(0,s.jsx)(n.code,{children:"y"})," der Collectibles immer knapp \xfcber Boden liegt und nicht auf Geb\xe4uded\xe4chern (derzeit wird bei Geb\xe4uden ein zuf\xe4lliger Knoten genommen \u2013 das k\xf6nnten auch Dach-Ecken sein, die jedoch in Weltkoordinaten auf Bodenprojektion umgerechnet werden, da LatLonToWorld Y=0 ausgibt). Wahrscheinlich landen sie also am Boden neben dem Geb\xe4ude \u2013 das passt. Falls man realistischer w\xe4re, k\xf6nnte man z.B. sagen: in Parks spawnen zus\xe4tzliche Collectibles, auf Wasser keine usw. Das sind Feineinstellungen, die man basierend auf Tests optimieren kann."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Ma\xdfstabs-Verbesserung:"})," Sollte der Anspruch bestehen, Entfernungen korrekt abzubilden, k\xf6nnte man die ",(0,s.jsx)(n.strong,{children:"Latitude-Kosinus-Korrektur"})," einbauen: d.h. den Ost-West-Bereich in Metern berechnen als ",(0,s.jsx)(n.code,{children:"(maxLon-minLon) * cos(Mittelbreite) * 111320"}),". Dann k\xf6nnte man ",(0,s.jsx)(n.code,{children:"scaleMultiplier"})," so setzen, dass z.B. ",(0,s.jsx)(n.strong,{children:"1 Einheit = 1 Meter"})," ist. In der Praxis w\xfcrde man den Ma\xdfstab einfach als z.B. 1 Unity = 1m fixieren und die Lat/Lon in eine lokale Meterprojektion umrechnen (z.B. UTM oder Mercator auf die lokale Patch). F\xfcr den kleinen Ma\xdfstab reicht aber eine flache equirectangulare Projektion wie bisher. Nur sollte man konsequent den Umrechnungsfaktor so w\xe4hlen, dass keine extremen Verzerrungen entstehen. Eventuell k\xf6nnte man den ",(0,s.jsx)(n.strong,{children:"Mittelpunkt"})," der Karte als Bezugspunkt nehmen und alle Koordinaten in Meterabst\xe4nde relativ dazu konvertieren (z.B. mit der haversine-Formel oder approximativ: \u0394lat in m = \u0394lat_deg * 111320; \u0394lon in m = \u0394lon_deg * 111320 * cos(lat)). Dann direkt diese Meter als Unity-Koordinaten verwenden (ggf. skaliert durch einen Faktor, falls man nicht 1:1 Meter haben will). Im Moment passiert die Skalierung indirekt \xfcber ",(0,s.jsx)(n.code,{children:"scaleMultiplier"}),", was man beibehalten kann, aber definierter gestalten sollte (z.B. so, dass 500m Radius = 500 Unity-Einheiten). Das h\xe4tte den Vorteil, dass z.B. die Ball-Geschwindigkeit oder Sprungweite im Spiel realistischen Bezug hat \u2013 momentan wei\xdf man das nicht genau, da 500m zu 1000 Units f\xfchrt, also 1 Unit = 0.5 m ungef\xe4hr. Einheitlichkeit w\xe4re w\xfcnschenswert, ist aber kein kritisch sichtbares Problem."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Mit den oben vorgeschlagenen \xc4nderungen w\xfcrde die Karte ",(0,s.jsx)(n.strong,{children:"automatisch und korrekt aus OSM-Daten generiert"})," werden, was dem urspr\xfcnglichen Ziel entspricht. Die Verbesserungspotenziale liegen vor allem darin, aus den bislang statischen/Platzhalter-basierten Komponenten eine dynamische, realit\xe4tsgetreue Level-Umgebung zu formen und diese nahtlos ins Spiel einzubetten. Wichtig ist dabei, Schritt f\xfcr Schritt vorzugehen \u2013 zun\xe4chst die Kernfunktion (OSM-Parsen und Basis-Objekte generieren), dann Feinschliff bei Optik und Performance, und schlie\xdflich die Integration ins Spieldesign (Level-Abfolge, Schwierigkeit, UI). So entsteht aus der vorhandenen Codebasis ein deutlich reichhaltigeres Spielerlebnis, in dem der Nutzer echte Orte als Spielwelt erleben kann."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Quellen:"})," Code-Analyse der bereitgestellten Klassen ",(0,s.jsx)(n.em,{children:"AddressResolver"})," und ",(0,s.jsx)(n.em,{children:"MapGenerator"})," aus dem Roll-a-Ball-Projekt, sowie zugeh\xf6rige Manager-Klassen (LevelManager, MapStartupController) f\xfcr das Zusammenspiel von Level-Logik und OSM-Integration. Die Hinweise im Code \u2013 etwa die tempor\xe4ren Platzhalter-Daten, die vereinfachte Mesh-Erstellung und die Kommentare zur geplanten prozeduralen Erweiterung \u2013 dienten als Grundlage f\xfcr die obigen Verbesserungsvorschl\xe4ge."]})]})}function o(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);