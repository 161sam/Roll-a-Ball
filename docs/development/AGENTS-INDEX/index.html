<!doctype html>
<html lang="de" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-development/AGENTS-INDEX" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">ğŸ¤– AGENTEN-ÃœBERSICHT | Roll-a-Ball</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://161sam.github.io/Roll-a-Ball/img/social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://161sam.github.io/Roll-a-Ball/img/social-card.jpg"><meta data-rh="true" property="og:url" content="https://161sam.github.io/Roll-a-Ball/docs/development/AGENTS-INDEX"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="ğŸ¤– AGENTEN-ÃœBERSICHT | Roll-a-Ball"><meta data-rh="true" name="description" content="In diesem Dokument werden die verschiedenen KI-Agenten (OpenAI Codex, Claude via Unity MCP) beschrieben, die zur Analyse, Korrektur und Erweiterung des Roll-a-Ball Projekts eingesetzt werden. Jeder Agent fokussiert sich auf eine bestimmte Phase oder Komponente der Entwicklung mit klar definierten Zielen, Arbeitsschritten und Erfolgsindikatoren."><meta data-rh="true" property="og:description" content="In diesem Dokument werden die verschiedenen KI-Agenten (OpenAI Codex, Claude via Unity MCP) beschrieben, die zur Analyse, Korrektur und Erweiterung des Roll-a-Ball Projekts eingesetzt werden. Jeder Agent fokussiert sich auf eine bestimmte Phase oder Komponente der Entwicklung mit klar definierten Zielen, Arbeitsschritten und Erfolgsindikatoren."><link data-rh="true" rel="icon" href="/Roll-a-Ball/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://161sam.github.io/Roll-a-Ball/docs/development/AGENTS-INDEX"><link data-rh="true" rel="alternate" href="https://161sam.github.io/Roll-a-Ball/docs/development/AGENTS-INDEX" hreflang="de"><link data-rh="true" rel="alternate" href="https://161sam.github.io/Roll-a-Ball/docs/development/AGENTS-INDEX" hreflang="x-default"><link rel="stylesheet" href="/Roll-a-Ball/assets/css/styles.8fefdf5d.css">
<script src="/Roll-a-Ball/assets/js/runtime~main.e1ccd019.js" defer="defer"></script>
<script src="/Roll-a-Ball/assets/js/main.239bf00c.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/Roll-a-Ball/img/logo.svg"><div role="region" aria-label="Zum Hauptinhalt springen"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Zum Hauptinhalt springen</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Roll-a-Ball/"><div class="navbar__logo"><img src="/Roll-a-Ball/img/logo.svg" alt="Roll-a-Ball Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Roll-a-Ball/img/logo.svg" alt="Roll-a-Ball Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Roll-a-Ball</b></a><a class="navbar__item navbar__link" href="/Roll-a-Ball/docs/intro">Entwicklung</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/161sam/Roll-a-Ball" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Umschalten zwischen dunkler und heller Ansicht (momentan system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="ZurÃ¼ck nach oben scrollen" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Auf dieser Seite</button></div><div class="theme-doc-markdown markdown"><header><h1>ğŸ¤– AGENTEN-ÃœBERSICHT</h1></header>
<p>In diesem Dokument werden die verschiedenen <strong>KI-Agenten</strong> (OpenAI Codex, Claude via Unity MCP) beschrieben, die zur Analyse, Korrektur und Erweiterung des Roll-a-Ball Projekts eingesetzt werden. Jeder Agent fokussiert sich auf eine bestimmte Phase oder Komponente der Entwicklung mit klar definierten Zielen, Arbeitsschritten und Erfolgsindikatoren.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenauftrag-roll-a-ball-scene-normalisierung--ui-korrektur-phase-3">ğŸ¯ Agentenauftrag: Roll-a-Ball Scene Normalisierung &amp; UI-Korrektur (Phase 3)<a href="#-agentenauftrag-roll-a-ball-scene-normalisierung--ui-korrektur-phase-3" class="hash-link" aria-label="Direkter Link zur ğŸ¯ Agentenauftrag: Roll-a-Ball Scene Normalisierung &amp; UI-Korrektur (Phase 3)" title="Direkter Link zur ğŸ¯ Agentenauftrag: Roll-a-Ball Scene Normalisierung &amp; UI-Korrektur (Phase 3)">â€‹</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenname">ğŸ§  Agentenname<a href="#-agentenname" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenname" title="Direkter Link zur ğŸ§  Agentenname">â€‹</a></h3>
<p><code>SceneNormalizerAgent</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ï¸-projektverzeichnis">ğŸ—‚ï¸ Projektverzeichnis<a href="#ï¸-projektverzeichnis" class="hash-link" aria-label="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis" title="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis">â€‹</a></h3>
<p><code>/home/saschi/Games/Roll-a-Ball/</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-ziel">ğŸ” Ziel<a href="#-ziel" class="hash-link" aria-label="Direkter Link zur ğŸ” Ziel" title="Direkter Link zur ğŸ” Ziel">â€‹</a></h3>
<p>Alle Unity-Szenen im Projekt sollen <strong>konsistent, funktionsfÃ¤hig und prefab-basiert</strong> aufgebaut sein. Insbesondere mÃ¼ssen UI-Elemente korrekt verankert, referenziert und benutzbar sein. Dieser Agent identifiziert systematisch Abweichungen in den Szenen und dokumentiert sowie korrigiert diese.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-auftragsschritte">ğŸ“Œ Auftragsschritte<a href="#-auftragsschritte" class="hash-link" aria-label="Direkter Link zur ğŸ“Œ Auftragsschritte" title="Direkter Link zur ğŸ“Œ Auftragsschritte">â€‹</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-szene-erkennung">1. Szene-Erkennung<a href="#1-szene-erkennung" class="hash-link" aria-label="Direkter Link zur 1. Szene-Erkennung" title="Direkter Link zur 1. Szene-Erkennung">â€‹</a></h4>
<ul>
<li>Alle <code>.unity</code>-Dateien im Verzeichnis <code>Assets/Scenes/</code> werden aufgelistet (z.â€¯B. <em>GeneratedLevel.unity</em>, <em>Level1.unity</em>, <em>Level2.unity</em>, <em>Level3.unity</em>, <em>Level_OSM.unity</em>, <em>MiniGame.unity</em>).</li>
<li>Es wird eine Liste aller Szenennamen mit ihren Speicherpfaden erstellt, um sicherzustellen, dass keine Szene Ã¼bersehen wird.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-szenen-laden--analysieren">2. Szenen laden &amp; analysieren<a href="#2-szenen-laden--analysieren" class="hash-link" aria-label="Direkter Link zur 2. Szenen laden &amp; analysieren" title="Direkter Link zur 2. Szenen laden &amp; analysieren">â€‹</a></h4>
<ul>
<li>
<p>Der Agent lÃ¤dt jede gefundene Szene nacheinander im Unity Editor (Ã¼ber Unity MCP) und inspiziert systematisch alle <strong>GameObjects</strong>, <strong>UI-Elemente</strong> und <strong>Prefab-Referenzen</strong>.</p>
</li>
<li>
<p>Folgende PrÃ¼fkategorien werden fÃ¼r jede Szene durchlaufen:</p>
<ul>
<li>
<p><strong>Prefab-Check:</strong> PrÃ¼fen, ob <strong>Ground</strong>, <strong>Wall</strong>, <strong>Collectible</strong> und <strong>GoalZone</strong> als Instanzen der vorgesehenen Prefabs platziert sind. Manuell duplizierte Objekte (statt Prefab-Nutzung) werden erkannt. Ebenso wird Ã¼berprÃ¼ft, ob benÃ¶tigte Skripte wie <code>CollectibleController</code> oder <code>GoalZoneTrigger</code> an den Objekten hÃ¤ngen.</p>
</li>
<li>
<p><strong>UI-Check:</strong> Sicherstellen, dass ein funktionierender <strong>Canvas</strong> mit korrekt eingestelltem <code>CanvasScaler</code> (Scale With Screen Size) und ein <strong>EventSystem</strong> vorhanden sind. Alle UI-Textfelder und Buttons mÃ¼ssen richtig verankert sein (Anchors) und ein <code>UIController</code> sollte existieren und mit den UI-Elementen verknÃ¼pft sein.</p>
</li>
<li>
<p><strong>Hierarchie-Check:</strong> ÃœberprÃ¼fen, ob alle obligatorischen Objekte in der Szene vorhanden und richtig konfiguriert sind:</p>
<ul>
<li><strong>Main Camera:</strong> Existiert und hat das Skript <code>CameraFollow</code> (oder entsprechendes Kamerasteuerungs-Skript) angehÃ¤ngt.</li>
<li><strong>Player:</strong> Existiert mit dem <code>PlayerController</code>-Skript und korrekten Physik-Einstellungen.</li>
<li><strong>GameManager / LevelManager:</strong> Entsprechende Manager-Objekte sind in der Szene und verwalten den Spielzustand (z.â€¯B. Level-Fortschritt, Punktestand).</li>
<li><strong>Tags &amp; Layers:</strong> Wichtige Objekte tragen die erwarteten Tags (z.â€¯B. Player, Collectible) und befinden sich auf den korrekten Layers (z.â€¯B. Ground, Obstacles), damit Kollisionen und Trigger einheitlich funktionieren.</li>
<li><strong>Spezial-Objekte:</strong> Falls die Szene steampunk-spezifische Objekte enthÃ¤lt (z.â€¯B. <code>MovingPlatform</code>, <code>RotatingObstacle</code>, Tore), wird geprÃ¼ft, ob diese die nÃ¶tigen Komponenten/Skripte besitzen und ordnungsgemÃ¤ÃŸ funktionieren.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-fehlerbericht--korrekturvorschlÃ¤ge">3. Fehlerbericht &amp; KorrekturvorschlÃ¤ge<a href="#3-fehlerbericht--korrekturvorschlÃ¤ge" class="hash-link" aria-label="Direkter Link zur 3. Fehlerbericht &amp; KorrekturvorschlÃ¤ge" title="Direkter Link zur 3. Fehlerbericht &amp; KorrekturvorschlÃ¤ge">â€‹</a></h4>
<ul>
<li>FÃ¼r jede Szene erstellt der Agent einen Markdown-Bericht <code>SceneReport_&lt;Szene&gt;.md</code>. Darin werden <strong>abweichende Befunde</strong> festgehalten, z.â€¯B. fehlende Prefab-Verwendung, falsche Komponenten oder defekte UI-Elemente.</li>
<li>Unter <em>âš ï¸ Probleme</em> listet der Bericht alle gefundenen Fehler und Inkonsistenzen (z.â€¯B. <em>&quot;Collectible X ist kein Prefab-Instance&quot;</em>, <em>&quot;CanvasScaler fehlt auf Canvas&quot;</em>, <em>&quot;Player fehlt Tag=Player&quot;</em>).</li>
<li>Unter <em>âœ… Empfehlungen</em> folgen konkrete VorschlÃ¤ge zur Behebung jedes Problems (etwa Ersatz eines duplizierten Objekts durch das entsprechende Prefab, HinzufÃ¼gen eines EventSystems, Zuweisung fehlender Skriptreferenzen).</li>
<li>AuÃŸerdem enthÃ¤lt der Bericht einen Abschnitt <em>ğŸ”„ KonsolidierungsvorschlÃ¤ge</em>, der zusammenfasst, wie die Szene insgesamt an den Standard angepasst werden kann (z.â€¯B. Ersetzen aller Boden-Objekte durch <code>GroundPrefab</code>, Neuaufbau der UI anhand einer funktionierenden Vorlage). AbschlieÃŸend gibt eine <em>ğŸ“Š Statistik</em> einen Ãœberblick, wie viele Prefabs korrekt bzw. falsch instanziert wurden (z.â€¯B. <em>10/12 Prefabs konsistent</em>).</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-optional-automatisierte-korrektur">4. Optional: Automatisierte Korrektur<a href="#4-optional-automatisierte-korrektur" class="hash-link" aria-label="Direkter Link zur 4. Optional: Automatisierte Korrektur" title="Direkter Link zur 4. Optional: Automatisierte Korrektur">â€‹</a></h4>
<ul>
<li>Wenn konfiguriert, nimmt der Agent direkt Korrekturen in den Szenen vor: Manuell duplizierte Objekte werden <strong>gelÃ¶scht und durch Prefab-Instanzen ersetzt</strong>. Fehlende Canvas-Elemente (Canvas, EventSystem) werden neu erstellt mit korrekten Einstellungen.</li>
<li>UI-Elemente, die falsch verankert sind, werden neu positioniert oder mit geeigneten Anchor-Presets versehen. Falls die UI einer Szene unbrauchbar ist, kann der Agent optional die UI <strong>komplett neu aufbauen</strong> (entsprechend dem Standard-Layout aus einer funktionierenden Szene).</li>
<li>Einheitliche <strong>Kamera-, Manager- und Player-Setups</strong> werden in allen Szenen sichergestellt (z.â€¯B. HinzufÃ¼gen des <code>GameManager</code>-Prefabs falls nicht vorhanden, Setzen der Kamera-Tag und -Follow-Skript, etc.).</li>
<li>Veraltete oder duplizierte Komponenten werden entweder deaktiviert oder â€“ falls nÃ¶tig â€“ durch neuere API-Versionen (Unity 6.1 kompatibel) ersetzt. Beispielsweise kÃ¶nnten obsolete Input-Handling-Komponenten durch das neue Input-System ersetzt werden, falls dies im Projektstandard so vorgesehen ist.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-erfolgsbedingungen">âœ… Erfolgsbedingungen<a href="#-erfolgsbedingungen" class="hash-link" aria-label="Direkter Link zur âœ… Erfolgsbedingungen" title="Direkter Link zur âœ… Erfolgsbedingungen">â€‹</a></h3>
<p>Der Agent gilt als erfolgreich, wenn anschlieÃŸend:</p>
<ul>
<li><strong>Keine Fehler</strong> oder Warnungen in der Unity-Konsole beim Laden jeder Szene auftreten.</li>
<li>Alle Szenen einheitlich funktionieren (Spielerbewegung, Collectibles einsammeln, Level-Abschluss etc. in jeder Szene mÃ¶glich).</li>
<li>Die UI in allen Szenen ist vollstÃ¤ndig sichtbar, responsiv (skalierend) und zeigt die richtigen Informationen an (z.â€¯B. Anzahl gesammelter Objekte, Level-Name).</li>
<li><strong>Prefab-Konsistenz &gt; 95%</strong>: Nahezu alle wiederverwendbaren Objekte in den Szenen basieren auf den vorgesehenen Prefabs statt auf Kopien.</li>
<li>Alle relevanten <strong>Skripte sind korrekt zugewiesen</strong> (keine Missing Script Fehler) und wichtige Objekte haben die richtigen Tags/Layers.</li>
</ul>
<p>Erst wenn jede Szene die obigen Kriterien erfÃ¼llt, wird die Normalisierung als abgeschlossen betrachtet.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-status-tracking">ğŸ§¾ Status-Tracking<a href="#-status-tracking" class="hash-link" aria-label="Direkter Link zur ğŸ§¾ Status-Tracking" title="Direkter Link zur ğŸ§¾ Status-Tracking">â€‹</a></h3>
<p>Zu jeder Szene wird der Bearbeitungsstand festgehalten:</p>
<table><thead><tr><th><strong>Szene</strong></th><th style="text-align:center"><strong>Analysiert</strong></th><th style="text-align:center"><strong>Fehlerfrei</strong></th><th style="text-align:center"><strong>UI repariert</strong></th><th style="text-align:center"><strong>Prefabs konsistent</strong></th><th><strong>Report-Datei</strong></th></tr></thead><tbody><tr><td>GeneratedLevel</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td><code>SceneReport_GeneratedLevel.md</code></td></tr><tr><td>Level1</td><td style="text-align:center">âœ…</td><td style="text-align:center">âœ…</td><td style="text-align:center">âœ…</td><td style="text-align:center">âœ…</td><td><code>SceneReport_Level1.md</code></td></tr><tr><td>Level2</td><td style="text-align:center">âœ…</td><td style="text-align:center">âŒ</td><td style="text-align:center">âœ…</td><td style="text-align:center">ğŸ”„</td><td><code>SceneReport_Level2.md</code></td></tr><tr><td>Level3</td><td style="text-align:center">âœ…</td><td style="text-align:center">âŒ</td><td style="text-align:center">âŒ</td><td style="text-align:center">ğŸ”„</td><td><code>SceneReport_Level3.md</code></td></tr><tr><td>Level_OSM</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td><code>SceneReport_Level_OSM.md</code></td></tr><tr><td>MiniGame</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td style="text-align:center">â³</td><td><code>SceneReport_MiniGame.md</code></td></tr></tbody></table>
<blockquote>
<p><strong>Legende:</strong> âœ… = erledigt, âŒ = Mangel/Fehler vorhanden, ğŸ”„ = teilweise erledigt/in Bearbeitung, â³ = noch ausstehend. <em>(Die Tabelle wird automatisch aktualisiert, sobald Berichte erstellt oder Korrekturen durchgefÃ¼hrt wurden.)</em></p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenlogik">ğŸ§  Agentenlogik<a href="#-agentenlogik" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenlogik" title="Direkter Link zur ğŸ§  Agentenlogik">â€‹</a></h3>
<p>Der <strong>SceneNormalizerAgent</strong> verwendet <em>OpenAI Codex</em> (integriert Ã¼ber Unity MCP) zur Analyse und Modifikation der Unity-Szenen. Er hat Zugriff auf:</p>
<ul>
<li><strong>Unity Editor APIs:</strong> Kann Szenen programmgesteuert laden (<code>EditorSceneManager</code>), Objekte finden (<code>FindObjectsOfType</code>), Prefabs instanziieren und UI-Anker setzen.</li>
<li><strong>Dateisystem:</strong> Darf Projektdateien lesen und schreiben (z.â€¯B. mit <code>read_file</code>, <code>edit_file</code> Aktionen), um Reports zu erzeugen oder Prefab-VerknÃ¼pfungen zu Ã¤ndern.</li>
<li><strong>Konsole &amp; Logs:</strong> Liest Konsolenausgaben (<code>read_console</code>), um Fehler oder Warnungen zu erkennen, die wÃ¤hrend des Szenenladens auftreten.</li>
<li><strong>Unity Scripting:</strong> Kann Unity-Skripte ausfÃ¼hren, um z.â€¯B. per Script Light die Hierarchie zu prÃ¼fen oder Objekte zu ersetzen (<code>ReplaceWithPrefab</code>, <code>FixUIAnchors</code> sind interne Routinen).</li>
</ul>
<p>Dank dieser FÃ¤higkeiten kann der Agent sowohl <strong>diagnostizieren</strong> als auch <strong>intervenieren</strong>, um die Szenen ohne manuelles Eingreifen zu reparieren. Alle Ã„nderungen erfolgen skriptgesteuert und nachvollziehbar in den generierten SceneReport-Dateien.</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenauftrag-openstreetmap-integration-phase-4">ğŸ¯ Agentenauftrag: OpenStreetMap Integration (Phase 4)<a href="#-agentenauftrag-openstreetmap-integration-phase-4" class="hash-link" aria-label="Direkter Link zur ğŸ¯ Agentenauftrag: OpenStreetMap Integration (Phase 4)" title="Direkter Link zur ğŸ¯ Agentenauftrag: OpenStreetMap Integration (Phase 4)">â€‹</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenname-1">ğŸ§  Agentenname<a href="#-agentenname-1" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenname" title="Direkter Link zur ğŸ§  Agentenname">â€‹</a></h3>
<p><code>OSMIntegrationAgent</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ï¸-projektverzeichnis-1">ğŸ—‚ï¸ Projektverzeichnis<a href="#ï¸-projektverzeichnis-1" class="hash-link" aria-label="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis" title="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis">â€‹</a></h3>
<p><code>/home/saschi/Games/Roll-a-Ball/</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-ziel-1">ğŸ” Ziel<a href="#-ziel-1" class="hash-link" aria-label="Direkter Link zur ğŸ” Ziel" title="Direkter Link zur ğŸ” Ziel">â€‹</a></h3>
<p>Die Spielszene <em>Level_OSM</em> soll echte Kartendaten integrieren, sodass Spieler durch Eingabe einer <strong>Adresse</strong> ihre eigene Stadt als Roll-a-Ball-Level erleben kÃ¶nnen. Ziel ist eine vollstÃ¤ndige <strong>OpenStreetMap-Integration</strong>: StraÃŸenzÃ¼ge werden zu begehbaren Pfaden, GebÃ¤ude als Hindernisse generiert und Collectibles strategisch in der echten Umgebung platziert â€“ alles im bestehenden Steampunk-Stil des Spiels. Die Integration muss nahtlos ins Spiel passen (UI, Gameplay, Performance) und robust gegen Fehler funktionieren (Fallback bei fehlender Internetverbindung oder ungÃ¼ltigen Adressen).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-auftragsschritte-1">ğŸ“Œ Auftragsschritte<a href="#-auftragsschritte-1" class="hash-link" aria-label="Direkter Link zur ğŸ“Œ Auftragsschritte" title="Direkter Link zur ğŸ“Œ Auftragsschritte">â€‹</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-osm-framework-einbinden">1. OSM-Framework einbinden<a href="#1-osm-framework-einbinden" class="hash-link" aria-label="Direkter Link zur 1. OSM-Framework einbinden" title="Direkter Link zur 1. OSM-Framework einbinden">â€‹</a></h4>
<ul>
<li><strong>APIs vorbereiten:</strong> Der Agent richtet den Zugriff auf die OpenStreetMap-APIs ein. Dazu gehÃ¶rt die <strong>Nominatim API</strong> fÃ¼r Geocoding (Umwandlung von Adresse zu Koordinaten) und die <strong>Overpass API</strong> fÃ¼r das Abrufen von Kartendaten (StraÃŸen, GebÃ¤ude etc.). Es wird sichergestellt, dass keine API-SchlÃ¼ssel nÃ¶tig sind bzw. falls doch, diese konfiguriert werden.</li>
<li><strong>Datenstrukturen definieren:</strong> Es werden C#-Klassen fÃ¼r die OSM-Daten erstellt (z.â€¯B. eine Klasse <code>OSMMapData</code> mit Listen von StraÃŸen, GebÃ¤uden, FlÃ¤chen und Bounds). Diese sollen serialisierbar sein, um die empfangenen JSON/XML-Daten bequem zu speichern und weiterzuverarbeiten.</li>
<li><strong>AddressResolver entwickeln:</strong> Ein Skript <code>AddressResolver</code> wird implementiert, das eine vom Spieler eingegebene Adresse entgegennimmt und asynchron die Geo-Koordinaten abruft. Bei Erfolg soll ein Event (z.â€¯B. <code>OnMapDataReady</code>) ausgelÃ¶st werden, das den Start der Kartengenerierung triggert. FehlerfÃ¤lle (kein Ergebnis, ZeitÃ¼berschreitung) mÃ¼ssen abgefangen und gemeldet werden (z.â€¯B. via <code>OnError</code> Event und UI-Dialog).</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-kartengenerierung-implementieren">2. Kartengenerierung implementieren<a href="#2-kartengenerierung-implementieren" class="hash-link" aria-label="Direkter Link zur 2. Kartengenerierung implementieren" title="Direkter Link zur 2. Kartengenerierung implementieren">â€‹</a></h4>
<ul>
<li><strong>MapGenerator entwickeln:</strong> Der Agent erstellt ein zentrales Skript <code>MapGenerator</code>, das die von <code>AddressResolver</code> erhaltenen OSM-Daten in <strong>Unity-GameObjects</strong> umwandelt. StraÃŸen (<code>highway</code> in OSM) werden z.â€¯B. als begehbare Wege generiert (z.â€¯B. durch Instanziieren eines StraÃŸen-Prefabs oder Extrudieren eines Meshes entlang der Koordinaten). GebÃ¤ude (<code>building</code> in OSM) werden als Hindernisse platziert (z.â€¯B. platzierte Quader mit HÃ¶he basierend auf GebÃ¤ude-Tags oder standardisiert). Parks und GewÃ¤sser kÃ¶nnen mit speziellen Materialien oder flachen Objekten dargestellt werden, um visuelle Abwechslung zu bieten.</li>
<li><strong>Prefab-Nutzung:</strong> Soweit mÃ¶glich nutzt der MapGenerator vorhandene Prefabs aus dem Projekt: FÃ¼r StraÃŸen ein Boden- oder StraÃŸen-Prefab (z.â€¯B. <code>GroundPrefab</code>), fÃ¼r GebÃ¤ude ggf. <code>WallPrefab</code> oder ein neues GebÃ¤ude-Prefab, fÃ¼r Sammelobjekte natÃ¼rlich das vorhandene <code>CollectiblePrefab</code>. Die <strong>Steampunk-Optik</strong> wird beibehalten, indem z.â€¯B. spezielle Materialien (Kupfer, Messing) auf die generierten Objekte gelegt werden.</li>
<li><strong>Player-Integration:</strong> Nach Generierung der Karte wird der Spieler-Ball (<code>Player</code>-Prefab) an der Startposition (typischerweise der Mittelpunkt der eingegebenen Adresse oder ein definierter Spawnpunkt) platziert. Sollte bereits ein Player in der Szene vorhanden sein, wird dieser ggf. repositioniert. ZusÃ¤tzlich wird ein <strong>GoalZone</strong>-Prefab in angemessener Entfernung oder an einem markanten Ort platziert, um ein Ziel fÃ¼r den Spieler zu definieren.</li>
<li><strong>Performance optimieren:</strong> Da potenziell viele Objekte generiert werden, achtet der Agent auf Performance-Optimierungen: Generierung findet in <strong>Koroutinen</strong> oder Ã¼ber mehrere Frames verteilt statt, um Frame-Drops zu vermeiden. AuÃŸerdem wird <strong>GPU Instancing</strong> oder Batching aktiviert, wo immer mÃ¶glich (z.â€¯B. fÃ¼r viele StraÃŸen-Segmente oder GebÃ¤ude-WÃ¤nde, die alle dasselbe Material nutzen).</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-scene-setup--ui-integration">3. Scene Setup &amp; UI-Integration<a href="#3-scene-setup--ui-integration" class="hash-link" aria-label="Direkter Link zur 3. Scene Setup &amp; UI-Integration" title="Direkter Link zur 3. Scene Setup &amp; UI-Integration">â€‹</a></h4>
<ul>
<li><strong>Level_OSM Scene vervollstÃ¤ndigen:</strong> Der Agent prÃ¼ft, ob die Szene <em>Level_OSM</em> bereits alle nÃ¶tigen Grund-Objekte enthÃ¤lt. Falls nicht, werden diese hinzugefÃ¼gt: z.â€¯B. ein <strong>Canvas</strong> mit einem Panel fÃ¼r die Adresseingabe, ein <strong>InputField</strong> (fÃ¼r Adresse), ein <strong>Button</strong> (&quot;Karte laden&quot;), eine Text-Anzeige fÃ¼r Ladefortschritt, etc. Ein EventSystem wird ebenfalls sichergestellt.</li>
<li><strong>UI-VerknÃ¼pfung:</strong> Ein Skript <code>MapStartupController</code> wird entwickelt oder konfiguriert, das die BrÃ¼cke zwischen UI und Backend schlÃ¤gt. Dieses Skript registriert z.â€¯B. den Button-Klick (&quot;Karte laden&quot;), sammelt die Adresse aus dem InputField und ruft den <code>AddressResolver</code> auf. Ebenso verwaltet es die UI-Anzeigen (Progress-Bar, Fehlermeldungen), wÃ¤hrend die Karte generiert wird. Alle UI-Elemente werden korrekt im Canvas verankert, damit sie auf unterschiedlichen AuflÃ¶sungen sichtbar bleiben.</li>
<li><strong>Event-Verkettung:</strong> Die einzelnen Komponenten werden verbunden: <em>AddressResolver</em> informiert <em>MapGenerator</em>, wenn die Daten bereit sind; <em>MapGenerator</em> informiert <em>MapStartupController</em>, wenn die Welt aufgebaut ist. Ebenso wird das GameManager/LevelManager-System benachrichtigt, dass ein neues Level gestartet wurde, damit bestehende Systeme (z.â€¯B. Zeitnahme, Punkte) weiter funktionieren.</li>
<li><strong>Build-Settings aktualisieren:</strong> Die Szene <em>Level_OSM</em> wird den <strong>Build Settings</strong> des Unity-Projekts hinzugefÃ¼gt, damit sie auch in gebauten Versionen des Spiels enthalten ist. Der Agent prÃ¼ft auÃŸerdem, ob fÃ¼r plattformspezifische Einstellungen etwas angepasst werden muss (z.â€¯B. Internetzugriff fÃ¼r Android erlauben).</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-testing--fallbacks">4. Testing &amp; Fallbacks<a href="#4-testing--fallbacks" class="hash-link" aria-label="Direkter Link zur 4. Testing &amp; Fallbacks" title="Direkter Link zur 4. Testing &amp; Fallbacks">â€‹</a></h4>
<ul>
<li>
<p><strong>Funktionstest mit Beispieldaten:</strong> Der Agent fÃ¼hrt die Szene im Play-Modus aus (ggf. via Simulation) und testet mit mehreren Beispieladressen:</p>
<ul>
<li><em>&quot;Leipzig, Augustusplatz&quot;</em>: Erwartet wird das Laden einer Stadtumgebung mit StraÃŸen und GebÃ¤uden im Zentrum von Leipzig.</li>
<li><em>UngÃ¼ltige Adresse</em> (z.â€¯B. &quot;asdlfkj&quot;): Es sollte eine Fehlermeldung erscheinen und ggf. das <strong>Fallback-System</strong> greifen.</li>
</ul>
</li>
<li>
<p><strong>Fallback-System:</strong> Bei jeglichen Fehlern im Ablauf (kein Internet, API antwortet nicht, Parsing-Fehler) stellt der Agent sicher, dass ein Fallback greift. StandardmÃ¤ÃŸig wird eine vordefinierte Stadt (z.â€¯B. Leipzig Markt) verwendet. D.â€¯h. der Agent prÃ¼ft, ob <code>enableFallbackMode</code> in <em>MapStartupController</em> aktiviert ist und die Fallback-Koordinaten hinterlegt sind. Bei einem erzwungenen Fallback-Durchlauf wird kontrolliert, dass zumindest eine kleine Dummy-Stadt generiert wird, damit der Spieler weiterspielen kann.</p>
</li>
<li>
<p><strong>Leistungstest:</strong> Nach erfolgreicher Generierung beobachtet der Agent die Framerate im Editor. Das Ziel ist, dass auch komplexere Stadt-Ausschnitte das Spiel nicht unspielbar machen. Falls nÃ¶tig, macht der Agent VorschlÃ¤ge, wie die Performance weiter verbessert werden kÃ¶nnte (z.â€¯B. weniger Details generieren, Simplify Meshes, kleinere Umkreissuche fÃ¼r OSM-Daten).</p>
</li>
<li>
<p><strong>Speicherbereinigung:</strong> Der Agent prÃ¼ft, dass nach Verlassen der Szene oder beim Neustart generierte Objekte aufgerÃ¤umt werden (z.â€¯B. beim Laden einer neuen Adresse alte GameObjects lÃ¶schen), um Speicherlecks zu vermeiden.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-optional-erweiterte-features">5. Optional: Erweiterte Features<a href="#5-optional-erweiterte-features" class="hash-link" aria-label="Direkter Link zur 5. Optional: Erweiterte Features" title="Direkter Link zur 5. Optional: Erweiterte Features">â€‹</a></h4>
<ul>
<li><strong>Street View Integration:</strong> Als Ausbaustufe kann der Agent einen Ausblick auf Street-View-Integration geben. Z.â€¯B. kÃ¶nnte er vorschlagen, fÃ¼r markante Punkte Panorama-Texturen zu laden oder ein kleines Vorschaubild aus Google Street View API einzublenden, um die Immersion zu erhÃ¶hen. (Diese Schritte werden nur als Idee dokumentiert, nicht automatisch implementiert.)</li>
<li><strong>GPS &amp; Standort</strong>: Perspektivisch kÃ¶nnte ein <strong>GPS-Feature</strong> integriert werden, mit dem der Spieler anstelle einer Adresse seinen aktuellen Standort laden kann. Der Agent vermerkt, welche Schnittstellen dafÃ¼r vorbereitet werden mÃ¼ssten (z.â€¯B. Unity LocationService fÃ¼r mobile Plattformen).</li>
<li><strong>Offline-Modus:</strong> Optional wird festgehalten, wie ein Offline-Spielmodus aussehen kÃ¶nnte (z.â€¯B. Nutzung zuvor geladener Kartendaten oder eines begrenzten lokalen Kartenabschnitts), falls Internet nicht verfÃ¼gbar ist.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-erfolgsbedingungen-1">âœ… Erfolgsbedingungen<a href="#-erfolgsbedingungen-1" class="hash-link" aria-label="Direkter Link zur âœ… Erfolgsbedingungen" title="Direkter Link zur âœ… Erfolgsbedingungen">â€‹</a></h3>
<p>Die OpenStreetMap-Integration gilt als erfolgreich, wenn:</p>
<ul>
<li><strong>Adresseingabe und Laden</strong> in <em>Level_OSM</em> ohne Entwickler-Eingriff funktionieren: Der Spieler kann eine Adresse eingeben, auf <em>Karte laden</em> klicken und binnen kurzer Zeit erscheint die entsprechende Spielwelt.</li>
<li><strong>OSM-Objekte korrekt generiert</strong> werden: StraÃŸen verlaufen begehbar, GebÃ¤ude stehen an plausiblen Positionen und bilden Hindernisse, Collectibles sind verteilt und erreichbar, ohne in der Luft zu schweben oder unzugÃ¤nglich zu sein.</li>
<li>Der <strong>Steampunk-Stil</strong> bleibt konsistent: Alle generierten Objekte verwenden die vorgesehenen Materialien, Prefabs und Effekte (z.â€¯B. Dampfeffekte in StraÃŸen oder an GebÃ¤uden, falls vorgesehen), sodass kein Bruch im visuellen Design entsteht.</li>
<li><strong>Performance</strong>: Die generierte Szene lÃ¤uft mit ausreichender Bildrate (idealerweise &gt;30 FPS auf durchschnittlicher Hardware). GrÃ¶ÃŸere Kartenabschnitte dÃ¼rfen die Engine nicht einfrieren; die Ladezeit ist angemessen (ein paar Sekunden, aber keine Minuten).</li>
<li><strong>StabilitÃ¤t</strong>: Fallbacks greifen bei Fehlern. D.â€¯h. keine AbstÃ¼rze oder Endlos-Schleifen bei Netzwerkausfall oder ungÃ¼ltigen Eingaben. Wenn APIs ausfallen, wird automatisch die Standardstadt geladen und das Spiel bleibt spielbar.</li>
<li><strong>Keine Regressionen</strong>: Die Integration darf bestehende Spielmechaniken nicht brechen. Insbesondere mÃ¼ssen Kamerasteuerung, Playercontroller, UI-Anzeigen (Punktestand, Timer) weiterhin funktionieren, auch wenn die Level-Geometrie nun dynamisch erstellt wird.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenlogik-1">ğŸ§  Agentenlogik<a href="#-agentenlogik-1" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenlogik" title="Direkter Link zur ğŸ§  Agentenlogik">â€‹</a></h3>
<p>Der <strong>OSMIntegrationAgent</strong> greift ebenfalls auf <em>OpenAI Codex</em> Ã¼ber Unity MCP zurÃ¼ck, mit Spezialisierungen fÃ¼r Web- und Datenoperationen:</p>
<ul>
<li><strong>HTTP-Anfragen</strong>: Der Agent kann Unity-intern Networking-Funktionen nutzen (z.â€¯B. <code>UnityWebRequest</code>) um API-Aufrufe an Nominatim und Overpass durch den Editor zu simulieren. (Hinweis: Im Editor kann dies mit Coroutine/EditorCoroutine geschehen, da echte HTTP-Aufrufe auÃŸerhalb des Spielmodus erfolgen mÃ¼ssen.)</li>
<li><strong>Datenparsing</strong>: Mithilfe von Codex generiert der Agent Parser fÃ¼r das JSON/XML der API-Antworten (beispielsweise mit Newtonsoft Json oder SimpleJSON).</li>
<li><strong>Scene Manipulation</strong>: Der Agent verwendet Unity APIs, um Objekte zu erzeugen (<code>GameObject.Instantiate</code> fÃ¼r Prefabs) und transformieren. Er kann komplexe Berechnungen (z.â€¯B. Geodaten in Unity-Koordinaten umrechnen) durchfÃ¼hren und direkt im Editor testen.</li>
<li><strong>Editor-Scripting</strong>: Da Setup-Schritte oft Editor-Arbeit erfordern (z.â€¯B. HinzufÃ¼gen der Scene zu Build Settings, Erstellen von Menu-Items), nutzt der Agent die Unity Editor Scripting API. Beispielsweise kann er ein EditorWindow erstellen (<code>OSMEditorExtension</code>), um manuelle Eingriffe zu erleichtern, oder MenÃ¼punkte wie <em>Roll-a-Ball â†’ OSM â†’ Setup OSM Scene</em> programmatisch hinzufÃ¼gen.</li>
<li><strong>Fehleranalyse</strong>: Falls wÃ¤hrend der Implementierung Fehler auftreten (Exceptions, NullRefs), erkennt der Agent diese via Konsole und passt den Code entsprechend an (z.â€¯B. fÃ¼gt <code>if</code>-Checks ein, erhÃ¶ht Timeouts, etc.).</li>
</ul>
<p><strong>Hinweis:</strong> Die OSM-Integration erfordert potenziell Internetzugriff. Falls die AusfÃ¼hrung in einer isolierten Umgebung erfolgt, generiert der Agent Beispiel-Datenstrukturen, um die Logik dennoch testen zu kÃ¶nnen. AbschlieÃŸend aktualisiert der Agent die Projektdokumentation (z.â€¯B. erstellt/aktualisiert <code>OSM_INTEGRATION_USER_GUIDE.md</code> und einen technischen Report <em>PHASE_4_COMPLETE_SUMMARY.md</em>) und markiert Phase 4 im <code>README.md</code> als abgeschlossen.</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenauftrag-multiplayer-kompatibilitÃ¤t-phase-5">ğŸ¯ Agentenauftrag: Multiplayer-KompatibilitÃ¤t (Phase 5)<a href="#-agentenauftrag-multiplayer-kompatibilitÃ¤t-phase-5" class="hash-link" aria-label="Direkter Link zur ğŸ¯ Agentenauftrag: Multiplayer-KompatibilitÃ¤t (Phase 5)" title="Direkter Link zur ğŸ¯ Agentenauftrag: Multiplayer-KompatibilitÃ¤t (Phase 5)">â€‹</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenname-2">ğŸ§  Agentenname<a href="#-agentenname-2" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenname" title="Direkter Link zur ğŸ§  Agentenname">â€‹</a></h3>
<p><code>MultiplayerAgent</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ï¸-projektverzeichnis-2">ğŸ—‚ï¸ Projektverzeichnis<a href="#ï¸-projektverzeichnis-2" class="hash-link" aria-label="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis" title="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis">â€‹</a></h3>
<p><code>/home/saschi/Games/Roll-a-Ball/</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-ziel-2">ğŸ” Ziel<a href="#-ziel-2" class="hash-link" aria-label="Direkter Link zur ğŸ” Ziel" title="Direkter Link zur ğŸ” Ziel">â€‹</a></h3>
<p>Das Spiel soll <strong>Multiplayer-fÃ¤hig</strong> werden, sodass mehrere Spieler gleichzeitig in den Roll-a-Ball Levels spielen kÃ¶nnen. Geplant ist zunÃ¤chst ein <strong>kooperativer Modus</strong> (z.â€¯B. gemeinsames Einsammeln von Collectibles) und perspektivisch auch kompetitive Elemente (Wettlauf um Punkte oder Zeit). Der Agent bereitet das Projekt auf NetzwerkfÃ¤higkeit vor, passt bestehenden Code an fÃ¼r mehrere Spieler und stellt sicher, dass Synchronisation, Spielablauf und UI fÃ¼r alle Beteiligten korrekt funktionieren.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-auftragsschritte-2">ğŸ“Œ Auftragsschritte<a href="#-auftragsschritte-2" class="hash-link" aria-label="Direkter Link zur ğŸ“Œ Auftragsschritte" title="Direkter Link zur ğŸ“Œ Auftragsschritte">â€‹</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-networking-framework-einrichten">1. Networking-Framework einrichten<a href="#1-networking-framework-einrichten" class="hash-link" aria-label="Direkter Link zur 1. Networking-Framework einrichten" title="Direkter Link zur 1. Networking-Framework einrichten">â€‹</a></h4>
<ul>
<li><strong>Netzwerk-API Auswahl:</strong> Der Agent evaluiert verfÃ¼gbare Unity-Multiplayer-Frameworks (z.â€¯B. <strong>Unity Netcode for GameObjects</strong> (NGO) vs. <strong>Mirror</strong> oder Photon). FÃ¼r eine Open-Source-LÃ¶sung bietet sich <em>Mirror</em> an, wÃ¤hrend NGO eine offizielle LÃ¶sung ist. Entscheidungskriterien (Latency, Ease of integration, Doku) werden notiert.</li>
<li><strong>Grundsetup:</strong> Nachdem ein Framework gewÃ¤hlt ist, integriert der Agent dieses ins Projekt (entsprechende Packages importieren, ggf. Project Settings anpassen). Ein zentrales <strong>NetworkManager</strong>-Objekt wird eingerichtet, das die Verbindung zwischen Host und Clients verwaltet. Hier definiert man z.â€¯B. maximale Spieleranzahl, Transport-Protokoll (kann z.â€¯B. UNet Transport oder KCP fÃ¼r Mirror sein) und grundlegende Callbacks (OnServerConnect, OnClientDisconnect etc.).</li>
<li><strong>Lobby/Testumgebung:</strong> Optional erstellt der Agent eine einfache Lobby-Szene oder benutzt <em>GeneratedLevel.unity</em> als Test, in der per Tastendruck entweder ein Host gestartet oder ein Client dem Spiel beitritt. Dies dient zum schnellen Testen der Verbindung, bevor Gameplay synchronisiert wird.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-spielobjekte-fÃ¼r-networking-vorbereiten">2. Spielobjekte fÃ¼r Networking vorbereiten<a href="#2-spielobjekte-fÃ¼r-networking-vorbereiten" class="hash-link" aria-label="Direkter Link zur 2. Spielobjekte fÃ¼r Networking vorbereiten" title="Direkter Link zur 2. Spielobjekte fÃ¼r Networking vorbereiten">â€‹</a></h4>
<ul>
<li><strong>Player-Prefab networkfÃ¤hig machen:</strong> Der existierende Spieler-Ball (<code>Player</code> GameObject/Prefab) wird um Netzwerk-Funktionen erweitert. Je nach Framework wird z.â€¯B. eine <code>NetworkIdentity</code> (Mirror) oder <code>NetworkObject</code> (Unity Netcode) Komponente hinzugefÃ¼gt. Der Player-Controller-Code muss so angepasst werden, dass er die Bewegung <strong>nur fÃ¼r den eigenen Spieler</strong> ausfÃ¼hrt und die Position/Rotation Ã¼ber das Netzwerk synchronisiert. (Oft mittels <em>Client Authority</em> oder transform sync Komponente).</li>
<li><strong>Synchronisation der Collectibles:</strong> Alle <strong>Collectible-Objekte</strong> mÃ¼ssen bei allen Spielern konsistent sein. Der Agent Ã¤ndert das Collectible-System dahingehend, dass das Einsammeln eines Objekts vom Server autoritativ gehandhabt wird: Wenn ein Spieler einsammelt, wird das Objekt auf dem Server zerstÃ¶rt und dieser Zustand an alle Clients repliziert. Dies verhindert, dass verschiedene Spieler dasselbe Item mehrfach sehen oder einsammeln kÃ¶nnen.</li>
<li><strong>Goals &amp; Trigger:</strong> Ã„hnlich wie Collectibles mÃ¼ssen Endzonen/Trigger (z.â€¯B. <code>GoalZone</code>) so angepasst werden, dass sie nur einmal feuern und allen Spielern das Levelende signalisieren. Der Agent implementiert, dass beim Erreichen der GoalZone durch einen beliebigen Spieler ein Event an alle gesendet wird (z.â€¯B. <em>LevelComplete</em>), woraufhin die Runde fÃ¼r alle endet.</li>
<li><strong>Multiplayer-taugliche Camera:</strong> Die Kamera-Verfolgung muss pro Spieler-Instanz getrennt funktionieren. Im einfachsten Fall wird fÃ¼r jeden Client die lokale Kamera verwendet, die dem eigenen Player folgt. Der Agent stellt sicher, dass die Kamera nicht versucht, mehreren Spielern gleichzeitig zu folgen. Gegebenenfalls spawnt der NetworkManager pro Client eine eigene Kamera oder der Player spawnt mit einer Kamera als Kindobjekt.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-ui--spiellogik-anpassen">3. UI &amp; Spiellogik anpassen<a href="#3-ui--spiellogik-anpassen" class="hash-link" aria-label="Direkter Link zur 3. UI &amp; Spiellogik anpassen" title="Direkter Link zur 3. UI &amp; Spiellogik anpassen">â€‹</a></h4>
<ul>
<li><strong>UI fÃ¼r mehrere Spieler:</strong> Der Agent passt die UI-Elemente wie Punktestand und Collectible-ZÃ¤hler an, sodass sie pro Spieler oder fÃ¼r das gesamte Team funktionieren. Beispielsweise kÃ¶nnte bei kooperativem Modus allen Spielern ein gemeinsamer Collectible-ZÃ¤hler (X/Y gefunden) angezeigt werden, der synchron aktualisiert wird. In kompetitiven Modi brÃ¤uchte jeder Spieler eine eigene Anzeige seines Scores â€“ hierfÃ¼r kann der Agent das HUD duplizieren und an verschiedene Ecken des Bildschirms platzieren oder ein Tabellensystem einfÃ¼hren.</li>
<li><strong>Respawn/Restart-Mechanik:</strong> In Multiplayer mÃ¼ssen AblÃ¤ufe wie &quot;Neustart&quot; oder &quot;Level neu generieren (R-Taste)&quot; koordiniert ablaufen. Der Agent implementiert, dass ein Level-Reset vom Server initiiert wird und an alle Clients gesendet. So wird verhindert, dass nur der lokale Client neu lÃ¤dt. Ã„hnlich wird bei einem Spielende (alle Collectibles gesammelt oder Zeit abgelaufen) eine Synchronisation eingefÃ¼hrt, damit alle Spieler gleichzeitig ins nÃ¤chste Level wechseln oder zurÃ¼ck zur Lobby gehen.</li>
<li><strong>Kooperations-Logik:</strong> Falls Koop-Modus, stellt der Agent sicher, dass <strong>Team-Ziele</strong> korrekt berechnet werden (z.â€¯B. Level geschafft, wenn <em>gesamt</em> alle Collectibles gesammelt sind). Falls kompetitiv, muss die Spielwertung getrennt gefÃ¼hrt werden. Der Code im GameManager/LevelManager wird dahingehend erweitert, mehrere Spielerobjekte zu verwalten (evtl. Liste von Spielern statt single Player reference) und SpielzustÃ¤nde pro Spieler (z.â€¯B. wer hat wie viele Collectibles) oder global zu unterscheiden.</li>
<li><strong>Synchronisations-Test:</strong> Der Agent fÃ¼gt temporÃ¤r Debug-UI oder Logs ein, um zu prÃ¼fen, ob wichtige ZustÃ¤nde synchron sind (z.â€¯B. eine kleine Konsole, die anzeigt, wie viele Spieler verbunden, wie viele Collectibles aus Sicht jedes Clients verbleiben). Diese Hilfen ermÃ¶glichen es, Desynchronisationen frÃ¼h zu erkennen.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-multiplayer-test--feinschliff">4. Multiplayer-Test &amp; Feinschliff<a href="#4-multiplayer-test--feinschliff" class="hash-link" aria-label="Direkter Link zur 4. Multiplayer-Test &amp; Feinschliff" title="Direkter Link zur 4. Multiplayer-Test &amp; Feinschliff">â€‹</a></h4>
<ul>
<li><strong>Lokaler Mehrspieler-Test:</strong> Der Agent startet das Spiel in zwei Instanzen (im Editor als Host und in einem Build als Client, oder zwei Builds) auf dem gleichen Rechner, um den Multiplayer zu prÃ¼fen. Szenarien: Beide Spieler bewegen ihren Ball, sammeln Objekte, erreichen die Ziellinie. Es wird beobachtet, ob alle Ereignisse korrekt bei beiden ankommen. Insbesondere Latenz/Synchronisations-Verhalten (Teleportierender Ball? Rubberbanding?) wird begutachtet. Bei Bedarf schlÃ¤gt der Agent Verbesserungen vor, z.â€¯B. <strong>Interpolation</strong> oder <strong>Prediction</strong> fÃ¼r flÃ¼ssigere Bewegung der Fremd-Players.</li>
<li><strong>Edge-Case Tests:</strong> Spieler verlassen das Spiel vorzeitig (Verbindungstrennung) â€“ der Agent prÃ¼ft, dass der Spielzustand damit umgehen kann (z.â€¯B. verbleibende Spieler kÃ¶nnen weiter spielen, das Objekt des getrennten Spielers wird entfernt). Ebenso wird ein neuer Client mitten im Spiel getestet, falls unterstÃ¼tzt (Late Joiner synchronisiert aktuellen Spielstand korrekt).</li>
<li><strong>Performance &amp; Bandbreite:</strong> Der Agent analysiert, ob die Netzwerklast im Rahmen bleibt. Falls z.â€¯B. zu viele Objekte zu hÃ¤ufig Updates senden, empfiehlt er Optimierungen (z.â€¯B. Sync seltener, relevancy checks â€“ nur nahe Objekte updaten). Auch wird geschaut, dass keine groÃŸen Garbage-Spikes durch Netzwerk erzeugt werden (z.â€¯B. durch exzessive Allocations in Update).</li>
<li><strong>Dokumentation &amp; KompatibilitÃ¤t:</strong> AbschlieÃŸend erstellt der Agent einen Report <code>MultiplayerIntegrationReport.md</code>, der zusammenfasst, welche Ã„nderungen vorgenommen wurden, welche EinschrÃ¤nkungen bestehen (z.â€¯B. <em>&quot;Maximal 4 Spieler getestet&quot;</em>, <em>&quot;Physics derzeit nicht deterministisch synchron â€“ kann zu Abweichungen fÃ¼hren&quot;</em>) und welche Schritte fÃ¼r voll robuste Multiplayer-UnterstÃ¼tzung noch empfohlen werden. AuÃŸerdem werden im Projekt-README neue Features (Multiplayer Koop/Competitive) vermerkt, und die <strong>Roadmap Phase 5</strong> kann entsprechend als begonnen/teilerfÃ¼llt markiert werden.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-optional-erweiterte-mehrspieler-features">5. Optional: Erweiterte Mehrspieler-Features<a href="#5-optional-erweiterte-mehrspieler-features" class="hash-link" aria-label="Direkter Link zur 5. Optional: Erweiterte Mehrspieler-Features" title="Direkter Link zur 5. Optional: Erweiterte Mehrspieler-Features">â€‹</a></h4>
<ul>
<li><strong>Globale Ranglisten:</strong> Als Ausblick kann der Agent schon die Integration eines Leaderboard-Services vorschlagen. Z.â€¯B. Nutzung einer einfachen Web-API, an die Scores gemeldet werden. Dieses Feature wird noch nicht implementiert, aber in der Dokumentation als nÃ¤chster Meilenstein notiert.</li>
<li><strong>TÃ¤gliche Herausforderungen:</strong> Der Agent skizziert, wie tÃ¤gliche Herausforderungen im Multiplayer aussehen kÃ¶nnten (z.â€¯B. tÃ¤glich generierter Level-Seed, Koop-Zeitangriff fÃ¼r alle Spieler mit Ranking). Solche Ideen werden gesammelt, um die Weiterentwicklung zu steuern.</li>
<li><strong>Plattform-Ãœbergreifend &amp; VR:</strong> Falls relevant, erwÃ¤hnt der Agent, ob das Multiplayer-System auch fÃ¼r zukÃ¼nftige VR-UnterstÃ¼tzung oder Cross-Platform (PC/Mobile) verwendbar ist oder welche Anpassungen nÃ¶tig wÃ¤ren (z.â€¯B. andere Steuerung, Networking in VR Kontext mit Motion-Sickness-Vermeidung bei Zuschauer-Modus etc.).</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-erfolgsbedingungen-2">âœ… Erfolgsbedingungen<a href="#-erfolgsbedingungen-2" class="hash-link" aria-label="Direkter Link zur âœ… Erfolgsbedingungen" title="Direkter Link zur âœ… Erfolgsbedingungen">â€‹</a></h3>
<p>Die Multiplayer-Vorbereitung ist erfolgreich, wenn:</p>
<ul>
<li><strong>Mehrere Spieler</strong> gleichzeitig im selben Spiellevel interagieren kÃ¶nnen, ohne Fehler. Beispielsweise kÃ¶nnen zwei Spieler in Level1 gemeinsam alle Collectibles sammeln und das Level beenden, wobei beide Clients synchron den Abschluss registrieren.</li>
<li><strong>Spielzustand SynchronitÃ¤t:</strong> Wichtige SpielzustÃ¤nde (Positionen der Spieler, verbleibende Collectibles, Punkte) sind bei allen Teilnehmern konsistent. Es treten keine duplizierten Objekte, &quot;Geister-Collectibles&quot; oder widersprÃ¼chlichen Anzeigen auf.</li>
<li><strong>StabilitÃ¤t im Netzwerk:</strong> Ein Verbindungsaufbau ist mÃ¶glich (Spieler kÃ¶nnen hosten/joinen), und das Spiel lÃ¤uft Ã¼ber ein paar Minuten ohne Verbindungsabbruch oder mit sauberem Handling, falls doch jemand trennt. Es gibt keine massiven Lags oder unkontrollierte Physik-Effekte durch die Netzwerklatenz.</li>
<li><strong>Bestehender Singleplayer unverÃ¤ndert:</strong> Wichtig ist, dass der normale Einzelspielermodus weiterhin einwandfrei funktioniert, falls man solo spielt. Die Multiplayer-Erweiterungen dÃ¼rfen das Singleplayer-Erlebnis nicht beeintrÃ¤chtigen (z.â€¯B. sollte im Einzelspielermodus kein NetworkManager stÃ¶ren oder Fehler werfen).</li>
<li><strong>Skalierbarkeit:</strong> Das System ist so ausgelegt, dass auch mehr als 2 Spieler unterstÃ¼tzt werden kÃ¶nnten (mindestens 4 Spieler in Tests erfolgreich). Zudem sollte es mÃ¶glich sein, weitere Multiplayer-Features (Chat, Team-Mechaniken) relativ einfach zu integrieren, ohne das GrundgerÃ¼st neu zu erfinden.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenlogik-2">ğŸ§  Agentenlogik<a href="#-agentenlogik-2" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenlogik" title="Direkter Link zur ğŸ§  Agentenlogik">â€‹</a></h3>
<p>Der <strong>MultiplayerAgent</strong> nutzt OpenAI Codex, um komplexe <strong>Netzwerk-Programmieraufgaben</strong> zu bewÃ¤ltigen:</p>
<ul>
<li><strong>Framework-Kenntnis</strong>: Codex wird mit Dokumentation oder gÃ¤ngigen Mustern des gewÃ¤hlten Netzwerksystems angeleitet, um korrekt z.â€¯B. <code>NetworkBehaviour</code>-Klassen, RPCs oder Synchronisierungs-Attributes zu schreiben.</li>
<li><strong>Code-Refactor</strong>: Viele bestehende Klassen mÃ¼ssen angepasst werden. Der Agent durchforstet die Codebasis und findet Stellen, die aktuell von einem einzelnen Spieler ausgehen (z.â€¯B. Referenzen auf &quot;Player&quot; Objekt). Codex hilft dabei, diese so zu generalisieren, dass sie mit einer dynamischen Liste von Spielern umgehen kÃ¶nnen.</li>
<li><strong>Merge &amp; KonfliktlÃ¶sung</strong>: Sollte das Projekt bereits fortgeschritten sein, kann das EinfÃ¼gen von Networking-Code Konflikte mit bisherigen Systemen auslÃ¶sen. Der Agent nutzt Codexâ€™ KontextverstÃ¤ndnis, um LÃ¶sungen zu finden (z.â€¯B. Bedingungen einzubauen &quot;if (IsClient) return;&quot; fÃ¼r Logik, die nur am Server laufen soll, etc.).</li>
<li><strong>Testing Automation</strong>: Der Agent kann kleine Testskripte generieren, die im Editor automatisiert zwei Players simulieren (z.â€¯B. zwei Editor PlayModes via Multi-Instance starten, falls unterstÃ¼tzt). Dies ermÃ¶glicht es, wiederholt die GrundfunktionalitÃ¤t zu prÃ¼fen.</li>
<li><strong>KI-UnterstÃ¼tzte Fehlersuche</strong>: Sollten Bugs auftreten (typische Netzwerkrace-Conditions, null references auf Clients, etc.), nutzt der Agent die KI, um die Ursachen im Code zu finden und zu beheben. MÃ¶gliche LÃ¶sungen zieht er aus bekannten Patterns (z.â€¯B. WaitForNetworkObjectSpawn, Scenes als Server synchron laden, etc.).</li>
</ul>
<p>Nachdem der Agent die Multiplayer-Integration fertiggestellt hat, aktualisiert er die Projektdokumentation. Die <strong>README.md</strong> erhÃ¤lt einen Abschnitt Ã¼ber Multiplayer, und die <em>Roadmap</em> Phase 5 Punkte (zumindest &quot;Multiplayer-UnterstÃ¼tzung&quot;) kÃ¶nnen als erledigt markiert werden. Auch der erzeugte <code>MultiplayerIntegrationReport.md</code> wird dem Repository hinzugefÃ¼gt.</p>
<hr>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenauftrag-performance-optimierung--build-automatisierung-phase-6">ğŸ¯ Agentenauftrag: Performance-Optimierung &amp; Build-Automatisierung (Phase 6)<a href="#-agentenauftrag-performance-optimierung--build-automatisierung-phase-6" class="hash-link" aria-label="Direkter Link zur ğŸ¯ Agentenauftrag: Performance-Optimierung &amp; Build-Automatisierung (Phase 6)" title="Direkter Link zur ğŸ¯ Agentenauftrag: Performance-Optimierung &amp; Build-Automatisierung (Phase 6)">â€‹</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenname-3">ğŸ§  Agentenname<a href="#-agentenname-3" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenname" title="Direkter Link zur ğŸ§  Agentenname">â€‹</a></h3>
<p><code>PerformanceBuildAgent</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="ï¸-projektverzeichnis-3">ğŸ—‚ï¸ Projektverzeichnis<a href="#ï¸-projektverzeichnis-3" class="hash-link" aria-label="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis" title="Direkter Link zur ğŸ—‚ï¸ Projektverzeichnis">â€‹</a></h3>
<p><code>/home/saschi/Games/Roll-a-Ball/</code></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-ziel-3">ğŸ” Ziel<a href="#-ziel-3" class="hash-link" aria-label="Direkter Link zur ğŸ” Ziel" title="Direkter Link zur ğŸ” Ziel">â€‹</a></h3>
<p>In dieser Phase wird das Spiel fÃ¼r den <strong>Release vorbereitet</strong>. Zwei Hauptaspekte stehen im Fokus: zum einen die <strong>Performance-Optimierung</strong> (das Spiel soll flÃ¼ssig auf den Zielplattformen laufen, ohne unnÃ¶tige Ressourcen zu verbrauchen) und zum anderen die <strong>Build-Automatisierung</strong> (reibungslose Erstellung von Builds fÃ¼r verschiedene Plattformen mit minimalem manuellem Aufwand). Der Agent identifiziert Performance-EngpÃ¤sse im Spiel, verbessert diese und richtet Skripte/Workflows ein, um das Erstellen neuer Builds und Releases effizient zu gestalten.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-auftragsschritte-3">ğŸ“Œ Auftragsschritte<a href="#-auftragsschritte-3" class="hash-link" aria-label="Direkter Link zur ğŸ“Œ Auftragsschritte" title="Direkter Link zur ğŸ“Œ Auftragsschritte">â€‹</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="1-profiling--analyse">1. Profiling &amp; Analyse<a href="#1-profiling--analyse" class="hash-link" aria-label="Direkter Link zur 1. Profiling &amp; Analyse" title="Direkter Link zur 1. Profiling &amp; Analyse">â€‹</a></h4>
<ul>
<li>
<p><strong>Profiler-Durchlauf:</strong> Der Agent fÃ¼hrt das Spiel in verschiedenen Szenarien aus (kleines Level, groÃŸes Level, OSM-Level, Multiplayer) und sammelt Daten mit dem Unity Profiler. CPU-Auslastung pro Frame, Garbage Collection Spikes, Render-Stallings und GPU-Auslastung werden protokolliert. Insbesondere achtet der Agent auf <strong>kritische EngpÃ¤sse</strong>: z.â€¯B. ob die <strong>Generierungskoroutinen</strong> groÃŸe Last erzeugen, ob die <strong>Physikberechnungen</strong> (fÃ¼r rollende BÃ¤lle, Kollisionen) viel Zeit benÃ¶tigen oder ob die <strong>Rendering</strong>-Last (Partikeleffekte, Beleuchtung) hoch ist.</p>
</li>
<li>
<p><strong>Bottlenecks identifizieren:</strong> Anhand der Profiler-Daten erstellt der Agent eine Liste der grÃ¶ÃŸten ÃœbeltÃ¤ter. Beispielsweise kÃ¶nnte herauskommen:</p>
<ul>
<li>Hohe CPU-Last durch hÃ¤ufige <strong>Garbage Collection</strong> (viele temporÃ¤re Allokierungen pro Frame).</li>
<li>Frame-Drops beim Laden neuer Level (vielleicht ungÃ¼nstiges Timing in der LevelGenerator-Koroutine).</li>
<li>Partikelsysteme mit zu vielen Partikeln gleichzeitig.</li>
<li>UnnÃ¶tig hohe <strong>Draw-Call</strong>-Zahlen (zu viele einzelne Objekte ohne Batching).</li>
</ul>
</li>
<li>
<p><strong>Diagnose-Report:</strong> Diese Befunde werden in einem kurzen <code>PerformanceReport.md</code> zusammengefasst, priorisiert nach Impact auf FPS.</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="2-code--und-szenenoptimierung">2. Code- und Szenenoptimierung<a href="#2-code--und-szenenoptimierung" class="hash-link" aria-label="Direkter Link zur 2. Code- und Szenenoptimierung" title="Direkter Link zur 2. Code- und Szenenoptimierung">â€‹</a></h4>
<ul>
<li><strong>Skript-Optimierungen:</strong> Auf Basis der Analyse optimiert der Agent kritische Code-Stellen. Beispielsweise werden temporÃ¤re List-Allocations in der Update-Schleife vermieden, indem Lists vorab erstellt und wiederverwendet werden. Koroutinen werden geprÃ¼ft, ob sie vielleicht zu groÃŸe Arbeitspakete pro Frame erledigen â€“ ggf. fÃ¼gt der Agent zusÃ¤tzliche <code>yield</code>-Schritte ein, um die Last zu verteilen. Physik-Abfragen (wie <code>Physics.OverlapSphere</code> fÃ¼r Collectibles) kÃ¶nnten gecacht oder seltener ausgefÃ¼hrt werden.</li>
<li><strong>Object Pooling:</strong> Der Agent implementiert ein <strong>Object Pooling</strong>-System fÃ¼r hÃ¤ufig erstellte/destroyte Objekte (z.â€¯B. Collectibles, Partikelobjekte). Das Ziel ist, teure Instantiierung/Destruction im laufenden Spiel zu reduzieren. Es wird ein Pool angelegt, der z.â€¯B. X Collectible-Objekte vorhÃ¤lt und wiederverwendet, anstatt stÃ¤ndig neue zu erzeugen.</li>
<li><strong>Grafik-Tuning:</strong> Gemeinsam mit den Entwicklern oder anhand der Zielplattformen passt der Agent die <strong>Quality Settings</strong> und Render-Optionen an. Beispielsweise kÃ¶nnte die SchattenqualitÃ¤t reduziert oder ein kÃ¼rzerer Schattenabstand gesetzt werden, wenn das Spiel auf schwÃ¤cheren GerÃ¤ten laufen soll. Auch wird geprÃ¼ft, ob <strong>Occlusion Culling</strong> aktiviert und konfiguriert ist (fÃ¼r die Labyrinth-Levels sinnvoll, damit nicht alle Objekte immer gerendert werden).</li>
<li><strong>Level-of-Detail (LOD):</strong> FÃ¼r 3D-Modelle (falls vorhanden, z.â€¯B. Steampunk-Deko) richtet der Agent LOD-Stufen ein oder nutzt Unitys <strong>LOD Group</strong>-Komponente, um weit entfernte Objekte gÃ¼nstiger zu rendern. Sollte das Projekt wenige komplexe Modelle haben, ist dies ggf. vernachlÃ¤ssigbar.</li>
<li><strong>Mobile Optimierungen:</strong> Falls Android/WebGL Targets geplant sind, sorgt der Agent fÃ¼r plattformspezifische Einstellungen: z.â€¯B. Texturkompression fÃ¼r Mobile, begrenzte framerate oder Abschalten von aufwendigen Post-Processing fÃ¼r WebGL.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="3-automatisierte-build-pipeline-einrichten">3. Automatisierte Build-Pipeline einrichten<a href="#3-automatisierte-build-pipeline-einrichten" class="hash-link" aria-label="Direkter Link zur 3. Automatisierte Build-Pipeline einrichten" title="Direkter Link zur 3. Automatisierte Build-Pipeline einrichten">â€‹</a></h4>
<ul>
<li>
<p><strong>Build-Skripte erstellen:</strong> Der Agent automatisiert den Build-Prozess mittels Unity <strong>Batchmode</strong> oder Editor-Skripten. Beispielsweise wird ein Skript <code>BuildAll.cs</code> oder eine Reihe von Skripten erstellt, die per MenÃ¼ oder CLI alle Zielplattformen bauen. Diese Skripte verwenden die Unity Editor API (<code>BuildPipeline.BuildPlayer</code>) und berÃ¼cksichtigen unterschiedliche Profile:</p>
<ul>
<li><em>Standalone (Windows/macOS/Linux)</em>: Evtl. separate Ordner pro OS, oder zumindest Einstellungen wie x86_64 Architektur.</li>
<li><em>Android</em>: Setzt automatisch den Build auf IL2CPP, ARM64, und signiert ggf. mit einem Keystore (Stub, falls nicht vorhanden).</li>
<li><em>WebGL</em>: Aktiviert Kompression, setzt Memory Size passend, etc.</li>
</ul>
</li>
<li>
<p><strong>One-Click Build:</strong> Im Unity-MenÃ¼ erscheint unter <em>Roll-a-Ball â†’ Build</em> nun Optionen wie <em>Build Standalone</em>, <em>Build Android</em>, <em>Build WebGL</em>. Der Agent stellt sicher, dass vor dem Build alle Szenen in Build Settings eingetragen sind (inkl. neu hinzugekommene <em>Level_OSM</em>, etc.) und dass die Builds in einen definierten Ordnerpfad ausgegeben werden.</p>
</li>
<li>
<p><strong>CI/CD Vorbereitung:</strong> Falls das Projekt auf GitHub oder einem Ã¤hnlichen Repository ist, bereitet der Agent eine einfache Continuous Integration vor. Z.â€¯B. generiert er ein GitHub Actions Workflow YAML, das bei einem Push einen Unity Build Container startet und das Projekt baut (dies erfordert Unity-Lizenz in CI, was evtl. nur skizziert wird). Der Agent dokumentiert die Schritte, die nÃ¶tig wÃ¤ren, um das CI zum Laufen zu bringen (viele Open-Source-Projekte nutzen z.â€¯B. Game.CI images fÃ¼r Unity in GitHub Actions).</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="4-multi-plattform-tests">4. Multi-Plattform Tests<a href="#4-multi-plattform-tests" class="hash-link" aria-label="Direkter Link zur 4. Multi-Plattform Tests" title="Direkter Link zur 4. Multi-Plattform Tests">â€‹</a></h4>
<ul>
<li><strong>Build-Verifizierung:</strong> Der Agent fÃ¼hrt nach jedem erstellten Build einen kurzen Test durch. FÃ¼r Standalone kÃ¶nnte er automatisiert das Spiel starten (im Hintergrund) und prÃ¼fen, ob es abstÃ¼rzt oder bestimmte Logs ausgibt. FÃ¼r Android kann er keinen echten Lauf durchfÃ¼hren, aber er prÃ¼ft die APK-GrÃ¶ÃŸe und ob der Build Ã¼berhaupt erfolgreich ist. WebGL kÃ¶nnte er lokal im Browser Ã¶ffnen (falls automatisierbar) oder zumindest sicherstellen, dass die Build-Dateien erzeugt wurden.</li>
<li><strong>Performance nach Build:</strong> Gerade auf mobilen/WebGL Plattformen testet der Agent die Performance mit den finalen Einstellungen. Er achtet auf Unterschiede zum Editor-Profiling (z.â€¯B. im WebGL-Build kÃ¶nnte die Performance anders ausfallen). Falls schwere Probleme auftauchen (z.â€¯B. WebGL memory issues), nimmt er entsprechende Anpassungen vor (z.â€¯B. mehr Heap oder Asset Stripping).</li>
<li><strong>Fehlerbereinigung:</strong> Sollten Plattform-spezifische Fehler auftreten (z.â€¯B. ein Script benutzt eine API, die in WebGL nicht unterstÃ¼tzt wird), identifiziert der Agent diese via Build-Logs und passt den Code an, um die KompatibilitÃ¤t herzustellen.</li>
<li><strong>Abschlusstests:</strong> Am Ende fÃ¼hrt der Agent eine vollstÃ¤ndige Testrunde der wichtigsten SpielablÃ¤ufe auf jeder Plattform durch (soweit mÃ¶glich). Das heiÃŸt: einmal Level spielen in Standalone PC, auf Android GerÃ¤t (manuell, sofern der Agent Bericht von Testern bekommt), und WebGL im Browser. Dabei wird sichergestellt, dass die Spielerfahrung konsistent und fehlerfrei ist.</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="5-optional-verÃ¶ffentlichungsvorbereitung">5. Optional: VerÃ¶ffentlichungsvorbereitung<a href="#5-optional-verÃ¶ffentlichungsvorbereitung" class="hash-link" aria-label="Direkter Link zur 5. Optional: VerÃ¶ffentlichungsvorbereitung" title="Direkter Link zur 5. Optional: VerÃ¶ffentlichungsvorbereitung">â€‹</a></h4>
<ul>
<li><strong>Release Build optimieren:</strong> Der Agent schlÃ¤gt vor, fÃ¼r einen tatsÃ¤chlichen Release noch Schritte wie <strong>IL2CPP Code-Stripping</strong> zu verfeinern, <strong>Profiler</strong>-Anbindungen zu entfernen, Debug-Logs zu reduzieren, um die Build-GrÃ¶ÃŸe klein und die Performance hoch zu halten.</li>
<li><strong>Installationspakete:</strong> Optional kÃ¶nnen Skripte erweitert werden, um Installationsprogramme oder Archive zu erstellen (z.â€¯B. ZIP der Standalone-Builds, APK Signing, etc.).</li>
<li><strong>Store-Setup:</strong> Der Agent dokumentiert, welche Schritte fÃ¼r eine VerÃ¶ffentlichung nÃ¶tig wÃ¤ren (z.â€¯B. Vorbereitung einer Itch.io Seite, oder Einreichen in Google Play Store), auch wenn diese Aufgaben auÃŸerhalb des direkten Code-Bereichs liegen. Dies dient als Checkliste fÃ¼r die Entwickler.</li>
<li><strong>ZukÃ¼nftige Automatisierung:</strong> Als Ausblick kann der Agent anmerken, wie man die Tests weiter automatisieren kÃ¶nnte (z.â€¯B. Integrationstests oder Verwendung von Unity Test Framework, sodass in CI nicht nur gebaut, sondern auch automatisch bestimmte Gameplay-Tests durchlaufen werden).</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-erfolgsbedingungen-3">âœ… Erfolgsbedingungen<a href="#-erfolgsbedingungen-3" class="hash-link" aria-label="Direkter Link zur âœ… Erfolgsbedingungen" title="Direkter Link zur âœ… Erfolgsbedingungen">â€‹</a></h3>
<p>Die Phase Performance &amp; Build ist erfolgreich, wenn:</p>
<ul>
<li><strong>Bildrate und Speicher</strong>: Das Spiel erreicht die angestrebte <strong>Framerate</strong> (z.â€¯B. 60 FPS auf Desktop, 30+ FPS auf Mobile) in allen regulÃ¤ren Szenen. Speicherverbrauch bleibt im Rahmen und es gibt keine auffÃ¤lligen Memory-Leaks oder Ã¼berlaufenden Garbage Collections im Spielverlauf.</li>
<li><strong>Reibungsloser Ablauf</strong>: LevelÃ¼bergÃ¤nge, insbesondere das prozedurale Generieren (GeneratedLevel, OSM-Level), verursachen keine merklichen Stotterer mehr. Die Spielerfahrung ist glatt und ohne lange Pausen.</li>
<li><strong>Kleine Build-GrÃ¶ÃŸe</strong>: UnnÃ¶tige Dateien sind nicht im Build. Die GesamtgrÃ¶ÃŸe des Builds ist optimiert (z.â€¯B. keine inkludierten Library/-Ordner, keine Ã¼bergroÃŸen ungenutzten Assets). Nach MÃ¶glichkeit bleibt das Projekt (vor allem WebGL) leichtgewichtig.</li>
<li><strong>Build-Prozess vereinfacht</strong>: Ein Entwickler kann mit minimalem Aufwand einen neuen Build fÃ¼r eine Plattform erzeugen, idealerweise durch einen einzelnen Befehl oder Klick. Alle wichtigen Szenen und Assets werden zuverlÃ¤ssig in die Builds einbezogen.</li>
<li><strong>Plattform-KompatibilitÃ¤t</strong>: Die Builds laufen auf den angegebenen Plattformen ohne AbstÃ¼rze. Windows, Linux, macOS sollten gleichermaÃŸen bedient werden. FÃ¼r Android gilt, dass die App auf einem TestgerÃ¤t installiert und gestartet werden kann, fÃ¼r WebGL, dass es in gÃ¤ngigen Browsern lÃ¤dt und spielbar ist.</li>
<li><strong>Automatisierungsgrad</strong>: Bonus-Ziel ist erreicht, wenn ein CI-System den Build automatisiert durchfÃ¼hren kÃ¶nnte (d.â€¯h. Skripte ohne Editor-GUI funktionieren). Auch ohne voll eingerichtetes CI soll zumindest die lokale Automatisierung zuverlÃ¤ssig funktionieren.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="-agentenlogik-3">ğŸ§  Agentenlogik<a href="#-agentenlogik-3" class="hash-link" aria-label="Direkter Link zur ğŸ§  Agentenlogik" title="Direkter Link zur ğŸ§  Agentenlogik">â€‹</a></h3>
<p>Der <strong>PerformanceBuildAgent</strong> kombiniert FÃ¤higkeiten in den Bereichen Profiling, Code-Optimierung und Automatisierung:</p>
<ul>
<li><strong>Profiler API &amp; Analytics</strong>: Der Agent kann via Code auf Unitys Profiler-Daten zugreifen (z.â€¯B. mit Development Build und ProfilerConnection) oder alternativ die Ausgabe des Profilers interpretieren. Gegebenenfalls werden Editor-integrierte Profiler-Markierungen (ProfilerMarkers) in den Code eingefÃ¼gt, um EngpÃ¤sse besser zu erkennen. Die KI hilft dabei, Muster zu erkennen (z.â€¯B. wiederkehrende GC.Alloc in bestimmten Funktionen).</li>
<li><strong>Code-Verbesserung</strong>: Codex kann auf Performance Best Practices zurÃ¼ckgreifen. Es schlÃ¤gt z.â€¯B. vor, teure LINQ-AusdrÃ¼cke durch herkÃ¶mmliche Schleifen zu ersetzen, bestimmte Update()-Aufrufe zu reduzieren (z.â€¯B. durch Zusammenlegen von Tasks, oder Nutzung von Events statt Polling).</li>
<li><strong>Parallelisierung</strong>: Wo angebracht, kann der Agent den Einsatz von Unity Jobs oder Burst vorschlagen (z.â€¯B. fÃ¼r massenhafte Berechnungen in der Generierung). Falls aber das Projekt nicht darauf ausgelegt ist, wird dies nur als Hinweis notiert, nicht zwingend implementiert.</li>
<li><strong>Editor-Scripting fÃ¼r Build</strong>: Der Agent nutzt Codex, um die Unity Editor BuildPipeline korrekt anzusteuern. Dabei achtet er auf hÃ¤ufige Fallen (z.â€¯B. dass Scenes in BuildSettings gesetzt sein mÃ¼ssen, dass Pfade existieren). Er testet die geschriebenen Build-Skripte im Editor und fÃ¤ngt etwaige Exceptions ab (z.â€¯B. fehlende Berechtigung, volles Laufwerk, usw.).</li>
<li><strong>Integrationsskripte</strong>: FÃ¼r CI kann der Agent Templates nutzen (z.â€¯B. eine YAML-Vorlage von Unity CI) und passt Repository-spezifische Parameter an. Er dokumentiert jeden Schritt gut, damit Entwickler Vertrauen in den automatischen Prozess fassen.</li>
<li><strong>Validierungs-Checks</strong>: Der Agent implementiert kleine Checks, die vor einem Build laufen, wie z.â€¯B. sicherzustellen, dass keine Development-Settings aktiv sind (Debug-Modus, Profiler attached) im Release-Build, oder dass die Versionnummer inkrementiert wurde. Diese helfen, menschliche Fehler vor Release zu minimieren.</li>
</ul>
<p>Am Ende dieser Phase sollten alle Kernsysteme stabil und optimiert sein. Der Agent aktualisiert <strong>README.md</strong> (Performance-Metriken, Systemanforderungen) mit den neuesten Messwerten und fÃ¼gt ggf. eine <em>FINAL_SUCCESS_COMPLETE.md</em> Dokumentation hinzu, die den Abschluss des Projekts bestÃ¤tigt (inklusive aller implementierten Features bis Phase 6).</p>
<hr>
<p>ğŸ“Œ <strong>Letzte Aktualisierung:</strong> <code>{{TODAY}}</code></p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/161sam/Roll-a-Ball/edit/main/wiki/docs/development/AGENTS-INDEX.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Diese Seite bearbeiten</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Dokumentation Seiten"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-agentenauftrag-roll-a-ball-scene-normalisierung--ui-korrektur-phase-3" class="table-of-contents__link toc-highlight">ğŸ¯ Agentenauftrag: Roll-a-Ball Scene Normalisierung &amp; UI-Korrektur (Phase 3)</a><ul><li><a href="#-agentenname" class="table-of-contents__link toc-highlight">ğŸ§  Agentenname</a></li><li><a href="#ï¸-projektverzeichnis" class="table-of-contents__link toc-highlight">ğŸ—‚ï¸ Projektverzeichnis</a></li><li><a href="#-ziel" class="table-of-contents__link toc-highlight">ğŸ” Ziel</a></li><li><a href="#-auftragsschritte" class="table-of-contents__link toc-highlight">ğŸ“Œ Auftragsschritte</a></li><li><a href="#-erfolgsbedingungen" class="table-of-contents__link toc-highlight">âœ… Erfolgsbedingungen</a></li><li><a href="#-status-tracking" class="table-of-contents__link toc-highlight">ğŸ§¾ Status-Tracking</a></li><li><a href="#-agentenlogik" class="table-of-contents__link toc-highlight">ğŸ§  Agentenlogik</a></li></ul></li><li><a href="#-agentenauftrag-openstreetmap-integration-phase-4" class="table-of-contents__link toc-highlight">ğŸ¯ Agentenauftrag: OpenStreetMap Integration (Phase 4)</a><ul><li><a href="#-agentenname-1" class="table-of-contents__link toc-highlight">ğŸ§  Agentenname</a></li><li><a href="#ï¸-projektverzeichnis-1" class="table-of-contents__link toc-highlight">ğŸ—‚ï¸ Projektverzeichnis</a></li><li><a href="#-ziel-1" class="table-of-contents__link toc-highlight">ğŸ” Ziel</a></li><li><a href="#-auftragsschritte-1" class="table-of-contents__link toc-highlight">ğŸ“Œ Auftragsschritte</a></li><li><a href="#-erfolgsbedingungen-1" class="table-of-contents__link toc-highlight">âœ… Erfolgsbedingungen</a></li><li><a href="#-agentenlogik-1" class="table-of-contents__link toc-highlight">ğŸ§  Agentenlogik</a></li></ul></li><li><a href="#-agentenauftrag-multiplayer-kompatibilitÃ¤t-phase-5" class="table-of-contents__link toc-highlight">ğŸ¯ Agentenauftrag: Multiplayer-KompatibilitÃ¤t (Phase 5)</a><ul><li><a href="#-agentenname-2" class="table-of-contents__link toc-highlight">ğŸ§  Agentenname</a></li><li><a href="#ï¸-projektverzeichnis-2" class="table-of-contents__link toc-highlight">ğŸ—‚ï¸ Projektverzeichnis</a></li><li><a href="#-ziel-2" class="table-of-contents__link toc-highlight">ğŸ” Ziel</a></li><li><a href="#-auftragsschritte-2" class="table-of-contents__link toc-highlight">ğŸ“Œ Auftragsschritte</a></li><li><a href="#-erfolgsbedingungen-2" class="table-of-contents__link toc-highlight">âœ… Erfolgsbedingungen</a></li><li><a href="#-agentenlogik-2" class="table-of-contents__link toc-highlight">ğŸ§  Agentenlogik</a></li></ul></li><li><a href="#-agentenauftrag-performance-optimierung--build-automatisierung-phase-6" class="table-of-contents__link toc-highlight">ğŸ¯ Agentenauftrag: Performance-Optimierung &amp; Build-Automatisierung (Phase 6)</a><ul><li><a href="#-agentenname-3" class="table-of-contents__link toc-highlight">ğŸ§  Agentenname</a></li><li><a href="#ï¸-projektverzeichnis-3" class="table-of-contents__link toc-highlight">ğŸ—‚ï¸ Projektverzeichnis</a></li><li><a href="#-ziel-3" class="table-of-contents__link toc-highlight">ğŸ” Ziel</a></li><li><a href="#-auftragsschritte-3" class="table-of-contents__link toc-highlight">ğŸ“Œ Auftragsschritte</a></li><li><a href="#-erfolgsbedingungen-3" class="table-of-contents__link toc-highlight">âœ… Erfolgsbedingungen</a></li><li><a href="#-agentenlogik-3" class="table-of-contents__link toc-highlight">ğŸ§  Agentenlogik</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Dokumentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Roll-a-Ball/docs/intro">EntwicklungsÃ¼bersicht</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Ressourcen</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/161sam/Roll-a-Ball" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://unity.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Unity<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Â© 2025 Roll-a-Ball Projekt.</div></div></div></footer></div>
</body>
</html>