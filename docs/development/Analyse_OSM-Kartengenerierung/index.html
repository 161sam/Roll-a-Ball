<!doctype html>
<html lang="de" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-development/Analyse_OSM-Kartengenerierung" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.8.1">
<title data-rh="true">Analyse und Verbesserungsvorschläge für die OSM-Kartengenerierung im Roll-a-Ball-Spiel | Roll-a-Ball</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://161sam.github.io/Roll-a-Ball/img/social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://161sam.github.io/Roll-a-Ball/img/social-card.jpg"><meta data-rh="true" property="og:url" content="https://161sam.github.io/Roll-a-Ball/docs/development/Analyse_OSM-Kartengenerierung"><meta data-rh="true" property="og:locale" content="de"><meta data-rh="true" name="docusaurus_locale" content="de"><meta data-rh="true" name="docsearch:language" content="de"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Analyse und Verbesserungsvorschläge für die OSM-Kartengenerierung im Roll-a-Ball-Spiel | Roll-a-Ball"><meta data-rh="true" name="description" content="Aktueller Stand der Implementierung"><meta data-rh="true" property="og:description" content="Aktueller Stand der Implementierung"><link data-rh="true" rel="icon" href="/Roll-a-Ball/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://161sam.github.io/Roll-a-Ball/docs/development/Analyse_OSM-Kartengenerierung"><link data-rh="true" rel="alternate" href="https://161sam.github.io/Roll-a-Ball/docs/development/Analyse_OSM-Kartengenerierung" hreflang="de"><link data-rh="true" rel="alternate" href="https://161sam.github.io/Roll-a-Ball/docs/development/Analyse_OSM-Kartengenerierung" hreflang="x-default"><link rel="stylesheet" href="/Roll-a-Ball/assets/css/styles.8fefdf5d.css">
<script src="/Roll-a-Ball/assets/js/runtime~main.21754238.js" defer="defer"></script>
<script src="/Roll-a-Ball/assets/js/main.91976851.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg xmlns="http://www.w3.org/2000/svg" style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t="light";var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",e||t),document.documentElement.setAttribute("data-theme-choice",e||t)}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/Roll-a-Ball/img/logo.svg"><div role="region" aria-label="Zum Hauptinhalt springen"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Zum Hauptinhalt springen</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/Roll-a-Ball/"><div class="navbar__logo"><img src="/Roll-a-Ball/img/logo.svg" alt="Roll-a-Ball Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/Roll-a-Ball/img/logo.svg" alt="Roll-a-Ball Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Roll-a-Ball</b></a><a class="navbar__item navbar__link" href="/Roll-a-Ball/docs/intro">Entwicklung</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/161sam/Roll-a-Ball" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Umschalten zwischen dunkler und heller Ansicht (momentan system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Zurück nach oben scrollen" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">Auf dieser Seite</button></div><div class="theme-doc-markdown markdown"><header><h1>Analyse und Verbesserungsvorschläge für die OSM-Kartengenerierung im Roll-a-Ball-Spiel</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="aktueller-stand-der-implementierung">Aktueller Stand der Implementierung<a href="#aktueller-stand-der-implementierung" class="hash-link" aria-label="Direkter Link zur Aktueller Stand der Implementierung" title="Direkter Link zur Aktueller Stand der Implementierung">​</a></h2>
<p>Die Klassen <strong><code>AddressResolver</code></strong> und <strong><code>MapGenerator</code></strong> bilden das Herzstück der geplanten OSM-Integration. Aktuell läuft der Prozess wie folgt ab:</p>
<ul>
<li>
<p><strong>AddressResolver</strong>: Kümmert sich um Geokodierung und Abruf der OSM-Daten. Bei Eingabe einer Adresse wird über Nominatim eine Koordinate ermittelt. Anschließend wird die Overpass-API mit einer Bounding Box (Standard-Radius ~500m) abgefragt. <strong>Wichtig:</strong> Die Antworten der Overpass-API werden derzeit <em>nicht</em> wirklich geparst – stattdessen füllt die Methode <code>ParseOSMResponse</code> das Ergebnis mit Platzhalter-Daten auf. Das heißt, unabhängig vom tatsächlichen Kartenausschnitt erzeugt das Programm momentan beispielhafte Straßen und Gebäude in einem einfachen Gittermuster. Diese Platzhalter dienen offenbar nur als Übergangslösung („In production, use a proper JSON library…“).</p>
</li>
<li>
<p><strong>MapGenerator</strong>: Nimmt die erhaltenen OSM-Daten (derzeit also die Platzhalter-Strukturen) und erzeugt daraus Unity-GameObjects. Hierbei werden Straßen, Gebäude, Flächen (Parks/Wasser) sowie Sammelobjekte (<em>Collectibles</em>) und ein Zielbereich generiert. Allerdings ist die Geometrie stark vereinfacht:</p>
<ul>
<li><em>Straßen:</em> Pro OSM-Weg wird <strong>ein einziges</strong> quaderförmiges Mesh erzeugt, das lediglich vom <strong>ersten bis zum letzten Knotenpunkt</strong> der Straße reicht. Kurven oder mehrere Segmente werden ignoriert – die Straße wird als gerade Linie zwischen Start- und Endpunkt dargestellt.</li>
<li><em>Gebäude:</em> Unabhängig von der tatsächlichen Grundrissform wird jedes Gebäude als <strong>ein Würfel (PrimitiveType.Cube)</strong> mit fester Grundfläche (5×5 Unity-Einheiten) platziert. Die Position ist der Durchschnitt aller Gebäude-Eckpunkte, die Höhe wird aus den OSM-Daten geschätzt (z.B. über <code>building:levels</code> oder Standardwerte). Die tatsächliche Polygonform der Gebäude wird <strong>nicht</strong> abgebildet – Ecken/Umrisse bleiben unberücksichtigt.</li>
<li><em>Flächen:</em> Parks, Gewässer etc. (OSM <strong>Areas</strong>) werden analog als einfacher <strong>Plane</strong> in der Mitte der Punktewolke erzeugt. Der Umriss der Fläche wird also nicht nachgezeichnet; es entsteht lediglich ein kleines flaches Quadrat (Skalierung fest auf <code>Vector3.one * 2f</code>) am Schwerpunkt der Fläche.</li>
<li><em>Zusatz:</em> Sammelobjekte werden pro Gebäude (Standard: 2 Stück) in der Nähe zufällig verteilt und vereinzelt an zufälligen Stellen entlang von Straßen platziert. Ein <strong>Zielbereich</strong> („GoalZone“) wird standardmäßig in die Mitte des größten Gebäudes oder – falls keine Gebäude vorhanden sind – ins Kartenmittel gesetzt. Der Spieler-Spawn erfolgt auf der ersten Straße oder im Kartenmittelpunkt.</li>
</ul>
</li>
</ul>
<p>Diese Architektur trennt die Verantwortlichkeiten sauber: <strong>AddressResolver</strong> lädt die Daten und wandelt Adressen in Koordinaten um, <strong>MapGenerator</strong> übernimmt die Welt-Erstellung und Styling (Steampunk-Materialien, Nebel, Dampf-Effekte etc.). Die Kommunikation läuft über Events (<code>OnMapDataLoaded</code>, <code>OnMapGenerationCompleted</code> usw.), die in einem <strong>MapStartupController</strong> mit der UI verknüpft sind. Über dieses System erhält der Spieler eine Eingabemaske für Adressen, einen <em>„aktueller Standort“</em>-Button (derzeit als Demo fest auf Leipzig gesetzt) und Ladeanzeigen für die Generierung.</p>
<p>Neben dem OSM-Level gibt es <strong>drei statische Tutorial-Level</strong> (Level1–3) mit festem Layout, um den Spieler an Steuerung und Gameplay heranzuführen. In der aktuellen Level-Logik wird nach Level 3 <em>kein</em> weiteres Level geladen – <code>LevelManager.DetermineNextScene</code> gibt nach „Level3“ einen leeren String zurück, was de facto das Spielende bedeutet. Laut Vorgabe soll hier jedoch nahtlos in <strong>prozedural generierte Levels</strong> übergegangen werden: Sobald Level 3 abgeschlossen ist, soll automatisch immer das nächste Level generiert werden (theoretisch endlos). Außerdem gibt es den speziellen <strong>OSM-Spielmodus</strong>, in dem der Nutzer jederzeit ein Level basierend auf einer beliebigen Adresse oder GPS-Position starten kann. Die generierte Karte soll dabei der realen Geografie entsprechen (Straßenverlauf, Gebäudeplatzierung etc.).</p>
<p>Zusammengefasst: Die Grundstruktur für die OSM-Integration ist vorhanden, aber viele Funktionen sind momentan stark vereinfacht oder unvollständig. Im nächsten Abschnitt werden die wichtigsten Baustellen und Probleme aufgezeigt.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="probleme-und-limitierungen-der-aktuellen-lösung">Probleme und Limitierungen der aktuellen Lösung<a href="#probleme-und-limitierungen-der-aktuellen-lösung" class="hash-link" aria-label="Direkter Link zur Probleme und Limitierungen der aktuellen Lösung" title="Direkter Link zur Probleme und Limitierungen der aktuellen Lösung">​</a></h2>
<ol>
<li>
<p><strong>Keine echte Auswertung der OSM-Daten:</strong> Der wohl größte Mangel ist, dass die Overpass-API-Antwort gar nicht geparst wird. Statt die tatsächlichen Straßen, Gebäude etc. aus den JSON-Daten zu lesen, erzeugt <code>ParseOSMResponse</code> immer das gleiche schematische Netz aus ein paar Straßen und Kästchen. Dadurch spiegelt die generierte Karte <strong>nicht die echte OSM-Umgebung</strong> der gewählten Adresse wider. Selbst wenn Overpass valide Daten liefern würde, werden sie ignoriert. Zudem wird so auch nicht erkennbar, ob in der Region eventuell gar keine Daten vorhanden sind – das Spiel würde trotzdem ein fiktives Grid anzeigen (anstatt den Nutzer zu informieren, dass z.B. mitten im Ozean keine Objekte sind).</p>
</li>
<li>
<p><strong>Vereinfachte Geometrie und fehlende Details:</strong> Die derzeit erzeugten Meshes sind nur grobe Platzhalter. Insbesondere:</p>
<ul>
<li><strong>Straßen</strong>: Alle Straßen werden als gerades Rechteck zwischen zwei Punkten dargestellt. Kurven, Kreuzungen oder Straßennetze mit Verzweigungen fehlen komplett. Eine L-förmige Straße würde z.B. diagonal abgeschnitten. Außerdem haben alle Straßen dieselbe Breite (2m) und das gleiche Material – Unterscheidungen nach <em>highway</em>-Typ (z.B. Hauptstraße vs. Fußweg) fehlen.</li>
<li><strong>Gebäude</strong>: Es wird nicht der Grundriss genutzt, sondern pauschal ein 5×5-Quader am Mittelpunkt platziert. Dadurch stehen die Gebäude nicht an ihren tatsächlichen Positionen oder in korrekter Ausdehnung zueinander. Überlappungen mit Straßen sind wahrscheinlich, da die 5x5-Fläche beliebig gewählt ist. Auch die Orientierung der Gebäude (Drehung) wird ignoriert – alle Würfel sind Achsen-parallel ausgerichtet.</li>
<li><strong>Flächen</strong>: Parks, Wälder, Gewässer etc. werden nur als winzige Plane-Fläche in der Mitte approximiert. Die tatsächliche Ausdehnung oder Form der Fläche geht verloren, wodurch z.B. ein langer Flussabschnitt lediglich als kleines blaues Quadrat erscheint.</li>
<li><strong>Visuelle Qualität</strong>: Primitive Basic-Objekte (Unity-Cubes/Planes) ohne Variation wirken sehr steril. Obwohl Steampunk-Materialien vorgesehen sind, nutzen alle Gebäude derzeit dasselbe Material, ebenso die Straßen – individuelle Texturen (z.B. Straßenasphalt vs. Pflaster) je nach Typ fehlen.</li>
</ul>
</li>
<li>
<p><strong>Performance-Potenzial unausgeschöpft:</strong> Für jede Straße und jedes Gebäude wird ein eigenes GameObject mit eigenem Renderer erzeugt. In städtischen Gebieten können 500m Radius aber Dutzende Straßen und Gebäude umfassen. Ohne weitere Optimierung drohen hier sehr viele Draw Calls. Zwar ist im Code eine <strong>Batching-Option</strong> angedeutet (<code>useBatching = true</code>), doch <code>ApplyMeshBatching()</code> ist noch leer bzw. enthält nur einen Debug-Log. Das heißt, <strong>keine echten Zusammenführungen</strong> der Meshes finden statt. Außerdem werden die vorbereiteten Listen <code>roadMeshes</code> und <code>buildingMeshes</code> nie befüllt – das Batchingsystem ist unvollständig.
Weitere Performance-Themen: Die Generierung läuft innerhalb von Coroutinen bereits schrittweise (yield nach X Objekten) – das ist gut gegen Frameeinbrüche. Dennoch könnte bei sehr vielen Objekten oder einem großen Radius auch das Parsen der JSON oder das Instantiieren vieler Primitives zum Engpass werden. Hier ist aber mangels echter Datenverarbeitung noch kein Problem sichtbar.</p>
</li>
<li>
<p><strong>Ungenutzte Prefabs und fehlende Variation:</strong> In <code>MapGenerator</code> sind Prefabs vorgesehen (<code>roadPrefab</code>, <code>buildingPrefab</code>, etc.), um ggf. vordefinierte Modelle zu verwenden. Diese bleiben aber ungenutzt – stattdessen werden immer Unity-Primitives erstellt. Dadurch geht die Möglichkeit verloren, optisch ansprechendere oder komplexere Modelle einzusetzen (z.B. vorgefertigte Deko-Gebäude im Steampunk-Stil). Auch die <strong>Steampunk-Elemente</strong> sind minimal: Ein zufälliger Dampfwolken-Emitter auf manchen Fabrikdächern und eine Änderung des Ambient-Light/Fog. Hier ließe sich thematisch mehr ausschöpfen (Zahnräder, Rohre an Gebäuden, bewegliche Mechaniken etc.), was aber Gameplay-seitig nicht kritisch ist – eher eine optionale Verbesserung für Atmosphäre.</p>
</li>
<li>
<p><strong>Maßstabsberechnung und Genauigkeit:</strong> Die Umrechnung von Geo-Koordinaten in Unity-Koordinaten ist momentan <strong>vereinfacht linear</strong>. Der Code nimmt an, dass 1° geographische Länge ≈ 111.320m (am Äquator) und konvertiert die gewünschten Meter in Grad indem er durch 111320 teilt. Diese Näherung ignoriert, dass die Längengrad-Abstände je nach Breitengrad kleiner werden (cos-Faktor). Für moderate Breiten (z.B. Deutschland ~50°N) ist der Fehler zwar spürbar (~30% zu große Ost-West-Ausdehnung), aber für 500m noch nicht dramatisch. Dennoch: Das generierte Kartenquadrat ist <strong>kein exakter Kreisradius</strong>, sondern ein Rechteck in Grad, das in Nord-Süd-Richtung ~500m, Ost-West etwas mehr abdeckt. Die <strong><code>scaleMultiplier</code></strong> wird dann gesetzt, um die gesamte Bounding Box auf ~1000 Unity-Einheiten zu bringen. Dieses Vorgehen wirkt etwas willkürlich – im Prinzip sollte 1 Unity-Einheit idealerweise <strong>1 Meter</strong> entsprechen, damit z.B. ein 10m breites Gebäude im Spiel ~10 Einheiten misst. Momentan ist der Maßstab davon abhängig, wie groß die Grad-Differenz des Bereichs ist; das kann zu leichten Verzerrungen führen und erschwert es, echte Größen abzuschätzen. Es wurde kein Ausgleich zwischen unterschiedlicher Breite/Höhe der Bounding Box implementiert (es wird einfach die Breite genommen) – d.h. falls die Höhe deutlich abweicht, würde das Kartenquadrat evtl. nicht perfekt quadratisch skaliert.</p>
</li>
<li>
<p><strong>Integration in den Spielablauf:</strong> Der Übergang von den statischen Leveln zu den generierten Leveln ist noch nicht umgesetzt. Nach Abschluss von Level 3 passiert aktuell nichts (Game Over). Zudem scheint der OSM-Modus derzeit getrennt vom <strong>LevelManager</strong> zu laufen:</p>
<ul>
<li>In der OSM-Szene übernimmt <code>MapStartupController</code> die Kontrolle und ruft nach Generierung <code>gameManager.StartGame()</code> auf, jedoch wird der <strong>LevelManager</strong> dort offenbar nicht verwendet. Das hat Implikationen für die Spielziele:</li>
<li>In den statischen Levels verwaltet <code>LevelManager</code> die Anzahl der Collectibles und schließt das Level automatisch ab, wenn alle eingesammelt sind. Im generierten Level werden zwar Collectibles platziert, aber <strong>nicht in den LevelManager eingebunden</strong>. Zwar aktualisiert <code>MapGenerator</code> nach dem Platzieren via <code>LevelManager.UpdateCollectibleCount()</code> die Zähler, jedoch werden die neuen Collectible-Objekte nicht mittels <code>AddCollectible()</code> dem LevelManager bekannt gemacht. Folge: Deren Event <code>OnCollectiblePickedUp</code> wird nicht vom LevelManager abonniert, sodass das Einsammeln keinen Abschluss auslöst. Dadurch besteht die Gefahr, dass ein generiertes Level <strong>nie als „gewonnen“ erkannt</strong> wird, selbst wenn alle Objekte gesammelt wurden – es sei denn, der <strong>GoalZone</strong>-Trigger übernimmt das (unklar, da Code dazu nicht sichtbar ist). Insgesamt ist die <strong>Level-Fortsetzung in generierten Levels unvollständig</strong>. Für das gewünschte Feature „nach Level 3 endlos weiter“ muss diese Lücke geschlossen werden.</li>
<li>Auch das <strong>automatische Starten</strong> eines generierten Levels nach Level 3 fehlt. Im Code gibt es einen Hinweis, dass hier ein „procedural level scene“ vorgesehen war. Derzeit würde Level3-&gt;GameOver gehen, was den Vorgaben widerspricht.</li>
</ul>
</li>
<li>
<p><strong>Benutzerführung und Fehlerszenarien:</strong> Die aktuelle UI für den OSM-Level deckt grundlegende Fälle ab (Adresse leer -&gt; Fehlermeldung „Bitte gültige Adresse eingeben“, AddressResolver-Fehler -&gt; ggf. Fallback-Karte). Dennoch ein paar Punkte:</p>
<ul>
<li><strong>GPS-Nutzung:</strong> Der „aktueller Standort“-Button ist im Code nur ein Platzhalter, der fix auf Leipzig gestellt ist. Eine echte GPS-Abfrage (Unity LocationService) mit Berechtigungsprüfung fehlt noch komplett.</li>
<li><strong>Fallback-Handling:</strong> Ist <code>enableFallbackMode</code> aktiv, lädt das Spiel bei Fehlern (Adresse nicht gefunden, keine Daten) eine feste Ersatz-Location (im Code vorbelegt mit Koordinaten 52.5217, 13.4132 – Berlin, Brandenburger Tor). Das ist grundsätzlich gut, aber die Entscheidung passiert blind nach <em>jedem</em> Fehler. Beispielsweise wenn Overpass keine Daten liefert, wird sofort Berlin geladen – der Nutzer hat keine Chance, eine andere Eingabe zu versuchen, was verwirrend sein könnte („Warum bin ich plötzlich in Berlin?“). Hier wäre evtl. eine bessere Kommunikation oder ein alternativer Fallback (z.B. Radius erhöhen, andere nahe Adresse versuchen) wünschenswert.</li>
<li><strong>Overpass/API Limits:</strong> Nicht direkt ein UI-Thema, aber erwähnenswert: Weder Nominatim noch Overpass haben eine explizite Limitierung im Code (außer Timeout 10s bzw. 20s). Bei häufiger Nutzung könnten jedoch API-Limits erreicht werden. Der User-Agent ist gesetzt, was positiv ist. Dennoch: Caching von Ergebnissen (wenn dieselbe Adresse mehrfach gespielt wird) existiert nicht und auch keine Begrenzung, wie oft pro Zeiteinheit Daten geladen werden. In einem Endlosmodus könnte das relevant werden.</li>
</ul>
</li>
<li>
<p><strong>Abdeckung komplexer OSM-Features:</strong> Der Overpass-Query selbst sucht derzeit nur nach einfachen Wegen: <code>way[&quot;highway&quot;]</code>, <code>way[&quot;building&quot;]</code>, <code>way[&quot;leisure&quot;]</code>, <code>way[&quot;natural&quot;]</code>, <code>way[&quot;landuse&quot;]</code>, sowie Knoten <code>node[&quot;amenity&quot;]</code> und <code>node[&quot;shop&quot;]</code>. <strong>Relationen</strong> (Multipolygone) werden ignoriert. Das bedeutet, größere zusammengesetzte Gebäude oder Flächen, die in OSM als Relation vorliegen, würden fehlen. Beispiel: Ein Park, der als Multipolygon-Relation gemappt ist, würde vom obigen Query nicht erfasst und somit gar nicht erscheinen. Ebenso könnte ein Gebäude mit Innenhof (Multipolygon) fehlen. Dies ist ein fortgeschrittenes Thema, aber der Vollständigkeit halber zu nennen – aktuell bleibt dieser Aspekt unberücksichtigt und könnte zu lückenhaften Karten führen.</p>
</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="entwicklungsvorschläge-zur-verbesserung">Entwicklungsvorschläge zur Verbesserung<a href="#entwicklungsvorschläge-zur-verbesserung" class="hash-link" aria-label="Direkter Link zur Entwicklungsvorschläge zur Verbesserung" title="Direkter Link zur Entwicklungsvorschläge zur Verbesserung">​</a></h2>
<p>Um die Map-Generierung wirklich <strong>automatisch anhand echter OSM-Daten</strong> zu machen, sollten die folgenden Maßnahmen ergriffen werden:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1-echtes-parsing-der-overpass-api-daten">1. <strong>Echtes Parsing der Overpass-API-Daten</strong><a href="#1-echtes-parsing-der-overpass-api-daten" class="hash-link" aria-label="Direkter Link zur 1-echtes-parsing-der-overpass-api-daten" title="Direkter Link zur 1-echtes-parsing-der-overpass-api-daten">​</a></h3>
<p>Statt Dummy-Daten zu verwenden, muss die JSON-Antwort von Overpass vollständig ausgewertet werden. Konkret heißt das:</p>
<ul>
<li>
<p>Ein JSON-Parser verwenden (z.B. <strong>Newtonsoft.Json</strong> oder Unitys <code>JsonUtility</code>, wobei NewtonSoft flexibler mit verschachtelten Strukturen umgehen kann). Damit kann <code>ParseOSMResponse</code> die <strong><code>elements</code>-Liste</strong> der Overpass-Antwort durchlaufen.</p>
</li>
<li>
<p><strong>Mapping der OSM-Objekte:</strong> Für jedes Element:</p>
<ul>
<li>
<p>Falls <code>type == &quot;node&quot;</code>: einen <strong>OSMNode</strong> erstellen (ID, lat, lon, Tags). Zweck: Diese Nodes dienen als Punkte, die von Wegen referenziert werden.</p>
</li>
<li>
<p>Falls <code>type == &quot;way&quot;</code>: Prüfen auf Tags wie <em>&quot;highway&quot;</em>, <em>&quot;building&quot;</em>, <em>&quot;leisure/natural/landuse&quot;</em>:</p>
<ul>
<li>Hat der Way ein <code>&quot;highway&quot;</code>-Tag -&gt; neuen <strong>OSMWay</strong> erstellen und als <em>Straße</em> in <code>mapData.roads</code> aufnehmen.</li>
<li>Hat er ein <code>&quot;building&quot;</code>-Tag -&gt; neuen <strong>OSMBuilding</strong> erstellen (Unterklasse von OSMWay) und in <code>mapData.buildings</code> aufnehmen. Dabei <code>building.CalculateHeight()</code> ausführen, um Höhe aus Tags wie <code>height</code> oder <code>building:levels</code> zu ermitteln. So werden reale Höhen (falls vorhanden) übernommen oder anhand Stockwerken geschätzt (Standardeinstellung 3m pro Etage). Der Building-Typ (residential, commercial etc.) sollte ebenfalls aus dem Tag übernommen werden (wird in CalculateHeight schon gesetzt).</li>
<li>Hat er z.B. ein <code>&quot;leisure&quot;</code>-, <code>&quot;natural&quot;</code>- oder <code>&quot;landuse&quot;</code>-Tag (und <strong>kein</strong> building/highway): -&gt; neuen <strong>OSMArea</strong> erstellen und in <code>mapData.areas</code> aufnehmen. Danach <code>OSMArea.DetermineAreaType()</code> aufrufen, um den <strong>Typ</strong> festzulegen (Park, Wasser, Wald usw.) und ggf. eine Materialfarbe zu bestimmen. Diese Information nutzen wir später, um passendes Material zu wählen.</li>
<li><strong>Nodes zuordnen:</strong> Jeder Way-Eintrag hat eine Liste von Node-IDs. Hier muss man die zuvor erstellten OSMNode-Objekte per ID nachschlagen (ggf. in einem Dictionary id-&gt;OSMNode speichern) und dem Way hinzufügen. Wichtig: Wenn der erste und letzte Knoten identisch sind, markiert <code>OSMWay.IsClosed()</code> das Objekt als geschlossener Ring. Das ist relevant für Gebäude/Flächen.</li>
</ul>
</li>
<li>
<p>Falls <code>type == &quot;relation&quot;</code>: <strong>(Optional, für vollständige OSM-Unterstützung)</strong> Prüfen, ob es sich um Multipolygon-Relationen für Gebäude oder Flächen handelt (Tag <code>&quot;type&quot;:&quot;multipolygon&quot;</code> mit building/landuse Tags in den Relationen). Diese könnte man verarbeiten, indem man Outer-/Inner-Ways ermittelt. Dies ist allerdings komplex; ein einfacherer Workaround wäre, im Overpass-Query solche Relationen ebenfalls als <em>way</em> abzurufen (Overpass kann Relationen in Flächen umwandeln, z.B. mit <code>(relation[&quot;building&quot;](...); &gt;;); out geom;</code>). Wenn darauf verzichtet wird, würden manche großen Features fehlen – als pragmatische Lösung zunächst okay, aber perspektivisch eine mögliche Erweiterung.</p>
</li>
</ul>
</li>
<li>
<p><strong>Amenities/POIs</strong>: Die Query erfasst auch Nodes mit <code>&quot;amenity&quot;</code> oder <code>&quot;shop&quot;</code>. Diese könnten in <code>OSMMapData.pointsOfInterest</code> (<code>List&lt;OSMNode&gt;</code>) gespeichert werden. Momentan nutzt die Generierung diese Punkte nicht weiter, aber man könnte überlegen, sie als besondere Punkte darzustellen – z.B. <strong>zusätzliche Collectibles oder Marker</strong> auf der Karte (etwa eine andere Farbe/Symbol für ein bekanntes Wahrzeichen oder einen Shop). Zumindest sind die Daten da und könnten für Gameplay oder Deko genutzt werden (kein Muss für Funktion, aber Potenzial für später).</p>
</li>
</ul>
<p>Durch diese Parsing-Verbesserung wird <code>mapData.roads</code>, <code>.buildings</code>, <code>.areas</code> etc. echte OSM-Objekte der Umgebung enthalten. <strong>Die Platzhalter-Funktionen</strong> <code>CreateSampleRoads/Buildings()</code> sollten danach komplett entfernt oder nur noch als Fallback dienen, falls das Parsen fehlschlägt. Stattdessen validiert man: Wenn in der Overpass-Antwort <strong>gar keine</strong> Straße/Building gefunden wurde, kann man <code>mapData</code> als ungültig betrachten und einen Fehler melden („Keine Kartendaten für diese Region.“), anstatt künstlich etwas zu erfinden. Das informiert den Nutzer korrekt, z.B. wenn mitten in der Wildnis keine Wege sind. Der vorhandene OnError-Pfad würde dann greifen und ggf. den Fallback-Ort laden.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="2-detailgetreue-straßen-generierung">2. <strong>Detailgetreue <strong>Straßen</strong>-Generierung</strong><a href="#2-detailgetreue-straßen-generierung" class="hash-link" aria-label="Direkter Link zur 2-detailgetreue-straßen-generierung" title="Direkter Link zur 2-detailgetreue-straßen-generierung">​</a></h3>
<p>Mit realen Straßendaten im <code>OSMMapData</code> muss die <strong>Mesh-Erzeugung für Straßen überarbeitet</strong> werden, damit das Straßennetz korrekt erscheint:</p>
<ul>
<li>
<p><strong>Segmentweise statt gesamter Weg:</strong> Anstatt nur Start- zu Endpunkt zu verbinden, sollte <code>GenerateRoadFromWay</code> <strong>alle Segmente</strong> eines Weges generieren. Ein einfacherer Ansatz:</p>
<ul>
<li>Iteriere über jede aufeinanderfolgende Punkte-Paarung <code>(node[i], node[i+1])</code> des Weges.</li>
<li>Für jedes Segment ein <strong>straßenförmiges Mesh</strong> erzeugen. Das könnte weiterhin ein gestrecktes Quader-Primitive sein, aber es muss <strong>für jedes Teilstück</strong> ausgerichtet werden, nicht für den ganzen Weg auf einmal. D.h. man würde die <code>CreateRoadMesh</code>-Logik pro Segment anwenden (Position = Mittelpunkt des Segmentes, LookAt = auf Endpunkt des Segments, Länge = Distanz zwischen den beiden Knoten, Breite = je nach Straßentyp).</li>
<li>Diese Segment-Objekte sollte man als Kinder des Road-Containers platzieren. Gegebenenfalls kann man sie später zu einem Gesamtmesh kombinieren (siehe <strong>Batching</strong> unten).</li>
</ul>
</li>
<li>
<p><strong>Kurven und Kreuzungen:</strong> Mit obigem Verfahren werden gekrümmte Straßen sichtbar als polygonale Kette von geraden Abschnitten. Das ist völlig ausreichend; fließende Krümmung wäre unmerklich, solange genügend Zwischenknoten da sind (OSM-Wege sind meist so detailliert, dass Kurven durch viele kleine Segmente angenähert sind). An Kreuzungen werden sich Segmente von verschiedenen Straßen überlappen oder aneinanderstoßen. Das ist ok, man könnte aber überlegen, <strong>Kreuzungspunkte</strong> zu glätten: z.B. das letzte Segment einer Straße endet genau am Knoten, das erste Segment der kreuzenden Straße beginnt dort – meist ergeben sich kleine Lücken oder Überschneidungen. Anspruchsvolle Lösung: spezielle Kreuzungs-Meshes (z.B. quadratische Flächen) an Knoten generieren. Für den Anfang kann man das ignorieren; optisch wird es dennoch brauchbar sein.</p>
</li>
<li>
<p><strong>Straßenbreite &amp; Material nach Typ:</strong> In OSM verrät das <em>highway</em>-Tag die Art der Straße (motorway, primary, secondary, residential, footway, etc.). Man sollte diese Info nutzen, um <strong>Breitenvariationen</strong> zu erzeugen:</p>
<ul>
<li>Z.B. <em>motorway/primary</em> = deutlich breiter (evtl. 4–6 Unity-Einheiten), <em>residential</em> = schmal (~2), <em>footway</em> = ganz schmal (1 oder weniger). Die Variable <code>roadWidth</code> könnte als Basis für normale Straßen dienen, und man multipliziert je nach Kategorie.</li>
<li>Unterschiedliche <strong>Materialien/Texturen</strong> wären ideal (z.B. Asphaltstraße vs. Schotterweg vs. Fußweg). Im einfachsten Fall kann man auch mit Farbe arbeiten: breite Straßen dunklerer Grauton, Fußwege heller. Hierfür könnte man mehrere Materials im MapGenerator vorsehen (aktuell gibt es nur eins für roads).</li>
<li>Falls gewünscht, könnte man <strong>Straßenmarkierungen</strong> (Linien) oder Bordsteine als optische Details hinzufügen. Das wäre aber Zusatzaufwand – zunächst reicht es, visuell zwischen großen und kleinen Straßen zu unterscheiden, um dem Spieler Orientierung zu geben.</li>
</ul>
</li>
<li>
<p><strong>Höhenprofil:</strong> In diesem Projekt scheint alles flach auf einer Ebene zu liegen (keine Geländehöhen). OSM-Daten zu Höhenmetern werden nicht abgefragt (macht auch wenig Sinn ohne ein Gelände- oder Straßen-Höhenmodell). Man kann also davon ausgehen, dass alle Straßen plan auf y=0 bleiben – das ist okay.</p>
</li>
</ul>
<p>Durch diese Änderungen wird das <strong>Straßennetz im Spiel viel näher am echten Stadtplan</strong> liegen. Der Ball kann dann z.B. einem echten Straßenverlauf folgen. Wichtig ist, die Kollision beizubehalten: Die generierten Straßensegmente müssen wie bisher einen Collider bekommen, damit der Ball daran stößt oder darüber rollen kann. Hier sollte man auch darauf achten, dass Straßen <strong>flächenbündig mit dem Boden</strong> sind:</p>
<ul>
<li>Momentan haben die Straßencubes eine Höhe von 0.1 und werden zentriert auf y=0 platziert, d.h. sie ragen 0.05 nach unten und 0.05 nach oben. Das erzeugt minimale Kanten. Besser: Entweder Höhe auf 0 (rein flaches Quad) oder die Straße <strong>0.05 nach oben verschieben</strong>, sodass sie auf dem Boden aufliegt (y = 0.05). Dann gibt es keinen Versatz nach unten. Alternativ könnte man Straßen auch <strong>ohne Collider</strong> lassen und nur als visuelle Markierung betrachten, aber dann würden sie für das Gameplay keine Hindernisse darstellen – es sei denn, man will sie lediglich als unterschiedliche Boden-Textur und nicht als Hindernis. Hier ist eine Design-Entscheidung gefragt: Soll der Ball an Häusern hängenbleiben (ja), und an Straßen? Vermutlich nicht – Straßen sind ja keine Wände. Daher könnte man erwägen, <strong>Straßen-Collider zu entfernen</strong>, damit der Ball ungehindert darüberrollen kann (im Gegensatz zu Gebäuden, die blockieren sollen). Momentan sind Straßen minimal erhöht, was wie ein Rand wirken könnte. Wahrscheinlich wäre es sauberer, Straßen nur als Textur/Optik auf dem Boden zu haben. Man könnte stattdessen den <strong>GroundPlane</strong> in Straßengebieten anders einfärben oder Kacheln. Dies wäre aber eine größere Umstellung; zumindest sollte die 0.1-Höhe so angepasst werden, dass keine Stolperkanten entstehen.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="3-realistischere-gebäude-darstellung">3. <strong>Realistischere <strong>Gebäude</strong>-Darstellung</strong><a href="#3-realistischere-gebäude-darstellung" class="hash-link" aria-label="Direkter Link zur 3-realistischere-gebäude-darstellung" title="Direkter Link zur 3-realistischere-gebäude-darstellung">​</a></h3>
<p>Die Gebäude sollten aus den OSM-Umrissen generiert werden, um eine echte Stadtstruktur zu ergeben:</p>
<ul>
<li>
<p><strong>Grundriss als Polygon</strong>: Jeder <code>OSMBuilding</code> bringt eine Liste von Nodes mit, die den Umriss definieren (erster = letzter für geschlossene Form). Statt diese zu mitteln und einen Würfel zu platzieren, sollte man die Polygonpunkte verwenden, um ein <strong>Mesh</strong> zu bauen:</p>
<ul>
<li>Zuerst alle Punkte von Lat/Lon in Weltkoordinaten umrechnen (wird ja schon in <code>buildingPoints</code> Liste gemacht).</li>
<li>Dann ein <strong>Flächen-Mesh</strong> aus diesen Punkten erzeugen. Hierzu muss das Polygon trianguliert werden (in Dreiecke zerlegt). Unity bietet keine eingebaute Polygon-Triangulation für beliebige Polygone, aber man könnte einen simplen Algorithmus (Ear Clipping) implementieren oder auf einen externen Mesh-Generator zurückgreifen. Für rechteckige oder konvexe Formen ginge es relativ einfach. Für den Anfang könnte man sich auch auf einfachere Formen beschränken: Viele Gebäude sind rechteckig; man könnte erkennen, wenn ein Gebäude genau 4 Punkte hat (Rechteck), dann kann man einfach ein extrudiertes Quader-Mesh mit entsprechenden Kantenlängen erzeugen. Bei mehr Ecken oder L-Formen sollte man jedoch verallgemeinern.</li>
<li><strong>Extrudieren in die Höhe</strong>: Hat man die Dachfläche trianguliert, kann man die gleichen Polygone eine Höhe weiter unten als Boden ansetzen und die Seitenwände generieren (jeder Kantenabschnitt -&gt; ein Rechteck als Wand). Alternativ kann man einen Unity ProBuilder o.Ä. nutzen, aber vermutlich reicht eigener Code.</li>
<li>Ergebnis wäre ein <strong>prismenförmiges Gebäude</strong> genau entlang des OSM-Grundrisses mit richtiger Höhe.</li>
</ul>
</li>
<li>
<p><strong>Vereinfachte Alternative</strong>: Falls die vollständige Mesh-Generierung zu aufwendig ist, zumindest die Platzierung verbessern:</p>
<ul>
<li>Statt fester 5×5 Größe könnte man die <strong>Bounding Box</strong> des Gebäudepolygons berechnen und einen skalieren Cube in dieser Ausdehnung setzen. Dann stünde das Gebäude an korrekter Position und hätte ungefähr die richtige Länge/Breite. Allerdings passen Würfel nur für rechteckige Häuser wirklich – L-Formen würden dann immer noch nicht stimmen und könnten benachbarte Straßen überdecken. Diese Lösung ist also nur bedingt besser.</li>
<li>Dennoch sollte die <strong>Position</strong> wenigstens das tatsächliche Schwerpunktszentrum des Polygons sein (das wird ja schon gemacht) und man könnte die <strong>X/Z-Skalierung</strong> des Würfels so wählen, dass sie dem maximalen Nord-Süd bzw. Ost-West-Abstand der Punkte entspricht. So füllt der Kubus den Umriss zumindest aus.</li>
</ul>
</li>
<li>
<p><strong>Drehung</strong>: Sollte man einen Cube weiterverwenden, wäre es wichtig, ihn passend zu drehen. Aktuell werden alle Gebäude-Cubes gar nicht gedreht (Bleiben in Weltachsen ausgerichtet). Das führt dazu, dass z.B. ein längliches Gebäude diagonal zur Karte dennoch als Achsen-paralleler Würfel steht und evtl. Flächen außerhalb seines echten Grundrisses bedeckt. <strong>Lösung:</strong> die Hauptorientierung des Polygons ermitteln (z.B. mittels PCA – Hauptkomponentenanalyse der Punkte – oder einfach die Achse zwischen erstem und gegenüberliegendem Punkt, falls Rechteck) und den Gebäude-Würfel entsprechend rotieren. Bei exakter Polygonmesh-Erzeugung würde sich das automatisch durch die Punkte ergeben.</p>
</li>
<li>
<p><strong>Visuelle Aufwertung:</strong></p>
<ul>
<li>Unterschiedliche Gebäude-Typen könnten mit unterschiedlichen Materialien oder Farben versehen werden. Im Code wird <code>building.buildingType</code> gesetzt (z.B. industrial, residential). Man könnte z.B. Wohnhäuser rotbraun, Industrie grau, Bürogebäude blau anstreichen – oder Fenstermuster an Fassaden je nach Typ. Dafür könnte man mehrere <strong>Building-Materials</strong> definieren (oder ein Shader, der basierend auf Tag anders aussieht).</li>
<li><strong>Steampunk-Deko:</strong> Derzeit werden nur Industriebauten gelegentlich mit einem Partikelemitter „Rauch“ gekrönt. Hier ließe sich mehr machen: Vielleicht Tanks, Schornsteine oder Zahnrad-Props auf die Dächer setzen, speziell bei gewissen Gebäudetypen. Man könnte dafür kleine Prefabs vorbereiten (z.B. ein Zahnrad-Objekt), das via <code>AddSteampunkElementsToBuilding</code> zufällig angeheftet wird. Dies erhöht den Steampunk-Flair und visuelle Abwechslung.</li>
<li><strong>Collider:</strong> Die Gebäude bekommen einen MeshCollider. Wenn wir auf tatsächliche Meshes umstellen, muss das beibehalten werden, damit Gebäude solide Hindernisse bleiben. Das ist für das Gameplay wichtig (der Ball soll um sie herum navigieren müssen).</li>
</ul>
</li>
</ul>
<p>In Summe erhöhen diese Änderungen die <strong>Authentizität der Spielwelt</strong> erheblich – die Platzierung der Gebäude entspricht dann echten Städten, was sowohl optisch interessanter ist als auch neue Gameplay-Möglichkeiten bietet (z.B. Gassen zwischen Häusern, versteckte Ecken für Collectibles etc.).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="4-flächen-parks-gewässer-wälder-sinnvoll-darstellen">4. <strong>Flächen (Parks, Gewässer, Wälder) sinnvoll darstellen</strong><a href="#4-flächen-parks-gewässer-wälder-sinnvoll-darstellen" class="hash-link" aria-label="Direkter Link zur 4-flächen-parks-gewässer-wälder-sinnvoll-darstellen" title="Direkter Link zur 4-flächen-parks-gewässer-wälder-sinnvoll-darstellen">​</a></h3>
<p>Ähnlich den Gebäuden sollten auch Flächen mehr als nur ein zentrales Plane bekommen:</p>
<ul>
<li><strong>Polygon-Füllung:</strong> Ein Park oder See kann wie ein flaches Gebäude behandelt werden – im Prinzip ebenfalls ein (evtl. unregelmäßiges) Polygon, das nur wenige Meter Höhe hat (praktisch 0, da Boden). Man kann analog die <strong>Umrisspunkte triangulieren</strong> und eine flache Mesh-Fläche erzeugen.</li>
<li><strong>Größe skalieren:</strong> Falls man nicht trianguliert, könnte man zumindest die Plane-Größe an den Flächenumfang anpassen. Evtl. indem man die Punktwolke nimmt und wie bei Gebäuden eine Bounding Box daraus bildet, dann ein entsprechend skaliertes Plane auflegt. Allerdings werden komplexe Formen so schlecht abgebildet (z.B. langer schmaler Park wird eine übergroße Rechteckfläche und überlappt Gebäude). Daher wäre Triangulation hier sogar noch wichtiger als bei Gebäuden, weil Flächen in OSM oft sehr unregelmäßig sind (Flussläufe etc.).</li>
<li><strong>Material &amp; Farbe:</strong> MapGenerator nutzt <code>GetMaterialForAreaType</code> bereits, um Parkflächen grün, Wasser blau usw. zu färben. Diese Logik sollte beibehalten werden. Gegebenenfalls könnte man statt Unity-Standard-Plane auch eigene Texturen verwenden (z.B. Grastextur, Wasser mit Reflektion). Hierfür könnten die öffentlichen Variablen <code>parkMaterial</code>, <code>waterMaterial</code> noch mit passenden Materialien belegt werden (zurzeit vermutlich einfache Farben).</li>
<li><strong>Terrain vs. Mesh:</strong> Eine weitergehende Überlegung: Wenn große Areale generiert werden (z.B. ein riesiger Wald), könnte man überlegen, statt einzelner Meshes auf Unity-Terrain oder Tile-Maps zu setzen. Das lohnt aber erst bei wirklich großen, über den Bildschirm reichenden Flächen. Für 500m Umkreis sind Polygone noch handhabbar.</li>
</ul>
<p>Die Darstellung von Flächen macht die Umgebung lebendiger und gibt dem Spieler visuelle Anhaltspunkte (z.B. „Grünfläche = Park, dort könnten Collectibles liegen“ oder „Blau = Wasser, da kann der Ball vielleicht nicht drüber“ – ggf. könnte man auch <em>Wasser als Hindernis</em> betrachten, falls der Ball reinfällt -&gt; Tod/Respawn, aber das wäre extra Gameplay-Logik). Mindestens dienen die Flächen der Authentizität.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="5-performance-optimieren-batching-instancing">5. <strong>Performance optimieren (Batching, Instancing)</strong><a href="#5-performance-optimieren-batching-instancing" class="hash-link" aria-label="Direkter Link zur 5-performance-optimieren-batching-instancing" title="Direkter Link zur 5-performance-optimieren-batching-instancing">​</a></h3>
<p>Sobald echte Daten verwendet werden, steigt die Anzahl der GameObjects vermutlich stark (jede Straße in 5 Segmente, zig Gebäude etc.). Um die Performance (Draw Calls, Hierarchy Overhead) zu verbessern:</p>
<ul>
<li>
<p><strong>Mesh-Batching implementieren:</strong> Die vorhandenen Strukturen <code>roadMeshes</code> und <code>buildingMeshes</code> sollten genutzt werden. Ein möglicher Ansatz:</p>
<ul>
<li>Ändere <code>CreateRoadMesh</code> und <code>CreateBuildingMesh</code>, so dass sie <strong>nicht direkt</strong> ein GameObject zurückgeben, sondern <strong>Meshdaten</strong> produzieren. Man könnte z.B. die erzeugten Primitive-Cubes zwar erstellen, aber dann deren Mesh (MeshFilter.sharedMesh) in einen CombineInstance packen und das GameObject sofort zerstören. Oder man generiert die Mesh-Quads pro Straßensegment pro Script und fügt sie direkt zu CombineInstances hinzu (vermeidet überhaupt das Erstellen vieler GameObjects).</li>
<li>Nach Generierung aller Straßen-Segmente, ruft man <code>CombineMeshes</code> auf, um <strong>ein Gesamt-Mesh für alle Straßen</strong> zu bauen. Dieses kann dann einem einzigen GameObject (z.B. <code>AllRoads</code>) zugewiesen werden mit einem MeshFilter/MeshRenderer. Ähnlich für Gebäude: Hier wäre allerdings Vorsicht geboten – unterschiedliche Gebäudehöhen und -materialien: Wenn alle Gebäude das gleiche Material nutzen (aktuell ja <code>buildingMaterial</code> einheitlich), kann man sie zusammenfassen. Falls man Material nach Gebäudetyp unterscheiden möchte, müsste man je Material ein Kombinat machen.</li>
<li><strong>Collider</strong>: Wenn man alles kombiniert, verliert man die einzelnen MeshCollider. Eine große Kombi-MeshCollider für alle Straßen könnte problematisch sein (Unity hat Limits für MeshCollider-Größe/Performance). Alternativ kann man die Collider separat lassen (z.B. nicht kombinieren, oder vereinfachte Colliders verwenden – z.B. pro Straßensegment ein BoxCollider statt MeshCollider, da Straßen ja flach rechteckig sind). Für Gebäude ähnlich: Würfel könnte man als BoxCollider belassen, anstatt komplexe MeshCollider, wenn die Form einfach ist. Bei echten polygonalen Gebäuden braucht man evtl. doch MeshCollider, außer man berechnet konvexe Polygone und könnte ebenfalls Boxen approximieren. Das ist ein Performance-Tuning: im Zweifelsfall erst mal bei MeshColliders bleiben und nur optisch batchen.</li>
<li><strong>Static Batching</strong>: Da die Level nach Generierung statisch sind (nichts bewegt sich außer Ball und Collectibles), könnte man auch Unitys statisches Batching nutzen. Dazu müssten die Objekte als <code>Static</code> markiert werden. Unity würde dann intern zum Rendern sie batchen. Das ließe sich mit <code>GameObject.isStatic = true</code> beim Erzeugen setzen. Der Vorteil: weniger eigener Combine-Code, Nachteil: passiert erst zur Laufzeit auf der GPU, evtl. etwas Overhead, aber Unity macht das ganz gut für viele kleine Objekte. Trotzdem wäre ein manuelles CombineMeshes zur Laufzeit eine solide Lösung um die Objektzahl drastisch zu reduzieren.</li>
</ul>
</li>
<li>
<p><strong>Pooling</strong>: Da nach Levelabschluss neue Level generiert werden (endlosmodus), könnte man überlegen, Objekte wiederzuverwenden. Aktuell zerstört <code>ClearExistingMap()</code> alle alten GameObjects. Das ist der einfachste Weg, aber verursacht bei jedem Wechsel neue Allokationen. Pooling (Objekte deaktivieren und recyceln) wäre komplexer zu implementieren und lohnt nur, falls generierte Level sehr ähnlich sind (was nicht garantiert ist – andere Stadt hat ganz andere Topologie). Also vermutlich okay, immer neu aufzubauen und zu löschen.</p>
</li>
<li>
<p><strong>LOD / Distanzen</strong>: Bei 500m Radius und Unity-Scale=1m sind die gesamten Objekte innerhalb ~1000×1000 Einheiten – das ist nicht so groß, dass man über Level of Detail nachdenken müsste. Sollte man künftig größere Kartenabschnitte generieren (z.B. 2km), dann könnte es Sinn machen, entfernte Objekte (am Kartenrand) als vereinfachte Darstellung zu generieren oder per Fog ausblenden. Im aktuellen Rahmen ist das aber nicht dringend.</p>
</li>
<li>
<p><strong>Physics Optimierung</strong>: Je mehr Collider (für Gebäude) es gibt, desto mehr muss die Physik-Engine prüfen. Hier könnte man ggf. <strong>Collisions-Layer</strong> nutzen – z.B. alle Gebäude auf Layer „Obstacles“ und den Ball so einstellen, dass er nur mit „Obstacles“ kollidiert und nicht mit „Road“ etc., um Checks zu sparen. Der GroundPlane und Straßen könnten auf einem Layer liegen, der für den Ball keine Kollision prüft (falls Ball sowieso immer auf Boden bleibt). Das sind Micro-Optimierungen, die erst bei Performanceproblemen angegangen werden müssen.</p>
</li>
</ul>
<p>Zunächst ist die Priorität, <em>Batching</em> einzuführen, damit die Draw Calls sinken. Das Spiel sollte auf gängigen Rechnern flüssig laufen, selbst wenn 100 Gebäude da sind, aber VR/AR oder mobile Targets könnten empfindlich sein – da ist Batchen fast Pflicht.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="6-verbesserte-integration-in-spielfluss-und-levelsystem">6. <strong>Verbesserte Integration in Spielfluss und Levelsystem</strong><a href="#6-verbesserte-integration-in-spielfluss-und-levelsystem" class="hash-link" aria-label="Direkter Link zur 6-verbesserte-integration-in-spielfluss-und-levelsystem" title="Direkter Link zur 6-verbesserte-integration-in-spielfluss-und-levelsystem">​</a></h3>
<p>Um den Übergang nach Level 3 und den Endlosmodus umzusetzen, sind einige Änderungen am Level-Management nötig:</p>
<ul>
<li>
<p><strong>Levelübergang nach Level 3:</strong> Im <code>LevelManager.DetermineNextScene</code> sollte nach Level3 nicht mehr <code>return &quot;&quot;</code> erfolgen, sondern z.B. der Name der OSM-Generierungs-Szene zurückgegeben werden (angenommen, es gibt eine Szene &quot;Level_OSM&quot; im Projekt). Alternativ kann man auch schon im Unity-Editor bei Level3 den <code>nextSceneName</code> setzen (im LevelConfiguration von Level3) – der Code prüft das und lädt dann direkt diese Szene. So oder so muss definiert werden, <strong>welche Szene</strong> nach Level3 kommt. Vermutlich ist bereits eine Szene vorgesehen, in der MapStartupController, AddressResolver, MapGenerator etc. vorhanden sind (die Suche zeigte einen &quot;Level_OSM&quot; – ggf. diese).</p>
</li>
<li>
<p><strong>Automatisches Generieren vs. Nutzereingabe:</strong> Hier gibt es zwei denkbare Modi:</p>
<ol>
<li>
<p><strong>Freier OSM-Modus (manuelle Eingabe)</strong>: Der Spieler kann nach Belieben einen Ort eingeben und spielen. Das ist via MapStartupController ja schon möglich.</p>
</li>
<li>
<p><strong>Kampagnenmodus endlos (automatisch)</strong>: Nach Level 3 geht es weiter mit prozeduralen Levels, <em>ohne dass der Spieler jedes Mal eine Adresse eingeben muss</em>. Für diesen Modus sollte das Spiel <strong>selbstständig Orte auswählen</strong> oder zumindest einen Standardort verwenden. Einige Ideen:</p>
<ul>
<li>Man könnte eine Liste von interessanten Orten vorbereiten (im Code gibt es ja bereits <code>suggestedAddresses</code> mit Leipzig Markt, Brandenburger Tor etc.). Man könnte also Level 4 = Leipzig, Level 5 = Berlin, Level 6 = München usw. automatisch setzen. Ist die Liste durch, entweder zyklisch wiederholen oder zufällig wählen.</li>
<li>Alternativ tatsächlich <em>Zufallskoordinaten</em> nehmen, evtl. eingeschränkt auf Stadtgebiete. Reiner Zufall könnte den Spieler ins Nirgendwo setzen, was langweilig wäre. Besser: aus einer Liste von Großstädten weltweit oder in einem bestimmten Gebiet wählen.</li>
<li>Eine weitere Möglichkeit: <strong>Spielerstandort</strong> als Start für den Endlosmodus – z.B. Level 4 spielt in der eigenen Stadt des Spielers (sofern GPS verfügbar). Das wäre ein cooles Feature (Realitätstreue), allerdings nicht immer praktikabel (man will evtl. nicht vor der eigenen Haustür Roll-a-Ball spielen, sondern lieber bekannte Städte).</li>
<li>Für den Anfang ist vermutlich die <strong>Liste der vorgeschlagenen Orte</strong> der einfachste Ansatz. Man könnte in MapStartupController eine Funktion vorsehen, die beim Start der OSM-Szene prüft, ob sie im <em>Auto-Progression</em>-Modus läuft, und dann ohne UI-Eingabe sofort die AddressResolver mit einem voreingestellten Ort aufruft.</li>
</ul>
</li>
</ol>
<ul>
<li><strong>UI-Unterdrückung im Auto-Modus:</strong> Wenn Level4 automatisch generiert werden soll, soll der Spieler nicht jedes Mal das Adress-Eingabe-Panel sehen müssen. Man könnte MapStartupController so erweitern, dass er erkennen kann, ob er aus der LevelProgression heraus gestartet wurde. Beispielsweise könnte GameManager oder LevelManager einen Parameter setzen (vielleicht über PlayerPrefs oder eine static Variable) „NextLevelLocation“ oder einen einfachen bool „autoGenerateNext“. Dann könnte MapStartupController in Start() prüfen: falls autoGenerateNext=true, direkt <code>LoadMapFromCoordinates/Address</code> mit dem gewünschten Ort aufrufen, anstatt <code>ShowAddressInput()</code>. Die UI würde dann gar nicht erst angezeigt, sondern direkt der Ladevorgang beginnen.</li>
<li>Das <strong>Fallback</strong>-System könnte hier zweitverwertet werden: z.B. definieren wir den Fallback-Ort (Berlin) als Standard für auto-generierte Levels. Dann könnte man nach Level3 sagen: lade Fallback sofort (sofern der Spieler nicht manuell was auswählt).</li>
</ul>
</li>
<li>
<p><strong>Level-Abschluss in generierten Levels:</strong> Damit die Endlos-Schleife funktioniert, muss jedes generierte Level auch beendet werden können, und dann das nächste starten:</p>
<ul>
<li>
<p><strong>Collectibles/Goal Mechanik:</strong> Es gibt zwei typische Ansätze, um ein Levelende zu definieren: <em>alle Collectibles eingesammelt</em> oder <em>Erreichen eines Zielbereichs</em>. Im aktuellen Roll-a-Ball ist offenbar vorgesehen, dass das Einsammeln aller Objekte den LevelManager das Level beenden lässt. Zusätzlich existiert ein „GoalZone“ als Finish (vielleicht muss man nach Sammeln aller Items in diesen Bereich fahren, was dann LevelComplete auslöst).</p>
</li>
<li>
<p>Um das in generierten Levels konsistent zu machen, sollte der <strong>LevelManager auch in der OSM-Szene aktiv</strong> sein und von Beginn an die generierten Collectibles kennen. Lösung: Nachdem <code>MapGenerator</code> die Collectibles platziert hat, muss man den LevelManager darüber informieren. Einfache Anpassung: In <code>MapGenerator.PlaceCollectibles()</code> anstatt nur <code>UpdateCollectibleCount()</code> aufzurufen, iteriere über die erstellten Collectible-GameObjects und rufe <code>LevelManager.Instance.AddCollectible(collectibleController)</code> für jedes auf. Dadurch:</p>
<ul>
<li>wird <code>levelConfig.totalCollectibles</code> korrekt gesetzt,</li>
<li><code>OnCollectiblePickedUp</code> der Collectible-Controller wird im LevelManager abonniert,</li>
<li>und die UI zeigt die Anzahl an.</li>
</ul>
</li>
<li>
<p>Wichtig: Der LevelManager muss in der OSM-Szene vorhanden sein (kann z.B. als Singleton via DontDestroyOnLoad überleben oder man fügt einen ins OSM-Scene-Setup). Im Code sucht MapGenerator mit <code>FindFirstObjectByType&lt;LevelManager&gt;()</code> nach einem LevelManager. Falls der nicht gefunden wird (aktuell wahrscheinlich so, weil im OSM-Setup nur GameManager genutzt wird), sollte man einen hinzufügen.</p>
</li>
<li>
<p><strong>GoalZone</strong>: Ebenfalls sollte man sicherstellen, dass die generierte GoalZone als solche erkannt wird. In LevelManager wird das Ziel via Tag &quot;Finish&quot; oder Name &quot;GoalZone&quot; gesucht. MapGenerator setzt den Namen bereits auf &quot;GoalZone&quot;, aber vergisst, das Tag zu setzen. Es wäre ratsam, dem GoalZone-Prefab den Tag &quot;Finish&quot; zu geben, damit LevelManager.FindGoalZone es findet. So kann man z.B. die Logik haben: alle Collectibles aufsammeln, dann erscheint evtl. (oder war schon sichtbar) die GoalZone – der Spieler rollt rein, und das triggert LevelComplete. Ggf. muss man einen Trigger am GoalZone-Prefab haben, der beim OnTriggerEnter den LevelManager.ForceCompleteLevel() auslöst, falls Collectibles schon alle weg sind.</p>
</li>
<li>
<p><strong>Nächsten Level laden/generieren:</strong> Sobald <code>LevelManager</code> das Ende erkennt (oder via GoalZone-Trigger), wird <code>OnLevelCompleted</code> gefeuert und in <code>LevelCompleteSequence</code> die nächste Szene geladen. Hier muss – wie oben besprochen – die nächste Szene definiert sein, entweder dieselbe OSM-Szene erneut (wenn man immer neu lädt) oder man generiert im gleichen Scene weiter.</p>
<ul>
<li><strong>Variante 1 (Scene neu laden):</strong> Man könnte immer wieder &quot;Level_OSM&quot; neu laden. Das würde MapStartupController von vorn starten lassen (mit evtl. neuer Adresse). Das ist einfach, aber eventuell unsauber, da GameManager als DontDestroy-On-Load deklariert ist und evtl. doppelt vorhanden sein könnte. Müsste man prüfen, wie GameManager Singleton gehandhabt wird (im Code wird er bei LoadLevel nicht zerstört und bleibt).</li>
<li><strong>Variante 2 (in derselben Scene regenerieren):</strong> Man lässt <code>LevelCompleteSequence</code> keine neue Scene laden, sondern direkt <code>MapGenerator.RegenerateMap()</code> mit neuen Daten aufrufen. Das erfordert, den LevelManager ein wenig umzuschreiben, da er standardmäßig Scenes lädt. Evtl. könnte man bei DetermineNextScene = &quot;&quot; speziell abfangen: Wenn currentScene == &quot;Level_OSM&quot; und man will endlos bleiben, dann eine Routine aufrufen, die MapGenerator neu startet. Dies wäre eine Sonderbehandlung und vermischt LevelManager mit MapGenerator – nicht optimal.</li>
<li>Praktischer ist vermutlich doch, jedes Mal &quot;Level_OSM&quot; neu zu laden. Dabei kann man in <code>OnLevelCompleted</code> statt GameOver ein <strong>Reload</strong> anstoßen. Z.B. DetermineNextScene könnte &quot;Level_OSM&quot; zurückgeben, sodass in <code>LoadNextLevel()</code> die Scene neu geladen wird. Allerdings müsste man dann dem MapStartupController mitteilen, welche neue Location zu laden ist (z.B. nächste in Liste). Hier könnte man wie gesagt PlayerPrefs oder statische Variablen nutzen, um zwischen den Scene-Loads den nächsten Ort zu speichern.</li>
</ul>
</li>
<li>
<p><strong>Progression/Difficulty:</strong> Im Endlosmodus könnte man den Schwierigkeitsgrad steigern. Z.B. sukzessive:</p>
<ul>
<li>Mehr Collectibles platzieren (derzeit feste 2 pro Gebäude). Man könnte <code>collectiblesPerBuilding</code> nach jedem Level erhöhen oder abhängig von Levelnummer variieren.</li>
<li>Größerer Suchradius: Ein größeres Gebiet bedeutet mehr Objekte und potenziell längere Spielzeit pro Level. Z.B. Level4 = 500m, Level5 = 600m, etc. Allerdings wächst damit exponentiell die Datenmenge – Overpass könnte jenseits 1km in Städten sehr viele Elemente liefern. Das muss man testen; evtl. sollte man 500m belassen.</li>
<li>Zeitlimit: In LevelConfiguration gibt es Felder für Zeitlimit. Denkbar wäre, im Endlosmodus ein Zeitlimit einzuführen, das immer knapper wird, um Herausforderung zu erhöhen. Aktuell ist das aber optional (<code>hasTimeLimit</code> meist false).</li>
<li>Dies alles sind optionale Balancing-Überlegungen, die man je nach gewünschter Spielerfahrung anpassen kann.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Zusammengefasst: <strong>Nach Level 3</strong> sollte automatisiert die OSM-Level-Szene geladen werden, und dort entweder ein Standardort oder eine Abfolge von Orten ohne weitere Nutzereingabe generiert werden. <strong>Jedes generierte Level</strong> muss dann wiederum abgeschlossen werden können (durch Sammeln+Ziel oder nur Sammeln), worauf das nächste generiert wird. Diese Endlos-Schleife erfordert sorgfältiges Zusammenspiel von LevelManager, MapGenerator und ggf. dem UI/StartupController, damit es nahtlos und verständlich für den Spieler abläuft.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="7-vervollständigung-der-benutzerfunktionen-adresseingabe-gps">7. <strong>Vervollständigung der Benutzerfunktionen (Adresseingabe, GPS)</strong><a href="#7-vervollständigung-der-benutzerfunktionen-adresseingabe-gps" class="hash-link" aria-label="Direkter Link zur 7-vervollständigung-der-benutzerfunktionen-adresseingabe-gps" title="Direkter Link zur 7-vervollständigung-der-benutzerfunktionen-adresseingabe-gps">​</a></h3>
<p>Abseits der technischen Generierung sollten noch ein paar Kleinigkeiten im User Interface ausgebessert werden:</p>
<ul>
<li>
<p><strong>GPS-Ortsbestimmung:</strong> Der Button „aktueller Standort“ sollte wie vorgesehen mit dem Gerätel Standort arbeiten. In Unity bedeutet das:</p>
<ul>
<li>Vor dem ersten Aufruf <code>Input.location.Start()</code> ausführen und ein bisschen Zeit geben, bis <code>Input.location.status</code> auf <strong>Running</strong> ist (dies könnte asynchron im Hintergrund passieren, evtl. mit einem kleinen „Warten auf GPS...“-Hinweis).</li>
<li>Dann <code>Input.location.lastData.latitude/longitude</code> auslesen und an <code>AddressResolver.LoadMapFromCoordinates(lat, lon)</code> übergeben.</li>
<li>Fehlerfälle beachten: GPS deaktiviert oder keine Fix -&gt; entsprechende Fehlermeldung („Standort konnte nicht ermittelt werden.“) und evtl. auf Fallback gehen.</li>
<li>Im Editor/PC gibt es kein GPS – dort kann man wie jetzt einen Demo-Ort (Leipzig) verwenden oder den Button ausblenden. Der Code macht das bereits per Kommentar kenntlich. Man könnte z.B. eine Compiler-Direktive oder Laufzeit-Abfrage nutzen: auf echter mobiler Plattform GPS nutzen, im Editor festen Wert.</li>
</ul>
</li>
<li>
<p><strong>Adresssuche verfeinern:</strong> Derzeit wird die erste Nominatim-Treffermenge (limit=1) genommen. Das ist okay, aber bei unklaren Eingaben könnte man dem Nutzer mehrere Vorschläge zeigen. Da im UI bereits eine Suggestion-Liste für Beispieladressen existiert, könnte man diese evtl. dynamisch nutzen: z.B. während der Eingabe bereits Nominatim-Autocomplete abfragen (es gibt eine API dafür), um dem Nutzer mögliche Adressen vorzuschlagen. Das wäre Komfort, aber nicht zwingend.</p>
</li>
<li>
<p><strong>Fehlermeldungen deutlicher:</strong> Falls Overpass kein Ergebnis liefert, kommt die Meldung „Keine Kartendaten für diese Region verfügbar.“. Diese sollte dem Nutzer evtl. erklären, dass er einen anderen Ort versuchen soll (statt sofort nach Fallback zu wechseln, wenn man das Verhalten ändern möchte). Im jetzigen Code wird bei jedem Fehler automatisch Fallback geladen, sofern aktiviert. Überlegen, ob das immer gewollt ist: Wenn jemand z.B. „Atlantik“ eingibt, landet er ungefragt in Berlin – besser wäre evtl.: „Hier gibt es nichts – es wird eine Beispielkarte geladen.“ (So ähnlich wird es gemacht: die Fehlermeldung concatenated das bereits mit „Lade Fallback-Karte...“). Das passt schon, eventuell könnte man aber dem Spieler danach erlauben, doch noch eine andere Adresse einzugeben, anstatt ihn fix nach Berlin zu setzen. Ist jedoch Feinheit.</p>
</li>
<li>
<p><strong>Sprachliche Anpassungen:</strong> Die UI-Texte mischen derzeit Deutsch und Englisch (z.B. &quot;Level Complete!&quot; als Notification in LevelManager, aber Fehlermeldungen und Hinweise sind auf Deutsch). Hier könnte man für Konsistenz sorgen. Wahrscheinlich sollen Spielertexte alle Deutsch sein. Entsprechend &quot;Level abgeschlossen!&quot; statt &quot;Level Complete!&quot; etc. Gleiches gilt für evtl. &quot;Checkpoint erreicht!&quot; usw., falls das relevant ist.</p>
</li>
</ul>
<p>Durch diese UI-Verbesserungen wird der <strong>Bedienkomfort</strong> erhöht und die Features (Adresseingabe, aktueller Standort) funktionieren wie erwartet. Insbesondere die GPS-Funktion kann ein Alleinstellungsmerkmal sein – der Spieler kann sein eigenes Viertel oder einen realen Ort seiner Wahl im Spiel erleben.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="8-weiteres-feintuning-und-zukünftige-erweiterungen">8. <strong>Weiteres Feintuning und zukünftige Erweiterungen</strong><a href="#8-weiteres-feintuning-und-zukünftige-erweiterungen" class="hash-link" aria-label="Direkter Link zur 8-weiteres-feintuning-und-zukünftige-erweiterungen" title="Direkter Link zur 8-weiteres-feintuning-und-zukünftige-erweiterungen">​</a></h3>
<p>Abschließend noch ein paar Gedanken, die über das Muss hinausgehen, aber perspektivisch interessant sein können:</p>
<ul>
<li>
<p><strong>Mehr OSM-Elemente einbeziehen:</strong> Bisher liegen Fokus auf Straßen, Gebäuden, Flächen. Man könnte aus den OSM-Daten noch mehr herausziehen:</p>
<ul>
<li><strong>POIs als Objekte:</strong> Bereits erwähnt, Amenities/Shops könnten als spezielle Objekte im Spiel auftauchen – z.B. könnte man an POI-Koordinaten Power-ups oder Hindernisse spawnen, um das Gameplay zu erweitern (eine Fantasie: an der Position einer „Police Station“ ein Steampunk-Wachroboter als Gegner, oder bei &quot;Shop&quot; ein Bonus-Item etc.).</li>
<li><strong>Beschriftungen:</strong> Man könnte die wichtigsten Straßennamen oder Ortsschilder einblenden (via TextMeshPro 3D Text in der Szene). In einem Roll-a-Ball sind Label eher irrelevant fürs Gameplay, aber könnten das Gefühl einer echten Stadt verstärken.</li>
<li><strong>Verkehrselemente:</strong> Ampeln, Laternen, Bänke – all das ist theoretisch in OSM (amenity=bench etc.). Es wäre aber wahrscheinlich Overkill für dieses Spiel.</li>
</ul>
</li>
<li>
<p><strong>Gameplay-Mechanik auf Karte anpassen:</strong> Wenn die Karte komplexer wird (viele Gebäude, evtl. Sackgassen), sollte man prüfen, ob der Ball immer überall hinkann. Nicht dass Collectibles an unerreichbaren Stellen landen. Der Generator platziert sie zufällig um Gebäude und an Straßenrand. Das kann auch mal auf einem Dach oder mitten auf der Straße sein. Vielleicht sollte man sicherstellen, dass <code>y</code> der Collectibles immer knapp über Boden liegt und nicht auf Gebäudedächern (derzeit wird bei Gebäuden ein zufälliger Knoten genommen – das könnten auch Dach-Ecken sein, die jedoch in Weltkoordinaten auf Bodenprojektion umgerechnet werden, da LatLonToWorld Y=0 ausgibt). Wahrscheinlich landen sie also am Boden neben dem Gebäude – das passt. Falls man realistischer wäre, könnte man z.B. sagen: in Parks spawnen zusätzliche Collectibles, auf Wasser keine usw. Das sind Feineinstellungen, die man basierend auf Tests optimieren kann.</p>
</li>
<li>
<p><strong>Maßstabs-Verbesserung:</strong> Sollte der Anspruch bestehen, Entfernungen korrekt abzubilden, könnte man die <strong>Latitude-Kosinus-Korrektur</strong> einbauen: d.h. den Ost-West-Bereich in Metern berechnen als <code>(maxLon-minLon) * cos(Mittelbreite) * 111320</code>. Dann könnte man <code>scaleMultiplier</code> so setzen, dass z.B. <strong>1 Einheit = 1 Meter</strong> ist. In der Praxis würde man den Maßstab einfach als z.B. 1 Unity = 1m fixieren und die Lat/Lon in eine lokale Meterprojektion umrechnen (z.B. UTM oder Mercator auf die lokale Patch). Für den kleinen Maßstab reicht aber eine flache equirectangulare Projektion wie bisher. Nur sollte man konsequent den Umrechnungsfaktor so wählen, dass keine extremen Verzerrungen entstehen. Eventuell könnte man den <strong>Mittelpunkt</strong> der Karte als Bezugspunkt nehmen und alle Koordinaten in Meterabstände relativ dazu konvertieren (z.B. mit der haversine-Formel oder approximativ: Δlat in m = Δlat_deg * 111320; Δlon in m = Δlon_deg * 111320 * cos(lat)). Dann direkt diese Meter als Unity-Koordinaten verwenden (ggf. skaliert durch einen Faktor, falls man nicht 1:1 Meter haben will). Im Moment passiert die Skalierung indirekt über <code>scaleMultiplier</code>, was man beibehalten kann, aber definierter gestalten sollte (z.B. so, dass 500m Radius = 500 Unity-Einheiten). Das hätte den Vorteil, dass z.B. die Ball-Geschwindigkeit oder Sprungweite im Spiel realistischen Bezug hat – momentan weiß man das nicht genau, da 500m zu 1000 Units führt, also 1 Unit = 0.5 m ungefähr. Einheitlichkeit wäre wünschenswert, ist aber kein kritisch sichtbares Problem.</p>
</li>
</ul>
<p>Mit den oben vorgeschlagenen Änderungen würde die Karte <strong>automatisch und korrekt aus OSM-Daten generiert</strong> werden, was dem ursprünglichen Ziel entspricht. Die Verbesserungspotenziale liegen vor allem darin, aus den bislang statischen/Platzhalter-basierten Komponenten eine dynamische, realitätsgetreue Level-Umgebung zu formen und diese nahtlos ins Spiel einzubetten. Wichtig ist dabei, Schritt für Schritt vorzugehen – zunächst die Kernfunktion (OSM-Parsen und Basis-Objekte generieren), dann Feinschliff bei Optik und Performance, und schließlich die Integration ins Spieldesign (Level-Abfolge, Schwierigkeit, UI). So entsteht aus der vorhandenen Codebasis ein deutlich reichhaltigeres Spielerlebnis, in dem der Nutzer echte Orte als Spielwelt erleben kann.</p>
<p><strong>Quellen:</strong> Code-Analyse der bereitgestellten Klassen <em>AddressResolver</em> und <em>MapGenerator</em> aus dem Roll-a-Ball-Projekt, sowie zugehörige Manager-Klassen (LevelManager, MapStartupController) für das Zusammenspiel von Level-Logik und OSM-Integration. Die Hinweise im Code – etwa die temporären Platzhalter-Daten, die vereinfachte Mesh-Erstellung und die Kommentare zur geplanten prozeduralen Erweiterung – dienten als Grundlage für die obigen Verbesserungsvorschläge.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/161sam/Roll-a-Ball/edit/main/wiki/docs/development/Analyse_OSM-Kartengenerierung.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Diese Seite bearbeiten</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Dokumentation Seiten"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#aktueller-stand-der-implementierung" class="table-of-contents__link toc-highlight">Aktueller Stand der Implementierung</a></li><li><a href="#probleme-und-limitierungen-der-aktuellen-lösung" class="table-of-contents__link toc-highlight">Probleme und Limitierungen der aktuellen Lösung</a></li><li><a href="#entwicklungsvorschläge-zur-verbesserung" class="table-of-contents__link toc-highlight">Entwicklungsvorschläge zur Verbesserung</a><ul><li><a href="#1-echtes-parsing-der-overpass-api-daten" class="table-of-contents__link toc-highlight">1. <strong>Echtes Parsing der Overpass-API-Daten</strong></a></li><li><a href="#2-detailgetreue-straßen-generierung" class="table-of-contents__link toc-highlight">2. <strong>Detailgetreue <strong>Straßen</strong>-Generierung</strong></a></li><li><a href="#3-realistischere-gebäude-darstellung" class="table-of-contents__link toc-highlight">3. <strong>Realistischere <strong>Gebäude</strong>-Darstellung</strong></a></li><li><a href="#4-flächen-parks-gewässer-wälder-sinnvoll-darstellen" class="table-of-contents__link toc-highlight">4. <strong>Flächen (Parks, Gewässer, Wälder) sinnvoll darstellen</strong></a></li><li><a href="#5-performance-optimieren-batching-instancing" class="table-of-contents__link toc-highlight">5. <strong>Performance optimieren (Batching, Instancing)</strong></a></li><li><a href="#6-verbesserte-integration-in-spielfluss-und-levelsystem" class="table-of-contents__link toc-highlight">6. <strong>Verbesserte Integration in Spielfluss und Levelsystem</strong></a></li><li><a href="#7-vervollständigung-der-benutzerfunktionen-adresseingabe-gps" class="table-of-contents__link toc-highlight">7. <strong>Vervollständigung der Benutzerfunktionen (Adresseingabe, GPS)</strong></a></li><li><a href="#8-weiteres-feintuning-und-zukünftige-erweiterungen" class="table-of-contents__link toc-highlight">8. <strong>Weiteres Feintuning und zukünftige Erweiterungen</strong></a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Dokumentation</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/Roll-a-Ball/docs/intro">Entwicklungsübersicht</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Ressourcen</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/161sam/Roll-a-Ball" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://unity.com/" target="_blank" rel="noopener noreferrer" class="footer__link-item">Unity<svg width="13.5" height="13.5" aria-hidden="true" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">© 2025 Roll-a-Ball Projekt.</div></div></div></footer></div>
</body>
</html>